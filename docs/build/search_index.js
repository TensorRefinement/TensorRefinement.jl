var documenterSearchIndex = {"docs":
[{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = TensorRefinement","category":"page"},{"location":"index.html#TensorRefinement","page":"Home","title":"TensorRefinement","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"factor\nFactorSize\nFactor\nVectorFactor\nMatrixFactor\nfactorsize\nfactorranks\nfactorndims\nfactornumentries\nfactorstorage\nfactormatrix\nfactorrankselect\nblock\nfactorvcat\nfactorhcat\nfactordcat\nfactorltcat\nfactorutcat\nfactorranktranspose\nfactormodetranspose\nfactormodereshape\nfactordiagm\nfactorcontract\nfactormp\nfactorkp\nfactorhp\nfactorqr!\nfactorqradd\nfactorsvd!","category":"page"},{"location":"index.html#TensorRefinement.TensorTrain.factor","page":"Home","title":"TensorRefinement.TensorTrain.factor","text":"factor(U::Array{T,N}) where {T<:Number,N}\n\nReshape a given tensor U into a factor that can be used in further TT-operations.\n\nArguments\n\nU::Array{T, N}: Multi-dimensional array with elements of type T (subtype of FloatRC: any real or complex floating point) and with N as the number dimensions.\n\nReturns\n\nA reshaped version of the tensor U with a single first and last dimension to facilitate TT-operations.\n\n\n\n\n\nfactor(U::Matrix{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, \n       n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}, \n       π::Union{NTuple{K,Int}, Vector{Int}}) where {T<:Number, K, M, N}\n\nReshape a matrix U into a multi-dimensional array with specified mode sizes m and n,  and permute the mode dimensions according to the permutation π.\n\nArguments\n\nU::Matrix{T}: Input matrix with elements of type T.\nm::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the first dimension of U.\nn::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the second dimension of U.\nπ::Union{NTuple{K,Int}, Vector{Int}}: Permutation of the mode dimensions.\n\nReturns\n\nA reshaped and permuted tensor based on the provided mode sizes m, n, and permutation π.\n\nThrows\n\nArgumentError: If π is empty or not a valid permutation of 1:length(m) + length(n).\nArgumentError: If m or n is none of the following: integer, vector or tuple of integers, empty vector or tuple. \nDimensionMismatch: If the dimensions of U are not divisible by the products of m or n, respectively.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.FactorSize","page":"Home","title":"TensorRefinement.TensorTrain.FactorSize","text":"Factorsize is an alias for aVector{Int}`\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.Factor","page":"Home","title":"TensorRefinement.TensorTrain.Factor","text":"Factor{T,N} is an alias for Array{T,N} where {T<:Number,N}\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.VectorFactor","page":"Home","title":"TensorRefinement.TensorTrain.VectorFactor","text":"VectorFactor{T} is a 3D tensor with entries of type T`\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.MatrixFactor","page":"Home","title":"TensorRefinement.TensorTrain.MatrixFactor","text":"MatrixFactor{T} is a 4D tensor with entries of type T`\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.factorsize","page":"Home","title":"TensorRefinement.TensorTrain.factorsize","text":"factorsize(U::Factor{T,N}) where {T<:Number,N}\n\nDetermine the sizes of the mode dimensions of the given factor U in a vector, excluding the first and last dimensions.\n\nArguments\n\nU::Factor{T, N}: factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N as the number dimensions.\n\nReturns\n\nFactorsize(n): custom type Factorsize that holds the mode dimensions of U excluding the first and last dimension as a vector.\n\nThrows\n\nArgumentError: If factor exhibits only one or no rank dimension.\nArgumentError: If factor exhibits negative mode size.\n\nExample\n\nU = Factor(rand(3, 4, 5, 6, 7))  # Initialization of random Factor\nsize_vector = factorsize(U)  # Returns vector containing all but the first and last dimensions\nprintln(size_vector)  # Outputs FactorSize([4, 5, 6]) where Factorsize = Vector{Int}\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorranks","page":"Home","title":"TensorRefinement.TensorTrain.factorranks","text":"factorranks(U::Factor{T,N}) where {T<:Number,N}\n\nDetermine the first and last rank dimension of a given factor U.\n\nArguments\n\nU::Factor{T, N}: factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N as the number dimensions.\n\nReturns\n\nTuple (sz[1], sz[end]) where sz[1] is the first and sz[end] is the last dimension of the input tensor.\n\nThrows\n\nArgumentError: If factor exhibits only one or no rank dimension.\nArgumentError: If factor exhibits negative mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorndims","page":"Home","title":"TensorRefinement.TensorTrain.factorndims","text":"factorndims(::Factor{T,N}) where {T<:Number,N}\n\nReturn the number of mode dimensions excluding the first and last dimension.\n\nArguments\n\n::Factor{T, N}: factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N as the number dimensions.\n\nReturns\n\nAn integer representing the number of mode dimensions, which is N - 2 (number of entries in factorsize).\n\nThrows\n\nArgumentError: If factor exhibits only one or no rank dimension.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factornumentries","page":"Home","title":"TensorRefinement.TensorTrain.factornumentries","text":"factornumentries(U::Factor{T,N}) where {T<:Number,N}\n\nDetermine the number of entries in the given factor.\n\nArguments\n\nU::Factor{T, N}: factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N as the number dimensions.\n\nReturns\n\nAn integer specifiying the number of entries in the given [Factor].\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorstorage","page":"Home","title":"TensorRefinement.TensorTrain.factorstorage","text":"An alias for the function factornumentries.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormatrix","page":"Home","title":"TensorRefinement.TensorTrain.factormatrix","text":"factormatrix(U::Factor{T,K}, π::Indices, σ::Indices) where {T<:Number, K}\n\nConvert a factor U into a matrix by permuting and reshaping the mode dimensions according to the specified indices π and σ.\n\nArguments\n\nU::Factor{T,K}: Input factor of type Factor with elements of type T and K dimensions.\nπ::Indices: Reference numbers specifying the permutation of mode dimensions for the first dimension of the resulting matrix.\nσ::Indices: Reference numbers specifying the permutation of mode dimensions for the second dimension of the resulting matrix.\n\nReturns\n\nA matrix obtained by permuting and reshaping U according to the specified indices π and σ.\n\nThrows\n\nArgumentError: If U does not have at least one mode dimension.\nArgumentError: If π or σ are not valid indices or do not constitute a valid permutation of mode dimensions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorrankselect","page":"Home","title":"TensorRefinement.TensorTrain.factorrankselect","text":"factorrankselect(U::Factor{T,N}, α::Indices, β::Indices) where {T<:Number, N}\n\nSelect specific slices from a factor U based on the provided rank indices α and β.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nα::Indices: Reference numbers for selecting slices along the first rank dimension.\nβ::Indices: Reference numbers for selecting slices along the second rank dimension.\n\nReturns\n\nA sub-array of U corresponding to the specified slices.\n\nThrows\n\nArgumentError: If the indices α or β are incorrect or out of range for the respective rank dimensions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.block","page":"Home","title":"TensorRefinement.TensorTrain.block","text":"block(U::Factor{T,N}, α::Int, β::Int) where {T<:Number, N}\n\nExtracts a specific block from the factor U based on the provided rank indices α and β.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nα::Int: Reference numbers for selecting the slice along the first rank dimension.\nβ::Int: Reference numbers for selecting the slice along the second rank dimension.\n\nReturns\n\nA sub-array representing the block corresponding to the specified rank indices.\n\nThrows\n\nArgumentError: If the indices α or β are out of range for the respective rank dimensions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorvcat","page":"Home","title":"TensorRefinement.TensorTrain.factorvcat","text":"factorvcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T<:Number, N, M}\n\nVertically concatenate the factors U, V, and additional factors in W along the first rank dimension.\n\nArguments\n\nU::Factor{T,N}: First factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nW::Vararg{Factor{T,N},M}: Additional factors to be concatenated, each of Of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the vertical concatenation of U, V, and the additional factors in W.\n\nThrows\n\nArgumentError: If any of the factors have incompatible mode sizes or second ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorhcat","page":"Home","title":"TensorRefinement.TensorTrain.factorhcat","text":"factorhcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T<:Number, N, M}\n\nHorizontally concatenate the factors U, V, and additional factors in W along the second rank dimension.\n\nArguments\n\nU::Factor{T,N}: First factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nW::Vararg{Factor{T,N},M}: Additional factors to be concatenated, each of Of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the horizontal concatenation of U, V, and the additional factors in W.\n\nThrows\n\nArgumentError: If any of the factors have incompatible mode sizes or first ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factordcat","page":"Home","title":"TensorRefinement.TensorTrain.factordcat","text":"factordcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T<:Number, N, M}\n\nConcatenate the factors U, V, and additional factors in W along the mode dimensions and the second rank dimension.\n\nArguments\n\nU::Factor{T,N}: First factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nW::Vararg{Factor{T,N},M}: Additional factors to be concatenated, each of Of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the concatenation of U, V, and the additional factors in W along the mode dimensions and the second rank dimension.\n\nThrows\n\nArgumentError: If any of the factors have incompatible mode sizes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorltcat","page":"Home","title":"TensorRefinement.TensorTrain.factorltcat","text":"factorltcat(U₁₁::Factor{T,N}, U₂₁::Factor{T,N}, U₂₂::Factor{T,N}) where {T<:Number, N}\n\nConcatenate three factors U₁₁, U₂₁, and U₂₂ in a lower triangular block matrix form.\n\nArguments\n\nU₁₁::Factor{T,N}: First factor for the upper left block, with elements of type T and N dimensions.\nU₂₁::Factor{T,N}: Second factor for the lower left block, with elements of type T and N dimensions.\nU₂₂::Factor{T,N}: Third factor for the lower right block, with elements of type T and N dimensions.\n\nReturns\n\nA new factor representing the lower triangular concatenation of U₁₁, U₂₁, and U₂₂.\n\nThrows\n\nArgumentError: If the factors are incompatible in mode size or rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorutcat","page":"Home","title":"TensorRefinement.TensorTrain.factorutcat","text":"factorutcat(U₁₁::Factor{T,N}, U₁₂::Factor{T,N}, U₂₂::Factor{T,N}) where {T<:Number, N}\n\nConcatenate three factors U₁₁, U₁₂, and U₂₂ in an upper triangular block matrix form.\n\nArguments\n\nU₁₁::Factor{T,N}: First factor for the upper left block, with elements of type T and N dimensions.\nU₁₂::Factor{T,N}: Second factor for the upper right block, with elements of type T and N dimensions.\nU₂₂::Factor{T,N}: Third factor for the lower right block, with elements of type T and N dimensions.\n\nReturns\n\nA new factor representing the upper triangular concatenation of U₁₁, U₁₂, and U₂₂.\n\nThrows\n\nArgumentError: If the factors are incompatible in mode size or rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorranktranspose","page":"Home","title":"TensorRefinement.TensorTrain.factorranktranspose","text":"factorranktranspose(U::Factor{T,N}) where {T<:Number, N}\n\nTranspose the rank dimensions of the factor U.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor with the rank dimensions of U transposed.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormodetranspose","page":"Home","title":"TensorRefinement.TensorTrain.factormodetranspose","text":"factormodetranspose(U::Factor{T,N}, π::NTuple{K,Int}) where {T<:Number, N, K}\n\nPermute the mode dimensions of the factor U according to the permutation π.\n\nArguments\n\nU::Factor{T,N}: Input factor with elements of type T and N dimensions.\nπ::NTuple{K,Int}: Permutation of the mode dimensions of U. Should contain exactly K = N - 2 elements, which are a valid permutation of 1:d where d is the number of mode dimensions.\n\nReturns\n\nA new factor resulting from permuting the mode dimensions of U according to π.\n\nThrows\n\nArgumentError: If U has fewer than one mode dimension.\nArgumentError: If π is not a valid permutation of the mode dimensions of U.\nArgumentError: If π is not a valid permutation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormodereshape","page":"Home","title":"TensorRefinement.TensorTrain.factormodereshape","text":"factormodereshape(U::Factor{T,N}, n::FactorSize) where {T<:Number, N}\n\nReshape the mode dimensions of the factor U to the specified sizes in n.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nn::FactorSize: Vector specifying the new sizes for the mode dimensions. Product of n must equal the product of current mode sizes of U.\n\nReturns\n\nA new factor resulting from reshaping the mode dimensions of U to n.\n\nThrows\n\nDimensionMismatch: If the product of n does not equal the product of the current mode sizes of U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factordiagm","page":"Home","title":"TensorRefinement.TensorTrain.factordiagm","text":"factordiagm(U::Factor{T,N}) where {T<:Number, N}\n\nCreate a tensor with diagonal properties from the factor U by placing the elements of U along the diagonal of a larger-dimensional tensor.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor that represents a tensor with diagonal properties constructed from U, dimensions expanded.\n\nThrows\n\nArgumentError: If U has fewer than one mode dimension.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorcontract","page":"Home","title":"TensorRefinement.TensorTrain.factorcontract","text":"factorcontract(U::Factor{T,N}, V::Factor{T,N}; rev::Bool=false, major::String=\"last\") where {T<:Number, N}\n\nContract two factors U and V along their shared rank dimensions. Function supports contracting in different orientations and orders based on parameters rev and major.\n\nArguments\n\nU::Factor{T,N}: First input factor of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second input factor of type Factor with elements of type T and N dimensions.\nrev::Bool=false: If true, reverse the roles of U and V in the contraction.\nmajor::String=\"last\": Specifies major contraction order. Must be either \"last\" (default) or \"first\".\n\nReturns\n\nA new factor resulting from contracting U and V along their shared rank dimensions.\n\nThrows\n\nArgumentError: If U and V have inconsistent ranks\nArgumentError: If major is not \"last\" or \"first\".\n\n\n\n\n\nfactorcontract(U::Factor{T,N}, V::S) where {T<:Number, N, S<:AbstractMatrix{T}}\n\nContract a factor U with a matrix V, aligning the rank dimensions and performing matrix multiplication.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nV::S: Matrix of type S and elements of type T to contract with U.\n\nReturns\n\nA new factor resulting from the contraction of U with V.\n\nThrows\n\nArgumentError: If U and V have inconsistent ranks.\n\n\n\n\n\nfactorcontract(U::S, V::Factor{T,N}) where {T<:Number, N, S<:AbstractMatrix{T}}\n\nContracts a matrix U with a factor V, aligning the rank dimensions and performing matrix multiplication.\n\nArguments\n\nU::S: Matrix of type S and elements of type T to contract with V.\nV::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the contraction of U with V.\n\nThrows\n\nArgumentError: If U and V have inconsistent ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormp","page":"Home","title":"TensorRefinement.TensorTrain.factormp","text":"factormp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T<:Number, N₁, N₂}\n\nPerform a mode-wise multiplication (contraction) of two factors U₁ and U₂ along specified modes σ₁ and σ₂. Operation contracts the specified modes, while the remaining dimensions of the factors are combined.\n\nArguments\n\nU₁::Factor{T,N₁}: First factor of type Factor with elements of type T and N₁ dimensions.\nσ₁::Indices: Reference numbers specifying which modes of U₁ to use in the contraction. Can be a vector of integers or an empty vector.\nU₂::Factor{T,N₂}: Second factor of type Factor with elements of type T and N₂ dimensions.\nσ₂::Indices: Reference numbers specifying which modes of U₂ to use in the contraction. Can be a vector of integers or an empty vector.\n\nReturns\n\nA new factor resulting from the mode-wise multiplication of U₁ and U₂, with contracted modes combined and the remaining dimensions preserved.\n\nThrows\n\nArgumentError: If σ₁ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If σ₂ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If the specified sets of modes of σ₁ and σ₂ are inconsistent.\nArgumentError: If the set of modes of U₁ is specified incorrectly.\nArgumentError: If the set of modes of U₂ is specified incorrectly.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorkp","page":"Home","title":"TensorRefinement.TensorTrain.factorkp","text":"factorkp(U::Union{Factor{T,N}, Pair{Factor{T,N},Int}}, V::Vararg{Union{Factor{T,N}, Pair{Factor{T,N},Int}},M}) where {T<:Number,N,M}\n\nPerform a Kronecker product of multiple factors (optionally raised to specified nonnegative integer exponents).\n\nArguments\n\nU::Union{Factor{T, N}, Pair{Factor{T, N}, Int}}: first factor can either be a Factor type or a pair (Factor, Int). If given as a pair, the integer is the exponent for the respective factor in the Kronecker product.\nV::Vararg{Union{Factor{T, N}, Pair{Factor{T, N}, Int}}, M}: variable number (denoted by M) of additional factors, each of which can also be either a Factor type or a pair (Factor, Int). The same usage for the integer applies as in the above line.\n\nReturns\n\nW: resulting tensor (or matrix if d = 0) after the Kronecker products of all provided factors (with optionally some factors exponentiated). Final tensor is a result of a series of multiplications and reshaping operations.\n\nThrows\n\nArgumentError: If a negative exponent is provided in a pair (Factor, Int).\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorhp","page":"Home","title":"TensorRefinement.TensorTrain.factorhp","text":"factorhp(U::Factor{T,N}, V::Factor{T,N}) where {T<:Number, N}\n\nCompute the higher-order tensor product of two factors U and V. Resulting factor has dimensions formed by multiplying the ranks and mode sizes of U and V.\n\nArguments\n\nU::Factor{T,N}: First factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N dimensions.\nV::Factor{T,N}: Second factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N dimensions.\n\nReturns\n\nA reshaped tensor representing the higher-order product of U and V, with dimensions (p * r, n..., q * s) where:\n(p, q) are the ranks of U.\n(r, s) are the ranks of V.\nn represents the mode sizes of U and V.\n\nThrows\n\nArgumentError: If U and V do not have the same mode size.\n\n\n\n\n\nfactorhp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T<:Number, N₁, N₂}\n\nCompute the higher-order tensor product of two factors U₁ and U₂ along specified modes σ₁ and σ₂. Function allows for a flexible contraction over selected modes.\n\nArguments\n\nU₁::Factor{T,N₁}: First factor of type Factor with elements of type T and N₁ dimensions.\nσ₁::Indices: Reference numbers specifying which modes of U₁ to use in the contraction. Can be a vector of integers or an empty vector.\nU₂::Factor{T,N₂}: Second factor of type Factor with elements of type T and N₂ dimensions.\nσ₂::Indices: Reference numbers specifying which modes of U₂ to use in the contraction. Can be a vector of integers or an empty vector.\n\nReturns\n\nA reshaped tensor representing the higher-order product of U₁ and U₂, contracted over the specified modes.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If σ₁ or σ₂ are incorrectly specified or inconsistent with the dimensions of U₁ or U₂.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\nExtended Error list:\n\nArgumentError: If σ₁ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If σ₂ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If the specified sets of modes of σ₁ and σ₂ are inconsistent.\nArgumentError: If the set of modes of U₁ is specified incorrectly.\nArgumentError: If the set of modes of U₂ is specified incorrectly.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorqr!","page":"Home","title":"TensorRefinement.TensorTrain.factorqr!","text":"factorqr!(U::Factor{T,N}; rev::Bool=false, factf=(rev ? A -> LinearAlgebra.lq!(A) : A -> LinearAlgebra.qr!(A))) where {T<:FloatRC, N}\n\nPerform a QR or LQ factorization of the tensor U, depending on the value of the keyword argument rev (reverse). \n\nArguments\n\nU::Factor{T, N}: mutable factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N as the number dimensions.\nrev::Bool=false: keyword argument that determines the type of factorization. If false, performs a QR factorization; if true, performs an LQ factorization.\nfactf: keyword argument that specifies the chosen factorization function. By default, LinearAlgebra.qr! and LinearAlgebra.lq! are used respectively (depending on rev).\n\nReturns\n\ntuple (U, R), where:\nU: transformed tensor after applying the QR or LQ factorization. (N-dimensional)\nR: factor tensor obtained by reshaping the factor matrix of the QR or LQ factorization (N-dimensional)\n\n\n\n\n\nfactorqr!(U::Factor{T,N}, ::Val{true}; rev::Bool=false, returnS::Bool=false,\n          factf=(A -> LinearAlgebra.qr!(A, LinearAlgebra.ColumnNorm()))) where {T<:FloatRC, N}\n\nPerform a QR factorization of the factor U with optional pivoting and the ability to return an additional factor S. The function can cope with different orientations (via rev) and supports custom factorization functions.\n\nArguments\n\nU::Factor{T,N}: Factor to be decomposed, of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N dimensions.\n::Val{true}: Value type that indicates that this version of factorqr! should be used when returnS is needed.\nrev::Bool=false: Keyword argument that determines the orientation of the QR factorization.\nfalse (default): Standard QR factorization is performed.\ntrue: Roles of rows and columns are reversed, affecting the orientation of the factorization.\nreturnS::Bool=false: Keyword argument that specifies whether to return an additional factor S such that A ⨝ S = Q if rev == false and S ⨝ A = Q if rev == true.\nfactf: Function used to perform the QR factorization, default is set to LinearAlgebra.qr! with column pivoting.\n\nReturns\n\nQ, R: Factors Q (orthogonal) and R (upper triangular) from the QR decomposition.\nQ, R, S: If returnS == true, returns an additional factor S along with Q and R.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorqradd","page":"Home","title":"TensorRefinement.TensorTrain.factorqradd","text":"factorqradd(Q::Factor{T,N}, R::Union{Factor{T,N},Nothing}, U::Factor{T,N}; rev::Bool=false) where {T<:FloatRC, N}\n\nAdd rows or columns to an orthogonal factor Q and its corresponding upper triangular factor R, depending on the value of rev. This function is an extension to the QR factorization by updating the factors to incorporate a new matrix U.\n\nArguments\n\nQ::Factor{T,N}: Orthogonal factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and N dimensions.\nIf rev == true, Q is assumed to be orthogonal with respect to the first rank.\nIf rev == false, Q is assumed to be orthogonal with respect to the second rank.\nR::Union{Factor{T,N},Nothing}: Upper triangular factor of the QR factorization. Can be of type Factor or Nothing.\nIf R is Nothing, an identity matrix of appropriate dimensions will be used.\nU::Factor{T,N}: New matrix to be added to the existing factors (same mode dimensions as Q).\nrev::Bool=false: Keyword argument indicating the direction of orthogonality for the operation. \nfalse (default): Assumes Q to be orthogonal with respect to the second rank, and columns will be added.\ntrue: Assumes Q to be orthogonal with respect to the first rank, and rows will be added.\n\nReturns\n\nQ: Updated orthogonal factor after incorporating U.\nR: Updated upper triangular factor after incorporating U.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the mode sizes of Q and U are incompatible.\nArgumentError: If R has incompatible rank or mode dimensions with Q.\nArgumentError: If Q and U are incompatible in their respective ranks.\nArgumentError: If R is specified and has an incompatible number of mode dimensions or rank.\n\nExtended Error List:\n\nArgumentError: If the mode sizes of Q and U are incompatible.\nArgumentError: If R and Q have incompatible number of mode dimensions or incompatible number of unitary mode sizes.\nArgumentError: If R and Q have incompatible rank.\nArgumentError: If Q and U have incompatible second rank.\nArgumentError: If R  has a different number of mode dimensions as Q or different unitary mode sizes.\nArgumentError: If Q and R have incompatible rank.\nArgumentError: If Q and U have incompatible first rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorsvd!","page":"Home","title":"TensorRefinement.TensorTrain.factorsvd!","text":"function factorsvd!(W::Factor{T,N},\n                m::Union{FactorSize,Colon},\n                n::Union{FactorSize,Colon};\n\t\t\t\tsoft::S=zero(S),\n\t\t\t\thard::S=zero(S),\n                atol::S=zero(S),\n                rtol::S=zero(S),\n                rank::Int=0,\n                major::String=\"last\",\n\t\t\t\trev::Bool=false,\n\t\t\t\tfactf=(A -> LinearAlgebra.svd!(A; full=false, alg=LinearAlgebra.QRIteration())) ) where {S<:AbstractFloat,T<:FloatRC{S},N}\n\nPerform a singular value decomposition (SVD) of the factor W where the factor dimensions are adjusted accordingly and optional thresholding is carried out based on specified parameters. \n\nArguments\n\nW::Factor{T, N}: Input factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and N dimensions.\nm::Union{FactorSize, Colon}: Mode-size parameter for first dimension. Can be a FactorSize vector specifying the sizes of the mode dimensions or Colon to represent all indices.\nn::Union{FactorSize, Colon}: Mode-size parameter for second dimension. Can also be a FactorSize vector or Colon.\nsoft::S=zero(S): Keyword argument specifying the soft threshold for singular value truncation. Must be nonnegative and finite.\nhard::S=zero(S): Keyword argument specifying the hard threshold for singular value truncation. Must be nonnegative and finite.\natol::S=zero(S): Absolute tolerance for singular values. Must be nonnegative and finite.\nrtol::S=zero(S): Relative tolerance for singular values. Must be nonnegative and finite.\nrank::Int=0: Maximum allowable rank for the truncated SVD. Must be nonnegative.\nmajor::String=\"last\": Specifies the major contraction order. Must be either \"last\" (default) or \"first\".\nrev::Bool=false: Boolean indicating whether to reverse the dimensions in the output.\nfactf: Function used to perform the SVD. Default sets it to a function using LinearAlgebra.svd! with QRIteration.\n\nReturns\n\nU: The left singular vectors after applying SVD, reshaped based on the specified parameters (and potentially truncated).\nV: The right singular vectors after applying SVD, reshaped similarly (and also potentially truncated).\nε: The effective noise level that stems from thresholding.\nδ: The relative noise level, calculated as ε / μ.\nμ: The norm of the input factor W.\nρ: The rank of the truncated SVD.\nσ: A vector of the singular values (after thresholding).\n\nThrows\n\nSummarized Error List:\n\nArgumentError: If both m and n are specified as Colon, this causes ambiguity.\nArgumentError: If either m or n is specified with non-positive or inconsistent dimensions.\nArgumentError: If major is not \"first\" or \"last\".\nArgumentError: If soft, hard, atol, or rtol are negative or not finite.\nArgumentError: If rank is negative.\nDimensionMismatch: If mode-size vectors m and n are inconsistent with dimensions of W.\nErrorException: If numerical issues such as overflow or underflow occur during computations.\n\nFull Error List:\n\nArgumentError: If both m and n are specified as Colon, this causes ambiguity.\nArgumentError: If the elements of the first mode-size vector are not positive.\nArgumentError: If the elements of the second mode-size vector are not positive.\nArgumentError: If major is neither \"last\" (default) nor \"first\".\nArgumentError: If soft is negative or infinite.\nArgumentError: If hard is negative or finite.\nArgumentError: If atol is negative or infinte.\nArgumentError:  If rtol is negative or infinte.\nArgumentError: If optional argument rank is negative.\nDimensionMismatch: If the number of entries in the first mode-size vector is inconsistent with the specified factor.\nDimensionMismatch: If the number of entries in the second mode-size vector is inconsistent with the specified factor.\nDimensionMismatch: If not every mode dimension of W is divisible by the corresponding element of the specified mode-size vector\nDimensionMismatch: If specified mode-size vectors are inconsistent with the specified factor.\nErrorException: If squaring soft leads to overflow and it was passed finite.\nErrorException: If squaring soft leads to underflow and it was passed positive.\nErrorException: If sqauring hard leads to overflow and it was passed finite.\nErrorException: If squaring hard leads to underflow and it was passed positive.\nErrorException: If squaring atol leads to overflow and it was passed finite.\nErrorException: If squaring atol leads to underflow and it was passed positive.\n\nExample\n\n```julia\n\nAssume Factor{T, N}, FactorSize, and FloatRC are properly defined and initialized\n\nInitialize W as a Factor{T, N} type, for example, a decomposed tensor\n\nW = Factor(...)  # specific initialization needed\n\nSpecify mode-size parameters\n\nm = FactorSize([2, 3]) n = FactorSize([2, 2])\n\nPerform SVD with pre-specified thresholds and tolerances\n\nU, V, ε, δ, μ, ρ, σ = factorsvd!(W, m, n; soft=0.5, hard=0.05, atol=1e-6, rtol=1e-3, rank=10, major=\"last\")\n\nOutput the resulting factors and singular values\n\nprintln(\"Left singular vectors (U): \", U) println(\"Right singular vectors (V): \", V) println(\"Effective noise level (ε): \", ε) println(\"Relative noise level (δ): \", δ) println(\"Norm of the input factor (μ): \", μ) println(\"Rank of the truncated SVD (ρ): \", ρ) println(\"Singular values after thresholding (σ): \", σ)\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"Modules = [TensorRefinement]\nOrder = [:function, :type]\nPrivate = true","category":"page"}]
}
