var documenterSearchIndex = {"docs":
[{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = TensorRefinement","category":"page"},{"location":"index.html#TensorRefinement","page":"Home","title":"TensorRefinement","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to the documentation for TensorRefinement.jl. Below you will find the index followed by the different sections of the package:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Auxiliary","page":"Home","title":"Auxiliary","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the Auxiliary module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Indices\nFloatRC\nFloat2 \nFloat3 \nInt2\nInt3\nindvec \nthreshold \ncompfloateps \nmodemul \nqraddcols\nlqaddrows","category":"page"},{"location":"index.html#TensorRefinement.Auxiliary.Indices","page":"Home","title":"TensorRefinement.Auxiliary.Indices","text":"Indices is an alias for an object of type Vector{Int}, Int, UnitRange{Int}, StepRange{Int} or NTuple{M,Int}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.Auxiliary.FloatRC","page":"Home","title":"TensorRefinement.Auxiliary.FloatRC","text":"FloatRC{T} is an alias for an object of type T or Complex{T}, where T is an AbstractFloat.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.Auxiliary.Float2","page":"Home","title":"TensorRefinement.Auxiliary.Float2","text":"Float2{T} is an alias for an object of type T or Vector{T}, where T is an AbstractFloat.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.Auxiliary.Float3","page":"Home","title":"TensorRefinement.Auxiliary.Float3","text":"Float3{T} is an alias for an object of type T, Vector{T} or Vector{Vector{T}}, where T is an AbstractFloat.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.Auxiliary.Int2","page":"Home","title":"TensorRefinement.Auxiliary.Int2","text":"Int2 is an alias for an object of type Int or Vector{Int}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.Auxiliary.Int3","page":"Home","title":"TensorRefinement.Auxiliary.Int3","text":"Int3 is an alias for an object of type Int, Vector{Int} or Vector{Vector{Int}}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.Auxiliary.indvec","page":"Home","title":"TensorRefinement.Auxiliary.indvec","text":"indvec(σ::Indices; min::Int=1, max::Int=0)\n\nConvert several index specifications to a vector of integers. Function supports Julia indexing types like Colon, Int, UnitRange, StepRange, Tuple, and Nothing.\n\nArguments\n\nσ::Indices: Index specification. Can be of various types such as Colon, Int, UnitRange, StepRange, Tuple, Vector{Any}, or Nothing.\nmin::Int=1: Minimum value for the range (applicable when σ is Colon).\nmax::Int=0: Maximum value for the range (applicable when σ is Colon).\n\nReturns\n\nVector{Int}: Vector of integers derived from the specified index.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Auxiliary.threshold","page":"Home","title":"TensorRefinement.Auxiliary.threshold","text":"threshold(c::Vector{T}, τsoft::T, τhard::T, τ::T, r::Int)\n\nApply thresholding to the vector c based on soft, hard, and overall thresholds (τsoft, τhard, and τ). Optional truncation of the vector to maintain a specified rank r available.\n\nArguments\n\nc::Vector{T}: Vector of elements of Type T.\nτsoft::T: Soft threshold value. All elements less than or equal to this value are set to zero, all above are shrunken towards zero.\nτhard::T: Hard threshold value. All elements less than or equal to this value are set to zero.\nτ::T: Overall tolerance threshold. Elements are truncated based on this value.\nr::Int: Desired rank of the vector. Only the first r elements are kept, all others are being set to zero.\n\nReturns\n\nTuple{Vector{T}, T, Int}: Tuple containing the thresholded vector, the error (ε), and the new rank (ρ).\n\nThrows\n\nArgumentError: If τsoft is negative.\nArgumentError: If τhard is negative.\nArgumentError: If τ is negative.\nArgumentError: If r is negative.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Auxiliary.compfloateps","page":"Home","title":"TensorRefinement.Auxiliary.compfloateps","text":"compfloateps(::Type{S}) where {T<:AbstractFloat, S<:FloatRC{T}}\n\nReturn the machine epsilon (smallest difference between distinct floating point numbers) for the floating-point type T.\n\nArguments\n\nS::Type{S}: A type that is a subtype of FloatRC{T}, where T is a floating-point type (AbstractFloat).\n\nReturns\n\nT: The machine epsilon of the floating-point type T.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Auxiliary.modemul","page":"Home","title":"TensorRefinement.Auxiliary.modemul","text":"modemul(A::AbstractArray{<:Number,N}, B::Vararg{Pair{Int,<:AbstractMatrix{<:Number}},M}) where {N,M}\n\nPerform a mode multiplication of an N-dimensional array A with multiple matrices, each matrix corresponding to a specific mode (dimension) of A. Function applies several mode multiplications to the tensor A, such that it is transformed according to the provided matrices.\n\nArguments\n\nA::AbstractArray{<:Number,N}: N-dimensional array of type Number.\nB::Vararg{Pair{Int,<:AbstractMatrix{<:Number}},M}: Variable number of pairs (k, Bk), where k is the dimension index and Bk is a matrix to multiply A with along its k-th dimension.\n\nReturns\n\nA: The result of applying the mode multiplications, eventually, reshaped back to an N-dimensional array.\n\nThrows\n\nArgumentError: If any dimension index is out of bounds 1:ndims(A), or if any dimension indices are not distinct.\nArgumentError: If any matrix does not match the corresponding dimension size of the tensor.\nArgumentError: If the dimenion indices are not distinct.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Auxiliary.qraddcols","page":"Home","title":"TensorRefinement.Auxiliary.qraddcols","text":"qraddcols(Q::Matrix{T}, R::Matrix{T}, U::Matrix{T}) where T<:FloatRC\n\nExtend the QR decomposition by adding additional columns. Given an existing QR decomposition Q * R = A and a new matrix U, this function computes the QR decomposition of [A U].\n\nArguments\n\nQ::Matrix{T}: Orthogonal matrix from the QR decomposition of type T.\nR::Matrix{T}: Upper triangular matrix from the QR decomposition of type T.\nU::Matrix{T}: Matrix to be added to the existing QR decomposition of type T.\n\nReturns\n\nQ: Updated orthogonal matrix after adding new columns.\nR: Updated upper triangular matrix after adding new columns.\n\nThrows\n\nArgumentError: If Q and R are incompatible in rank.\nArgumentError: If Q and U are incompatible in the first rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Auxiliary.lqaddrows","page":"Home","title":"TensorRefinement.Auxiliary.lqaddrows","text":"lqaddrows(L::Matrix{T}, Q::Matrix{T}, U::Matrix{T}) where T<:FloatRC\n\nExtend the LQ decomposition by adding additional rows. Given an existing LQ decomposition L * Q = A and a new matrix U, this function computes the LQ decomposition of [L U]'. Currently, this function is not implemented.\n\nArguments\n\nL::Matrix{T}: Lower triangular matrix from the LQ decomposition of type T.\nQ::Matrix{T}: Orthogonal matrix from the LQ decomposition of type T.\nU::Matrix{T}: Matrix to be added to the existing QR decomposition of type T.\n\nReturns\n\nL: Updated lower triangular matrix after adding new rows. \nQ: Updated orthogonal matrix after adding new rows.\n\nThrows\n\nArgumentError: If L and Q are incompatible in size.\nArgumentError: If Q and U are incompatible in size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Chebyshev","page":"Home","title":"Chebyshev","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the Chebyshev module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"chebeval \nchebexnodes \nchebtochebex\nchebextocheb\nchebextoleg\nchebextolegn\nchebrtnodes\nchebtochebrt\nchebrttocheb\nchebrttoleg\nchebrttolegn\nchebtoleg\nchebtolegn\nlegtocheb\nlegntocheb\nchebref\nchebdiff\nchebexdiff\nchebdec\nchebdeceval!","category":"page"},{"location":"index.html#TensorRefinement.Chebyshev.chebeval","page":"Home","title":"TensorRefinement.Chebyshev.chebeval","text":"chebeval(t::Vector{T}, r::Int) where {T<:AbstractFloat}\n\nEvaluate the first r Chebyshev polynomials at the points specified in the vector t.\n\nArguments\n\nt::Vector{T}: Vector of points at which to evaluate the Chebyshev polynomials.\nr::Int: Number of Chebyshev polynomials to evaluate.\n\nReturns\n\nMatrix{T}: An n x r matrix V, where n is the length of t. The entry V[i,j]  contains the value of the (j-1)-th Chebyshev polynomial evaluated at t[i].\n\nThrows\n\nArgumentError: If r is negative.\n\n\n\n\n\nchebeval(t::Vector{T}, c::Vector{T}) where {T<:AbstractFloat}\n\nEvaluate a Chebyshev series for a given coefficient vector c at the points in t.\n\nArguments\n\nt::Vector{T}: Input vector of points specifying where the series is evaluated.\nc::Vector{T}: Coefficients of the Chebyshev series.\n\nReturns\n\nVector u containing the evaluation of the Chebyshev series at each point in t. That means, u[i] contains the evalutation of the Chebyshev series at point t[i] with coefficients from c.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebexnodes","page":"Home","title":"TensorRefinement.Chebyshev.chebexnodes","text":"chebexnodes(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the Chebyshev nodes of the second kind (also called « Chebyshev extrema ») on the interval [-1, 1].\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev nodes to compute.\n\nReturns\n\nVector of r Chebyshev nodes of the second kind.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebtochebex","page":"Home","title":"TensorRefinement.Chebyshev.chebtochebex","text":"chebtochebex(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev coefficients to Chebyshev extrema coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev coefficients to Chebyshev extrema coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebextocheb","page":"Home","title":"TensorRefinement.Chebyshev.chebextocheb","text":"chebextocheb(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev extrema coefficients to Chebyshev coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev extrema coefficients to Chebyshev coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebextoleg","page":"Home","title":"TensorRefinement.Chebyshev.chebextoleg","text":"chebextoleg(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev extrema coefficients to Legendre coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev extrema coefficients to Legendre coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebextolegn","page":"Home","title":"TensorRefinement.Chebyshev.chebextolegn","text":"chebextolegn(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev extrema coefficients to normalized Legendre coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev extrema coefficients to normalized Legendre coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebrtnodes","page":"Home","title":"TensorRefinement.Chebyshev.chebrtnodes","text":"chebrtnodes(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the Chebyshev nodes of the first kind (also called « Chebyshev roots ») on the interval (-1, 1).\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev roots to compute.\n\nReturns\n\nVector of r Chebyshev nodes of the first kind.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebtochebrt","page":"Home","title":"TensorRefinement.Chebyshev.chebtochebrt","text":"chebtochebrt(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix from Chebyshev polynomial coefficients to Chebyshev root polynomial coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev coefficients to Chebyshev root coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebrttocheb","page":"Home","title":"TensorRefinement.Chebyshev.chebrttocheb","text":"chebrttocheb(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix from Chebyshev root polynomial coefficients to Chebyshev polynomial coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev root coefficients to Chebyshev coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebrttoleg","page":"Home","title":"TensorRefinement.Chebyshev.chebrttoleg","text":"chebrttoleg(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev root coefficients to Legendre coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev root coefficients to Legendre coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebrttolegn","page":"Home","title":"TensorRefinement.Chebyshev.chebrttolegn","text":"chebrttolegn(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev root coefficients to normalized Legendre coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev root coefficients to normalized Legendre coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebtoleg","page":"Home","title":"TensorRefinement.Chebyshev.chebtoleg","text":"chebtoleg(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev coefficients to Legendre coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev coefficients to Legendre coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebtolegn","page":"Home","title":"TensorRefinement.Chebyshev.chebtolegn","text":"chebtolegn(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Chebyshev coefficients to normalized Legendre coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Chebyshev coefficients to normalized Legendre coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.legtocheb","page":"Home","title":"TensorRefinement.Chebyshev.legtocheb","text":"legtocheb(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from Legendre coefficients to Chebyshev coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Legendre polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from Legendre coefficients to Chebyshev coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.legntocheb","page":"Home","title":"TensorRefinement.Chebyshev.legntocheb","text":"legntocheb(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the transformation matrix that converts from normalized Legendre coefficients to Chebyshev coefficients.\n\nArguments\n\n::Type{T}: Type of the floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the transformation from normalized Legendre coefficients to Chebyshev coefficients.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebref","page":"Home","title":"TensorRefinement.Chebyshev.chebref","text":"chebref(ξ::T, η::T, r::Int) where {T<:AbstractFloat}\n\nCompute the Chebyshev reference matrix for interpolation between two points ξ and η. Currently, this function is not implemented.\n\nArguments\n\nξ::T: First one of the two points which are to be interpolated.\nη::T: Second one of the two points which are to be interpolated.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the reference for interpolation between ξ and η using the Chebyshev polynomials up to a degree of r-1.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\nchebref(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute the Chebyshev reference matrix (with entries of type T) for Chebyshev polynomials up to a degree of r-1.\n\nArguments\n\n::Type{T}: Type of floating-point numbers.\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the reference for the Chebyshev polynomials up to a degree of r-1.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\nchebref(r::Int)\n\nConvenience function to call chebref(Float64, r).\n\nArguments\n\nr::Int: Number of Chebyshev polynomials.\n\nReturns\n\nChebyshev reference matrix of size r × r, whose entries are of Type Float64.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebdiff","page":"Home","title":"TensorRefinement.Chebyshev.chebdiff","text":"chebdiff(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nComputes the differentiation matrix for Chebyshev polynomials of degree up to r-1.\n\nArguments\n\n::Type{T}: Numeric type for the matrix elements; subtype of AbstractFloat.\nr::Int: Number of Chebyshev polynomials (degree).\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the differentiation operator for Chebyshev polynomials of degree up to r-1.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebexdiff","page":"Home","title":"TensorRefinement.Chebyshev.chebexdiff","text":"chebexdiff(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nComputes the differentiation matrix for r Chebyshev extrema nodes.\n\nArguments\n\n::Type{T}: Numeric type for the matrix elements; subtype of AbstractFloat.\nr::Int: Number of extrema nodes.\n\nReturns\n\nMatrix{T}: A matrix of size r x r representing the differentiation operator for r Chebyshev extrema nodes.\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebdec","page":"Home","title":"TensorRefinement.Chebyshev.chebdec","text":"chebdec(c::Vector{T}, L::Int; major::String=\"last\") where {T<:AbstractFloat}\n\nConstruct a Chebyshev decomposition based on the coefficients c and the number of terms L.\n\nArguments\n\nc::Vector{T}: Vector of Chebyshev coefficients.\nL::Int: Number of terms in the decomposition.\nmajor::String: Order of decomposition, either \"first\" or \"last\" (default is \"last\").\n\nReturns\n\nDec{T,N}: A decomposition consisting of factors obtained by the reference matrices of Chebyshev polynomials.\n\nThrows\n\nArgumentError: If majoris neither\"first\"nor\"last\"`.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Chebyshev.chebdeceval!","page":"Home","title":"TensorRefinement.Chebyshev.chebdeceval!","text":"chebdeceval!(U::Dec{T,N}, t::Vector{T}; major::String=\"last\") where {T<:AbstractFloat,N}\n\nEvaluate a Chebyshev decomposition U at the points specified in t, and modify it in place.\n\nArguments\n\nU::Dec{T,N}: Chebyshev decomposition to evaluate.\nt::Vector{T}: Vector of points at which to evaluate the decomposition.\nmajor::String: Order of decomposition, either \"first\" or \"last\" (default is \"last\").\n\nReturns\n\nDec{T,N}: The evaluated decomposition U at points t.\n\nThrows\n\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#Exponential","page":"Home","title":"Exponential","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the Exponential module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"trigevalmask\ntrigeval\ntrigrefmask\ntrigrefmask2\ntrigdiffmask\ntrigdiff\ntrigdec\ntrigdeceval!\ncosfactor\ncosdec","category":"page"},{"location":"index.html#TensorRefinement.Exponential.trigevalmask","page":"Home","title":"TensorRefinement.Exponential.trigevalmask","text":"trigevalmask(t::Vector{T}, ν::Vector{T}) where {T<:AbstractFloat}\n\nEvaluate the trigonometric functions cosine and sine at a set of points t for a given set of frequencies ν.\n\nArguments\n\nt::Vector{T}: Vector of points where the trigonometric functions are evaluated.\nν::Vector{T}: Vector of frequencies for which the trigonometric functions are computed. Length of ν determines the number of cosine-sine pairs.\n\nReturns\n\nMatrix{T}: A matrix of size (n, 2*r), where n is the length of t and r is the length of ν. Each row contains alternating cosine and sine values for the corresponding point in t and frequency in ν.\n\nThrows\n\nArgumentError: If the number of frequencies r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.trigeval","page":"Home","title":"TensorRefinement.Exponential.trigeval","text":"trigeval(t::Vector{T}, ν::Vector{T}, c::Vector{T}) where {T<:AbstractFloat}\n\nEvaluate a trigonometric series with given frequencies ν and coefficients c at a set of points t. Each element in t is evaluated as the sum of cosine and sine terms for  each frequency in ν with the weight corresponding to the coefficients in c.\n\nArguments\n\nt::Vector{T}: Vector of points where the trigonometric series is evaluated.\nν::Vector{T}: Vector of frequencies for the trigonometric series. Length of ν determines the number of cosine-sine pairs.\nc::Vector{T}: Vector of coefficients, where each pair of consecutive elements corresponds to the cosine and sine weights for a particular frequency.\n\nReturns\n\nVector{T}: Vector of length n (the length of t) which represents the values of the trigonometric series evaluated at each point in t.\n\nThrows\n\nArgumentError: If the number of frequencies r is not positive.\nArgumentError: If the length of c is not 2*r, rendering ν and c incompatible in size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.trigrefmask","page":"Home","title":"TensorRefinement.Exponential.trigrefmask","text":"trigrefmask(η::T, ν::Vector{T}) where {T<:AbstractFloat}\n\nConstruct a reference mask for trigonometric transformations, based on a shift η and a set of frequencies ν.\n\nArguments\n\nη::T: Shift value for the trigonometric transformations.\nν::Vector{T}: Vector of frequencies. Each frequency corresponds to a 2x2 block in the resulting matrix.\n\nReturns\n\nMatrix{T}: Square matrix of size 2*r × 2*r, where r is the length of ν. Each 2x2 block contains the sine and cosine values for the corresponding frequency in ν, rotated by η.\n\nThrows\n\nArgumentError: If the number of frequencies r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.trigrefmask2","page":"Home","title":"TensorRefinement.Exponential.trigrefmask2","text":"trigrefmask2(ν::Vector{T}) where {T<:AbstractFloat}\n\nConstruct a reference mask for trigonometric interpolation using two points at -1/2 and 1/2.\n\nArguments\n\nν::Vector{T}: Vector of frequencies.\n\nReturns\n\nArray{T,3}: Three-dimensional array of size 2r × 2r × 2, where r is the length of ν.\n\nThrows\n\nArgumentError: If ν is empty (i.e., r == 0).\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.trigdiffmask","page":"Home","title":"TensorRefinement.Exponential.trigdiffmask","text":"trigdiffmask(ν::Vector{T}) where {T<:AbstractFloat}\n\nConstructs a differentiation mask for trigonometric functions based on the given frequencies.\n\nArguments\n\nν::Vector{T}: Vector of frequencies.\n\nReturns\n\nMatrix{T}: Square matrix of size 2r × 2r, where r is the length of ν.\n\nThrows\n\nArgumentError: If the number of frequencies r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.trigdiff","page":"Home","title":"TensorRefinement.Exponential.trigdiff","text":"trigdiff(ν::Vector{T}, c::Vector{T}) where {T<:AbstractFloat}\n\nPerform differentiation on trigonometric functions with the given frequencies ν and coefficients c.\n\nArguments\n\nν::Vector{T}: Vector of frequencies.\nc::Vector{T}: Vector of coefficients, which must be of length 2r, where r is the length of ν.\n\nReturns\n\nVector{T}: Vector of differentiated coefficients of length 2r.\n\nThrows\n\nArgumentError: If the length of c does not match 2r, rendering v and c incompatible in size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.trigdec","page":"Home","title":"TensorRefinement.Exponential.trigdec","text":"trigdec(ν::Vector{T}, c::Vector{T}, L::Int; major::String=\"last\") where {T<:AbstractFloat}\n\nConstruct a trigonometric decomposition based on frequencies ν and coefficients c.\n\nArguments\n\nν::Vector{T}: Vector of frequencies.\nc::Vector{T}: Vector of coefficients, which must be twice the length of ν.\nL::Int: Length of the decomposition.\nmajor::String: Either \"first\" or \"last\", specifying the major dimension of the decomposition (default is \"last\").\n\nReturns\n\nDec{T,N}: Decomposition U of length L where the first factor is based on the coefficients c, and the remaining factors are based on trigonometric reference masks.\n\nThrows\n\nArgumentError: If ν and c have incompatible sizes.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.trigdeceval!","page":"Home","title":"TensorRefinement.Exponential.trigdeceval!","text":"trigdeceval!(U::Dec{T,N}, t::Vector{T}, ν::Vector{T}; major::String=\"last\") where {T<:AbstractFloat,N}\n\nEvaluate a trigonometric decomposition U at a set of points t and frequencies ν, modifying the decomposition in place.\n\nArguments\n\nU::Dec{T,N}: Decomposition to be evaluated.\nt::Vector{T}: Vector of points at which to evaluate the decomposition.\nν::Vector{T}: Vector of frequencies.\nmajor::String: Either \"first\" or \"last\", specifying the major dimension of the decomposition (default is \"last\").\n\nReturns\n\nDec{T,N}: Evaluated and accordingly updated decomposition U.\n\nThrows\n\nArgumentError: If major is neither \"first\" nor \"last\".\nArgumentError: If N ≠ 3, i.e., if there are factors whose number of mode indices is not 1.\nArgumentError If the first or last rank of U and the size of ν are incompatible.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.cosfactor","page":"Home","title":"TensorRefinement.Exponential.cosfactor","text":"cosfactor(τ::Vector{T}, c::T) where {T<:AbstractFloat}\n\nConstruct a factorized cosine-sine matrix for each value of τ using the scaling value c.\n\nArguments\n\nτ::Vector{T}: Vector of angles in radians.\nc::T: Value used in scaling the cosine and sine terms.\n\nReturns\n\nArray{T,3}: Three-dimensional array of size 2 × n × 2, where n is the length of τ.\n\nThrows\n\nArgumentError: If τ is empty (i.e., n == 0).\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Exponential.cosdec","page":"Home","title":"TensorRefinement.Exponential.cosdec","text":"cosdec(τ::Vector{Vector{T}}, c::Vector{T}) where {T<:AbstractFloat}\n\nConstruct a cosine-based decomposition given a set of angles τ and coefficients c.\n\nArguments\n\nτ::Vector{Vector{T}}: Vector whose elements are vectors of angles in radians.\nc::Vector{T}: Vector of coefficients corresponding to the angles in τ.\n\nReturns\n\nDec{T,N}: Decomposition U where each of the L elements is a cosine matrix turned into a factor.\n\nThrows\n\nArgumentError: If τ and c are of different lengths.\nArgumentError: If any element of τ is empty.\n\n\n\n\n\n","category":"function"},{"location":"index.html#FEM","page":"Home","title":"FEM","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the FEM module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"extdn\nextdd\ndiffdn \ndiffdd \ndint\ndintf\nbpxdn\nbpxdd\nextmix\ndiffbpxdn\ndiffbpxdd","category":"page"},{"location":"index.html#TensorRefinement.FEM.extdn","page":"Home","title":"TensorRefinement.FEM.extdn","text":"extdn(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nGenerate a matrix decomposition which specifies ... based on the parameters provided.\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nℓ::Int: Index of the current factor.\nd::Int: ...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition P representing ...\n\nThrows\n\nArgumentError: If L is not positive.\nArgumentError: If ℓ is not in 0:L.\nArgumentError: If d is not positive.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.extdd","page":"Home","title":"TensorRefinement.FEM.extdd","text":"extdd(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nGenerate a matrix decomposition specifiying... \n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nℓ::Int: Index of the current factor.\nd::Int: Size of the ...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition P representing ...\n\nThrows\n\nArgumentError: If L is not positive.\nArgumentError: If ℓ is not in 1:L.\nArgumentError: If d is not positive.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.diffdn","page":"Home","title":"TensorRefinement.FEM.diffdn","text":"diffdn(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nConstruct a matrix decomposition that represents ...\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nℓ::Int: Index of the current factor.\nd::Int: Size of the ...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition M representing ...\n\nThrows\n\nArgumentError: If L is negative.\nArgumentError: If ℓ is not in 0:L.\nArgumentError: If d is not positive.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\ndiffdn(::Type{T}, L::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nSentence summarizing the function.\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the ...\nmajor::String=\"last\": Specifies the major axis (\"first\" or \"last\") for the operation. The default is \"last\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition M representing ...\n\nThrows\n\nArgumentError: If L is negative.\nArgumentError: If d is not positive.\nArgumentError: If major is neither \"first\" or \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.diffdd","page":"Home","title":"TensorRefinement.FEM.diffdd","text":"diffdd(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nConstruct a matrix decomposition representing ... based on the parameters provided.\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nℓ::Int: Index of the current factor. Should be in the range 1:L.\nd::Int: Size of the...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition M representing ...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If ℓ is not in 1:L.\nArgumentError: If d is less than 1.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\ndiffdd(::Type{T}, L::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nSummary Sentence for function.\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the...\nmajor::String=\"last\": Specifies the major axis (\"first\" or \"last\") for the operation. The default is \"last\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition M representing ...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If d is less than 1.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.dint","page":"Home","title":"TensorRefinement.FEM.dint","text":"dint(::Type{T}, L::Int, d::Int, K::AbstractMatrix{T}; major::String=\"last\") where {T<:FloatRC}\n\nConstruct a decomposition representing integration ... with a given coefficient matrix K.\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the ...\nK::AbstractMatrix{T}: Coefficient matrix, should be of size (d+1, d+1).\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nDec{T,N}: Decomposition Λ representing the integration.\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If d is less than 1.\nArgumentError: If K is not of size (d+1, d+1).\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.dintf","page":"Home","title":"TensorRefinement.FEM.dintf","text":"dintf(::Type{T}, L::Int, d::Int, K::AbstractMatrix{T}; major::String=\"last\") where {T<:FloatRC}\n\nConstruct a decomposition representing integration ... with a given coefficient matrix K.\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the ...\nK::AbstractMatrix{T}: Coefficient matrix, should be of size (d+1, d+1).\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nDec{T,N}: Decomposition Λ representing the integration...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If d is less than 1.\nArgumentError: If K is not of size (d+1, d+1).\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.bpxdn","page":"Home","title":"TensorRefinement.FEM.bpxdn","text":"bpxdn(::Type{T}, L::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nConstruct a decomposition representing ...\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nDec{T,N}: Decomposition C representing ...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If d is less than 1.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.bpxdd","page":"Home","title":"TensorRefinement.FEM.bpxdd","text":"bpxdd(::Type{T}, L::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nConstruct a decomposition representing ...\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the ... \nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nDec{T,N}: Decomposition C representing ...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If d is less than 1.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.extmix","page":"Home","title":"TensorRefinement.FEM.extmix","text":"extmix(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nConstruct a decomposition representing ... for a given set of parameters.\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nℓ::Int: Current factor index (must be between 0 and L).\nd::Int: Size of the...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition E representing ...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If ℓ is not in the range 0:L.\nArgumentError: If d is less than 1.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.diffbpxdn","page":"Home","title":"TensorRefinement.FEM.diffbpxdn","text":"diffbpxdn(::Type{T}, L::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nGenerate a decomposition representing ... using ...\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the ...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition M representing ...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If d is less than 1.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.FEM.diffbpxdd","page":"Home","title":"TensorRefinement.FEM.diffbpxdd","text":"diffbpxdd(::Type{T}, L::Int, d::Int; major::String=\"last\") where {T<:FloatRC}\n\nGenerate decomposition representing ... using ...\n\nArguments\n\n::Type{T}: Numeric type (subtype of FloatRC).\nL::Int: Total number of factors in the decomposition.\nd::Int: Size of the ...\nmajor::String: Specifies the major dimension of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nMatrixDec{T}: Matrix decomposition M representing ...\n\nThrows\n\nArgumentError: If L is less than 1.\nArgumentError: If d is less than 1.\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#Legendre","page":"Home","title":"Legendre","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the Legendre module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"legeval \nlegneval \nlegtolegn\nlegntoleg\nlegdiff\nlegndiff \nlegref\nlegnref \nlegdec\nlegdeceval!","category":"page"},{"location":"index.html#TensorRefinement.Legendre.legeval","page":"Home","title":"TensorRefinement.Legendre.legeval","text":"legeval(t::Vector{T}, r::Int) where {T<:AbstractFloat}\n\nEvaluate the first r Legendre polynomials at the points specified in the vector t.\n\nArguments\n\nt::Vector{T}: Vector of points at which to evaluate the Legendre polynomials.\nr::Int: Number of Legendre polynomials to evaluate.\n\nReturns\n\nMatrix{T}: An n x r matrix V, where n is the length of t. The entry V[i,j]  contains the value of the (j-1)-th Legendre polynomial evaluated at t[i].\n\nThrows\n\nArgumentError: If r is negative.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legneval","page":"Home","title":"TensorRefinement.Legendre.legneval","text":"legneval(t::Vector{T}, r::Int) where {T<:AbstractFloat}\n\nEvaluate the first r normalized Legendre polynomials at the points specified in the vector t.\n\nArguments\n\nt::Vector{T}: Vector of points at which to evaluate the normalized Legendre polynomials.\nr::Int: Number of normalized Legendre polynomials to evaluate.\n\nReturns\n\nMatrix{T}: An n x r matrix V, where n is the length of t. The entry V[i,j]  contains the value of the (j-1)-th normalized Legendre polynomial evaluated at t[i].\n\nThrows\n\nArgumentError: If the number of degrees of freedom r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legtolegn","page":"Home","title":"TensorRefinement.Legendre.legtolegn","text":"legtolegn(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nConstruct a diagonal matrix that transforms coefficients in the Legendre polynomial basis  to coefficients in the normalized Legendre polynomial basis.\n\nArguments\n\n::Type{T}: Numeric type (subtype of AbstractFloat) for the matrix elements.\nr::Int: Size of the matrix.\n\nReturns\n\nDiagonal{T}: Diagonal matrix of size r x r containing the scaling factors  to convert from Legendre polynomials to normalized Legendre polynomials.\n\nThrows\n\nArgumentError: If r is negative.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legntoleg","page":"Home","title":"TensorRefinement.Legendre.legntoleg","text":"legntoleg(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nConstruct a diagonal matrix that transforms coefficients in the normalized Legendre polynomial basis  to coefficients in the standard Legendre polynomial basis.\n\nArguments\n\n::Type{T}: Numeric type (subtype of AbstractFloat) for the matrix elements.\nr::Int: Size of the matrix.\n\nReturns\n\nDiagonal{T}: Diagonal matrix of size r x r containing the scaling factors  to convert from normalized Legendre polynomials to Legendre polynomials.\n\nThrows\n\nArgumentError: If r is negative.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legdiff","page":"Home","title":"TensorRefinement.Legendre.legdiff","text":"legdiff(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nConstruct a differentiation matrix for Legendre polynomials of degree up to r-1.\n\nArguments\n\n::Type{T}: Numeric type (subtype of AbstractFloat) for the matrix elements.\nr::Int: Number of degrees of freedom (DOFs), i.e., the size of the matrix.\n\nReturns\n\nMatrix{T}: Matrix of size r x r representing the differentiation operator for Legendre polynomials of degree up to r-1.\n\nThrows\n\nArgumentError: If r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legndiff","page":"Home","title":"TensorRefinement.Legendre.legndiff","text":"legndiff(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nConstruct a differentiation matrix for normalized Legendre polynomials of degree up to r-1.\n\nArguments\n\n::Type{T}: Numeric type (subtype of AbstractFloat) for matrix elements.\nr::Int: Number of degrees of freedom (DOFs), i.e., the size of the matrix.\n\nReturns\n\nMatrix{T}: Matrix of size r x r representing the differentiation operator for normalized Legendre polynomials of degree up to r-1.\n\nThrows\n\nArgumentError: If r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legref","page":"Home","title":"TensorRefinement.Legendre.legref","text":"legref(ξ::T, η::T, r::Int) where {T<:AbstractFloat}\n\nCompute a matrix related to the Legendre polynomials over a reference interval, parameterized by ξ and η.\n\nArguments\n\nξ::T: Float representing one of the parameters for the transformation.\nη::T: Float representing the other parameter for the transformation.\nr::Int: Number of degrees of freedom (DOFs), i.e., the size of the matrix.\n\nReturns\n\nMatrix{T}: An r x r matrix W that encodes the transformation in the Legendre polynomial basis for given parameters ξ and η.\n\nThrows\n\nArgumentError: If r is less than 1.\n\n\n\n\n\nlegref(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute a matrix based on the Legendre polynomials that encodes specific transformations or relations.\n\nArguments\n\n::Type{T}: Numeric type (subtype of AbstractFloat) for matrix elements.\nr::Int: Number of degrees of freedom (DOFs), i.e., the size of the matrix.\n\nReturns\n\nArray{T,3}: An r x r x 2 array W where the first slice (W[:,:,1]) represents the transformation matrix in a standard basis   and the second slice (W[:,:,2]) ...\n\nThrows\n\nArgumentError: If r is less than 1.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legnref","page":"Home","title":"TensorRefinement.Legendre.legnref","text":"lengref(::Type{T}, r::Int) where {T<:AbstractFloat}\n\nCompute a matrix based on the normalized Legendre polynomials that encodes specific transformations or relations.\n\nArguments\n\n::Type{T}: Numeric type (subtype of AbstractFloat) for matrix elements.\nr::Int: Number of degrees of freedom (DOFs), i.e., the size of the matrix.\n\nReturns\n\nArray{T,3}: An r x r x 2 array W where the first slice (W[:,:,1]) represents the transformation matrix in a standard basis   and the second slice (W[:,:,2]) ...\n\nThrows\n\nArgumentError: If r is less than 1.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legdec","page":"Home","title":"TensorRefinement.Legendre.legdec","text":"legdec(c::Vector{T}, L::Int; major::String=\"last\") where {T<:AbstractFloat}\n\nConstruct a decomposition based on the Legendre polynomials for a given vector of coefficients c and a specified number of factors L.\n\nArguments\n\nc::Vector{T}: Vector of coefficients for the Legendre polynomials. Length of this vector (r) determines the degree of the polynomial (maximal r-1).\nL::Int: Number of factors in the decomposition.\nmajor::String: Specifies the ordering of the decomposition, either \"last\" (default) or \"first\".\n\nReturns\n\nDec{T,N}: Decomposition object based on the Legendre polynomials and the given vector of coefficients c.\n\nThrows\n\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.Legendre.legdeceval!","page":"Home","title":"TensorRefinement.Legendre.legdeceval!","text":"legdeceval!(U::Dec{T,N}, t::Vector{T}; major::String=\"last\") where {T<:AbstractFloat,N}\n\nEvaluate a Legendre polynomial decomposition U at a set of points t, adding the reshaped evaluation matrix as a factor to U in place.\n\nArguments\n\nU::Dec{T,N}: Decomposition representing a Legendre polynomial; will be evaluated and modified in place.\nt::Vector{T}: Vector of points at which to evaluate the polynomial.\nmajor::String: Specifies the ordering of the decomposition, either \"last\" (default) or \"first\". \n\nReturns\n\nDec{T,N}: Modified decomposition object U, now including a factor based on the reshaped evaluation matrix at points t.\n\nThrows\n\nArgumentError: If major is neither \"first\" nor \"last\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorTrainFactor","page":"Home","title":"TensorTrainFactor","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the TensorTrainFactor module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FactorSize\nFactor\nVectorFactor \nMatrixFactor\nfactorsize \nfactorranks\nfactorndims\nfactornumentries\nfactorstorage\nfactor\nfactormatrix\nfactorrankselect\nblock\nfactorvcat\nfactorhcat \nfactordcat\nfactorltcat \nfactorutcat\nfactorranktranspose \nfactormodetranspose\nfactormodereshape\nfactordiagm\nfactorcontract \nfactormp\nfactorkp\nfactorhp\nfactorqr!\nfactorqradd\nfactorsvd!","category":"page"},{"location":"index.html#TensorRefinement.TensorTrain.FactorSize","page":"Home","title":"TensorRefinement.TensorTrain.FactorSize","text":"Factorsize is an alias for a Vector{Int}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.Factor","page":"Home","title":"TensorRefinement.TensorTrain.Factor","text":"Factor{T,N} is an alias for Array{T,N}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.VectorFactor","page":"Home","title":"TensorRefinement.TensorTrain.VectorFactor","text":"VectorFactor{T} is a 3D tensor with entries of type T.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.MatrixFactor","page":"Home","title":"TensorRefinement.TensorTrain.MatrixFactor","text":"MatrixFactor{T} is a 4D tensor with entries of type T.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.factorsize","page":"Home","title":"TensorRefinement.TensorTrain.factorsize","text":"factorsize(U::Factor{T,N}) where {T<:Number,N}\n\nDetermine the sizes of the mode dimensions of the given factor U in a vector, excluding the first and last dimensions.\n\nArguments\n\nU::Factor{T, N}: Factor of type Factor with elements of type T and with N as the number dimensions.\n\nReturns\n\nFactorsize(n): Custom type Factorsize that holds the mode dimensions of U excluding the first and last dimension as a vector.\n\nThrows\n\nArgumentError: If factor exhibits only one or no rank dimension.\nArgumentError: If factor exhibits negative mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorranks","page":"Home","title":"TensorRefinement.TensorTrain.factorranks","text":"factorranks(U::Factor{T,N}) where {T<:Number,N}\n\nDetermine the first and last rank dimension of a given factor U.\n\nArguments\n\nU::Factor{T, N}: Factor of type Factor with elements of type T and with N as the number dimensions.\n\nReturns\n\nTuple (sz[1], sz[end]) where sz[1] is the first and sz[end] is the last dimension of the input tensor.\n\nThrows\n\nArgumentError: If factor exhibits only one or no rank dimension.\nArgumentError: If factor exhibits negative mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorndims","page":"Home","title":"TensorRefinement.TensorTrain.factorndims","text":"factorndims(::Factor{T,N}) where {T<:Number,N}\n\nReturn the number of mode dimensions excluding the first and last dimension.\n\nArguments\n\n::Factor{T, N}: Factor of type Factor with elements of type T and with N as the number dimensions.\n\nReturns\n\nAn integer representing the number of mode dimensions, which is N - 2 (number of entries in factorsize).\n\nThrows\n\nArgumentError: If factor exhibits only one or no rank dimension.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factornumentries","page":"Home","title":"TensorRefinement.TensorTrain.factornumentries","text":"factornumentries(U::Factor{T,N}) where {T<:Number,N}\n\nDetermine the number of entries in the given factor.\n\nArguments\n\nU::Factor{T, N}: Factor of type Factor with elements of type T and with N as the number dimensions.\n\nReturns\n\nAn integer specifiying the number of entries in the given Factor.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorstorage","page":"Home","title":"TensorRefinement.TensorTrain.factorstorage","text":"An alias for the function factornumentries.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factor","page":"Home","title":"TensorRefinement.TensorTrain.factor","text":"factor(U::Array{T,N}) where {T<:Number,N}\n\nReshape a given tensor U into a factor that can be used in further TT-operations.\n\nArguments\n\nU::Array{T, N}: Multi-dimensional array with elements of type T and with N as the number dimensions.\n\nReturns\n\nA reshaped version of the tensor U with a single first and last dimension to facilitate TT-operations.\n\n\n\n\n\nfactor(U::Matrix{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, \n       n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}, \n       π::Union{NTuple{K,Int}, Vector{Int}}) where {T<:Number, K, M, N}\n\nReshape a matrix U into a multi-dimensional array with specified mode sizes m and n,  and permute the mode dimensions according to the permutation π.\n\nArguments\n\nU::Matrix{T}: Input matrix with elements of type T.\nm::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the first dimension of U.\nn::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the second dimension of U.\nπ::Union{NTuple{K,Int}, Vector{Int}}: Permutation of the mode dimensions.\n\nReturns\n\nA reshaped and permuted tensor based on the provided mode sizes m, n, and permutation π.\n\nThrows\n\nArgumentError: If π is empty or not a valid permutation of 1:length(m) + length(n).\nArgumentError: If m or n is none of the following: integer, vector or tuple of integers, empty vector or tuple. \nDimensionMismatch: If the dimensions of U are not divisible by the products of m or n, respectively.\n\n\n\n\n\nfactor(U::Matrix{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, \n       n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}) where {T<:Number, M, N}\n\nReshape a matrix U into a multi-dimensional array with mode sizes m and n and use 1:length(m)+length(n) as permutation of dimensions.\n\nFunction is a variant of the more general factor function with an automatic permutation sequence 1:length(m)+length(n) applied to the reshaped matrix.\n\nArguments\n\nU::Matrix{T}: Input matrix with elements of type T.\nm::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the first dimension of U.\nn::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the second dimension of U.\n\nReturns\n\nA reshaped and permuted factor based on the mode sizes m and n with a permutation 1:length(m)+length(n).\n\nThrows\n\nArgumentError: If m or n is not an integer, a vector or tuple of integers, or an empty vector or tuple.\nDimensionMismatch: If the dimensions of U are not divisible by the products of m or n.\n\n\n\n\n\nfactor(U::Vector{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, \n       π::Union{NTuple{M,Int}, Vector{Int}}) where {T<:Number, M}\n\nReshape a vector U into a two-dimensional array, then reshape it further into a multi-dimensional array based on the mode sizes m and apply the permutation π.\n\nFunction is a variant of the more general factor function, which allows reshaping a vector U into a matrix and then applying mode sizes and a custom permutation.\n\nArguments\n\nU::Vector{T}: Input vector with elements of type T.\nm::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the reshaped array.\nπ::Union{NTuple{M,Int}, Vector{Int}}: Permutation of the mode dimensions.\n\nReturns\n\nA reshaped and permuted factor based on the mode sizes m and permutation π.\n\nThrows\n\nArgumentError: If m is none of the following: integer, vector or tuple of integers, an empty vector or tuple.\n\n\n\n\n\nfactor(U::Vector{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}) where {T<:Number, M}\n\nReshape a vector U into a two-dimensional array, then reshape it into a multi-dimensional array based on the mode sizes m with a natural permutation.\n\nFunction is a variant of the more general factor function, which reshapes a vector U into a matrix and then into an array with mode sizes m. It also applies a natural permutation 1:length(m).\n\nArguments\n\nU::Vector{T}: Input vector with elements of type T.\nm::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}: Mode sizes for the reshaped array.\n\nReturns\n\nA reshaped and permuted factor based on the mode sizes m with a natural permutation.\n\nThrows\n\nArgumentError: If m is none of the following: integer, vector or tuple of integers, empty vector or tuple.\n\n\n\n\n\nfactor(U::Dec{T,N}; major::String=\"last\") where {T<:Number,N}\n\nCreate a new decomposition by factorizing the decomposition U to a single factor (contraction along all mode dimmensions).\n\nArguments\n\nU::Dec{T,N}: Decomposition, whose entries are in T and with N dimensions, to factorize.\nmajor::String=\"last\": Reference numbers for selecting slices along the first rank dimension of the first factor of U.\n\nReturns\n\nV: New factor object type Factor obtained by contracting the entire decomposition. \n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormatrix","page":"Home","title":"TensorRefinement.TensorTrain.factormatrix","text":"factormatrix(U::Factor{T,K}, π::Indices, σ::Indices) where {T<:Number, K}\n\nConvert a factor U into a matrix by permuting and reshaping the mode dimensions according to the specified indices π and σ.\n\nArguments\n\nU::Factor{T,K}: Input factor of type Factor with elements of type T and K dimensions.\nπ::Indices: Reference numbers specifying the permutation of mode dimensions for the first dimension of the resulting matrix.\nσ::Indices: Reference numbers specifying the permutation of mode dimensions for the second dimension of the resulting matrix.\n\nReturns\n\nA matrix obtained by permuting and reshaping U according to the specified indices π and σ.\n\nThrows\n\nArgumentError: If U does not have at least one mode dimension.\nArgumentError: If π or σ are not valid indices or do not constitute a valid permutation of mode dimensions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorrankselect","page":"Home","title":"TensorRefinement.TensorTrain.factorrankselect","text":"factorrankselect(U::Factor{T,N}, α::Indices, β::Indices) where {T<:Number, N}\n\nSelect specific slices from a factor U based on the provided rank indices α and β.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nα::Indices: Reference numbers for selecting slices along the first rank dimension.\nβ::Indices: Reference numbers for selecting slices along the second rank dimension.\n\nReturns\n\nA sub-array of U corresponding to the specified slices.\n\nThrows\n\nArgumentError: If the indices α or β are incorrect or out of range for the respective rank dimensions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.block","page":"Home","title":"TensorRefinement.TensorTrain.block","text":"block(U::Factor{T,N}, α::Int, β::Int) where {T<:Number, N}\n\nExtracts a specific block from the factor U based on the provided rank indices α and β.\n\nDetailed description: Function reshapes given factor into 3D array, selects all entries along second dimension, where α and β specify the first and third dimension, and reshapes selected entries into a block with sizes equivalent to the mode dimensions of the initial array.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nα::Int: Reference numbers for selecting the slice along the first rank dimension.\nβ::Int: Reference numbers for selecting the slice along the second rank dimension.\n\nReturns\n\nA sub-array representing the block corresponding to the specified rank indices.\n\nThrows\n\nArgumentError: If the indices α or β are out of range for the respective rank dimensions.\n\n\n\n\n\nblock(U::Dec{T,N}, α::Int, β::Int; major::String=\"last\") where {T<:Number,N}\n\nCreate a new block by selecting the first ranks of the first and last ranks of the last factor of the decomposition U specified by the indices α and β, contract all factors together and yield the resulting block.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, to copy and modify.\nα::Int: The index to select from the first rank.\nβ::Int: The index to select from the last rank.\nmajor::String=\"last\": Specifies the major order for the operation; default is \"last\".\n\nReturns\n\nV: New factor type obtained by rank selection and contraction to a block.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorvcat","page":"Home","title":"TensorRefinement.TensorTrain.factorvcat","text":"factorvcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T<:Number, N, M}\n\nVertically concatenate the factors U, V, and additional factors in W along the first rank dimension.\n\nArguments\n\nU::Factor{T,N}: First factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nW::Vararg{Factor{T,N},M}: Additional factors to be concatenated, each of Of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the vertical concatenation of U, V, and the additional factors in W.\n\nThrows\n\nArgumentError: If any of the factors have incompatible mode sizes or second ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorhcat","page":"Home","title":"TensorRefinement.TensorTrain.factorhcat","text":"factorhcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T<:Number, N, M}\n\nHorizontally concatenate the factors U, V, and additional factors in W along the second rank dimension.\n\nArguments\n\nU::Factor{T,N}: First factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nW::Vararg{Factor{T,N},M}: Additional factors to be concatenated, each of Of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the horizontal concatenation of U, V, and the additional factors in W.\n\nThrows\n\nArgumentError: If any of the factors have incompatible mode sizes or first ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factordcat","page":"Home","title":"TensorRefinement.TensorTrain.factordcat","text":"factordcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T<:Number, N, M}\n\nConcatenate the factors U, V, and additional factors in W along the mode dimensions and the second rank dimension.\n\nArguments\n\nU::Factor{T,N}: First factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second factor to be concatenated. Of type Factor with elements of type T and N dimensions.\nW::Vararg{Factor{T,N},M}: Additional factors to be concatenated, each of Of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the concatenation of U, V, and the additional factors in W along the mode dimensions and the second rank dimension.\n\nThrows\n\nArgumentError: If any of the factors have incompatible mode sizes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorltcat","page":"Home","title":"TensorRefinement.TensorTrain.factorltcat","text":"factorltcat(U₁₁::Factor{T,N}, U₂₁::Factor{T,N}, U₂₂::Factor{T,N}) where {T<:Number, N}\n\nConcatenate three factors U₁₁, U₂₁, and U₂₂ in a lower triangular block matrix form.\n\nArguments\n\nU₁₁::Factor{T,N}: First factor for the upper left block, with elements of type T and N dimensions.\nU₂₁::Factor{T,N}: Second factor for the lower left block, with elements of type T and N dimensions.\nU₂₂::Factor{T,N}: Third factor for the lower right block, with elements of type T and N dimensions.\n\nReturns\n\nA new factor representing the lower triangular concatenation of U₁₁, U₂₁, and U₂₂.\n\nThrows\n\nArgumentError: If the factors are incompatible in mode size or rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorutcat","page":"Home","title":"TensorRefinement.TensorTrain.factorutcat","text":"factorutcat(U₁₁::Factor{T,N}, U₁₂::Factor{T,N}, U₂₂::Factor{T,N}) where {T<:Number, N}\n\nConcatenate three factors U₁₁, U₁₂, and U₂₂ in an upper triangular block matrix form.\n\nArguments\n\nU₁₁::Factor{T,N}: First factor for the upper left block, with elements of type T and N dimensions.\nU₁₂::Factor{T,N}: Second factor for the upper right block, with elements of type T and N dimensions.\nU₂₂::Factor{T,N}: Third factor for the lower right block, with elements of type T and N dimensions.\n\nReturns\n\nA new factor representing the upper triangular concatenation of U₁₁, U₁₂, and U₂₂.\n\nThrows\n\nArgumentError: If the factors are incompatible in mode size or rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorranktranspose","page":"Home","title":"TensorRefinement.TensorTrain.factorranktranspose","text":"factorranktranspose(U::Factor{T,N}) where {T<:Number, N}\n\nTranspose the rank dimensions of the factor U.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor with the rank dimensions of U transposed.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormodetranspose","page":"Home","title":"TensorRefinement.TensorTrain.factormodetranspose","text":"factormodetranspose(U::Factor{T,N}, π::NTuple{K,Int}) where {T<:Number, N, K}\n\nPermute the mode dimensions of the factor U according to the permutation π.\n\nArguments\n\nU::Factor{T,N}: Input factor with elements of type T and N dimensions.\nπ::NTuple{K,Int}: Permutation of the mode dimensions of U. Should contain exactly K = N - 2 elements, which are a valid permutation of 1:d where d is the number of mode dimensions.\n\nReturns\n\nA new factor resulting from permuting the mode dimensions of U according to π.\n\nThrows\n\nArgumentError: If U has fewer than one mode dimension.\nArgumentError: If π is not a valid permutation of the mode dimensions of U.\n\n\n\n\n\nfactormodetranspose(U::Factor{T,N}, π::Vector{Int}) where {T<:Number,N}\n\nPermute the mode dimensions of the factor U according to the permutation π, where π is passed as a vector instead of a tuple.\n\nFunction acts as a wrapper around factormodetranspose to convert the vector π to a tuple and then call the main method.\n\nArguments\n\nU::Factor{T,N}: Input factor with elements of type T and N dimensions.\nπ::Vector{Int}: Permutation of the mode dimensions of U. Should contain exactly N - 2 elements to allow for permutation of the mode dimensions.\n\nReturns\n\nA new factor resulting from permuting the mode dimensions of U according to π.\n\nThrows\n\nArgumentError: If U has fewer than one mode dimension.\nArgumentError: If π is not a valid permutation of the mode dimensions of U.\n\n\n\n\n\nfactormodetranspose(U::Factor{T,2}) where {T<:Number}\n\nTranspose the two dimensions of the factor U, assuming U has exactly two dimensions.\n\nFunction is a specialized version of factormodetranspose for the case when U has two dimensions. It transposes U by swapping the two dimensions, equivalent to the permutation (2, 1).\n\nArguments\n\nU::Factor{T,2}: Two-dimensional factor with elements of type T.\n\nReturns\n\nA new factor obtained by transposing the two dimensions of U.\n\nThrows\n\nArgumentError: If U is not two-dimensional.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormodereshape","page":"Home","title":"TensorRefinement.TensorTrain.factormodereshape","text":"factormodereshape(U::Factor{T,N}, n::FactorSize) where {T<:Number, N}\n\nReshape the mode dimensions of the factor U to the specified sizes in n.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nn::FactorSize: Vector specifying the new sizes for the mode dimensions. Product of n must equal the product of current mode sizes of U.\n\nReturns\n\nA new factor resulting from reshaping the mode dimensions of U to n.\n\nThrows\n\nDimensionMismatch: If the product of n does not equal the product of the current mode sizes of U.\n\n\n\n\n\nfactormodereshape(U::Factor{T,N}, n::Vector{Any}) where {T<:Number,N}\n\nReshape the mode dimensions of the factor U to the specified sizes in n, which defaults to an empty vector if n is of type Vector{Any}.\n\nFunction acts as a specialized version of factormodereshape where the input vector n is replaced with an empty Vector{Int}(). \n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nn::Vector{Any}: Vector specifying the new sizes for the mode dimensions.\n\nReturns\n\nA reshaped factor where the mode dimensions are modified, which defaults to use an empty vector of integers for mode reshaping.\n\nThrows\n\nDimensionMismatch: If the product of n does not equal the product of the current mode sizes of U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factordiagm","page":"Home","title":"TensorRefinement.TensorTrain.factordiagm","text":"factordiagm(U::Factor{T,N}) where {T<:Number, N}\n\nCreate a tensor with diagonal properties from the factor U by placing the elements of U along the diagonal of a larger-dimensional tensor.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor that represents a tensor with diagonal properties constructed from U, dimensions expanded.\n\nThrows\n\nArgumentError: If U has fewer than one mode dimension.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorcontract","page":"Home","title":"TensorRefinement.TensorTrain.factorcontract","text":"factorcontract(U::Factor{T,N}, V::Factor{T,N}; rev::Bool=false, major::String=\"last\") where {T<:Number, N}\n\nContract two factors U and V along their shared rank dimensions. Function supports contracting in different orientations and orders based on parameters rev and major.\n\nArguments\n\nU::Factor{T,N}: First input factor of type Factor with elements of type T and N dimensions.\nV::Factor{T,N}: Second input factor of type Factor with elements of type T and N dimensions.\nrev::Bool=false: If true, reverse the roles of U and V in the contraction.\nmajor::String=\"last\": Specifies major contraction order. Must be either \"last\" (default) or \"first\".\n\nReturns\n\nA new factor resulting from contracting U and V along their shared rank dimensions.\n\nThrows\n\nArgumentError: If U and V have inconsistent ranks\nArgumentError: If major is neither \"last\" nor \"first\".\n\n\n\n\n\nfactorcontract(U::Factor{T,N}, V::S) where {T<:Number, N, S<:AbstractMatrix{T}}\n\nContract a factor U with a matrix V, aligning the rank dimensions and performing matrix multiplication.\n\nArguments\n\nU::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\nV::S: Matrix of type S and elements of type T to contract with U.\n\nReturns\n\nA new factor resulting from the contraction of U with V.\n\nThrows\n\nArgumentError: If U and V have inconsistent ranks.\n\n\n\n\n\nfactorcontract(U::S, V::Factor{T,N}) where {T<:Number, N, S<:AbstractMatrix{T}}\n\nContracts a matrix U with a factor V, aligning the rank dimensions and performing matrix multiplication.\n\nArguments\n\nU::S: Matrix of type S and elements of type T to contract with V.\nV::Factor{T,N}: Input factor of type Factor with elements of type T and N dimensions.\n\nReturns\n\nA new factor resulting from the contraction of U with V.\n\nThrows\n\nArgumentError: If U and V have inconsistent ranks.\n\n\n\n\n\nfactorcontract(U::S, V::R) where {T<:Number, S<:AbstractMatrix{T}, R<:AbstractMatrix{T}}\n\nPerform a matrix multiplication (contraction) of two factors U and V, which are matrices.\n\nArguments\n\nU::S: First input matrix of type AbstractMatrix{T} with elements of type T.\nV::R: Second input matrix of type AbstractMatrix{T} with elements of type T.\n\nReturns\n\nThe result of matrix multiplication U * V, which contracts the two input matrices.\n\nThrows\n\nDimensionMismatch: If the number of columns in U does not match the number of rows in V.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factormp","page":"Home","title":"TensorRefinement.TensorTrain.factormp","text":"factormp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T<:Number, N₁, N₂}\n\nPerform a mode-wise multiplication (contraction) of two factors U₁ and U₂ along specified modes σ₁ and σ₂. Operation contracts the specified modes, while the remaining dimensions of the factors are combined.\n\nArguments\n\nU₁::Factor{T,N₁}: First factor of type Factor with elements of type T and N₁ dimensions.\nσ₁::Indices: Reference numbers specifying which modes of U₁ to use in the contraction. Can be a vector of integers or an empty vector.\nU₂::Factor{T,N₂}: Second factor of type Factor with elements of type T and N₂ dimensions.\nσ₂::Indices: Reference numbers specifying which modes of U₂ to use in the contraction. Can be a vector of integers or an empty vector.\n\nReturns\n\nA new factor resulting from the mode-wise multiplication of U₁ and U₂, with contracted modes combined and the remaining dimensions preserved.\n\nThrows\n\nArgumentError: If σ₁ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If σ₂ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If the specified sets of modes of σ₁ and σ₂ are inconsistent.\nArgumentError: If the set of modes of U₁ is specified incorrectly.\nArgumentError: If the set of modes of U₂ is specified incorrectly.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorkp","page":"Home","title":"TensorRefinement.TensorTrain.factorkp","text":"factorkp(U::Union{Factor{T,N}, Pair{Factor{T,N},Int}}, V::Vararg{Union{Factor{T,N}, Pair{Factor{T,N},Int}},M}) where {T<:Number,N,M}\n\nPerform a Kronecker product of multiple factors (optionally raised to specified nonnegative integer exponents).\n\nArguments\n\nU::Union{Factor{T, N}, Pair{Factor{T, N}, Int}}: First factor can either be a Factor type or a pair (Factor, Int). If given as a pair, the integer is the exponent for the respective factor in the Kronecker product.\nV::Vararg{Union{Factor{T, N}, Pair{Factor{T, N}, Int}}, M}: Variable number (denoted by M) of additional factors, each of which can also be either a Factor type or a pair (Factor, Int). The same usage for the integer applies as in the above line.\n\nReturns\n\nW: Resulting tensor (or matrix if d = 0) after the Kronecker products of all provided factors (with optionally some factors exponentiated). Final tensor is a result of a series of multiplications and reshaping operations.\n\nThrows\n\nArgumentError: If a negative exponent is provided in a pair (Factor, Int).\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorhp","page":"Home","title":"TensorRefinement.TensorTrain.factorhp","text":"factorhp(U::Factor{T,N}, V::Factor{T,N}) where {T<:Number, N}\n\nCompute the higher-order tensor product of two factors U and V. Resulting factor has dimensions formed by multiplying the ranks and mode sizes of U and V.\n\nArguments\n\nU::Factor{T,N}: First factor of type Factor with elements of type T and with N dimensions.\nV::Factor{T,N}: Second factor of type Factor with elements of type T and with N dimensions.\n\nReturns\n\nA reshaped tensor representing the higher-order product of U and V, with dimensions (p * r, n..., q * s) where:\n(p, q) are the ranks of U.\n(r, s) are the ranks of V.\nn represents the mode sizes of U and V.\n\nThrows\n\nArgumentError: If U and V do not have the same mode size.\n\n\n\n\n\nfactorhp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T<:Number, N₁, N₂}\n\nCompute the higher-order tensor product of two factors U₁ and U₂ along specified modes σ₁ and σ₂. Function allows for a flexible contraction over selected modes.\n\nArguments\n\nU₁::Factor{T,N₁}: First factor of type Factor with elements of type T and N₁ dimensions.\nσ₁::Indices: Reference numbers specifying which modes of U₁ to use in the contraction. Can be a vector of integers or an empty vector.\nU₂::Factor{T,N₂}: Second factor of type Factor with elements of type T and N₂ dimensions.\nσ₂::Indices: Reference numbers specifying which modes of U₂ to use in the contraction. Can be a vector of integers or an empty vector.\n\nReturns\n\nA reshaped tensor representing the higher-order product of U₁ and U₂, contracted over the specified modes.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If σ₁ or σ₂ are incorrectly specified or inconsistent with the dimensions of U₁ or U₂.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\nExtended Error list:\n\nArgumentError: If σ₁ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If σ₂ is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.\nArgumentError: If the specified sets of modes of σ₁ and σ₂ are inconsistent.\nArgumentError: If the set of modes of U₁ is specified incorrectly.\nArgumentError: If the set of modes of U₂ is specified incorrectly.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorqr!","page":"Home","title":"TensorRefinement.TensorTrain.factorqr!","text":"factorqr!(U::Factor{T,N}; rev::Bool=false, factf=(rev ? A -> LinearAlgebra.lq!(A) : A -> LinearAlgebra.qr!(A))) where {T<:FloatRC, N}\n\nPerform a QR or LQ factorization of the tensor U, depending on the value of the keyword argument rev (reverse). \n\nArguments\n\nU::Factor{T, N}: Mutable factor of type Factor with elements of type T and with N as the number dimensions.\nrev::Bool=false: Keyword argument that determines the type of factorization. If false, performs a QR factorization; if true, performs an LQ factorization.\nfactf: Keyword argument that specifies the chosen factorization function. By default, LinearAlgebra.qr! and LinearAlgebra.lq! are used respectively (depending on rev).\n\nReturns\n\ntuple (U, R), where:\nU: Transformed tensor after applying the QR or LQ factorization. (N-dimensional)\nR: Factor tensor obtained by reshaping the factor matrix of the QR or LQ factorization (N-dimensional)\n\n\n\n\n\nfactorqr!(U::Factor{T,N}, ::Val{false}; rev::Bool=false) where {T<:FloatRC{<:AbstractFloat},N}\n\nPerform an in-place QR or LQ factorization of the factor U, depending on the value of the keyword argument rev (reverse). This variant uses the Val{false} signature for the default QR factorization.\n\nArguments\n\nU::Factor{T,N}: Mutable factor of type Factor with elements of type T (a subtype of FloatRC) and N dimensions.\nrev::Bool=false: Keyword argument that specifies whether to perform an LQ factorization (true) or a QR factorization (false, default).\n\nReturns\n\nA tuple (U, R) where:\nU: Transformed tensor after applying the QR or LQ factorization.\nR: Factor tensor obtained by reshaping the factor matrix of the factorization.\n\n\n\n\n\nfactorqr!(U::Factor{T,N}, ::Val{true}; rev::Bool=false, returnS::Bool=false,\n          factf=(A -> LinearAlgebra.qr!(A, LinearAlgebra.ColumnNorm()))) where {T<:FloatRC, N}\n\nPerform a QR factorization of the factor U with optional pivoting and the ability to return an additional factor S. The function can cope with different orientations (via rev) and supports custom factorization functions.\n\nArguments\n\nU::Factor{T,N}: Factor to be decomposed, of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and with N dimensions.\n::Val{true}: Value type that indicates that this version of factorqr! should be used when returnS is needed.\nrev::Bool=false: Keyword argument that determines the orientation of the QR factorization.\nfalse (default): Standard QR factorization is performed.\ntrue: Roles of rows and columns are reversed, affecting the orientation of the factorization.\nreturnS::Bool=false: Keyword argument that specifies whether to return an additional factor S such that A ⨝ S = Q if rev == false and S ⨝ A = Q if rev == true.\nfactf: Function used to perform the QR factorization, default is set to LinearAlgebra.qr! with column pivoting.\n\nReturns\n\nQ, R: Factors Q (orthogonal) and R (upper triangular) from the QR decomposition.\nQ, R, S: If returnS == true, returns an additional factor S along with Q and R.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorqradd","page":"Home","title":"TensorRefinement.TensorTrain.factorqradd","text":"factorqradd(Q::Factor{T,N}, R::Union{Factor{T,N},Nothing}, U::Factor{T,N}; rev::Bool=false) where {T<:FloatRC, N}\n\nAdd rows or columns to an orthogonal factor Q and its corresponding upper triangular factor R, depending on the value of rev. This function is an extension to the QR factorization by updating the factors to incorporate a new matrix U.\n\nArguments\n\nQ::Factor{T,N}: Orthogonal factor of type Factor with elements of type T (subtype of FloatRC: any real or complex floating point) and N dimensions.\nIf rev == true, Q is assumed to be orthogonal with respect to the first rank.\nIf rev == false, Q is assumed to be orthogonal with respect to the second rank.\nR::Union{Factor{T,N},Nothing}: Upper triangular factor of the QR factorization. Can be of type Factor or Nothing.\nIf R is Nothing, an identity matrix of appropriate dimensions will be used.\nU::Factor{T,N}: New matrix to be added to the existing factors (same mode dimensions as Q).\nrev::Bool=false: Keyword argument indicating the direction of orthogonality for the operation. \nfalse (default): Assumes Q to be orthogonal with respect to the second rank, and columns will be added.\ntrue: Assumes Q to be orthogonal with respect to the first rank, and rows will be added.\n\nReturns\n\nQ: Updated orthogonal factor after incorporating U.\nR: Updated upper triangular factor after incorporating U.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the mode sizes of Q and U are incompatible.\nArgumentError: If R has incompatible rank or mode dimensions with Q.\nArgumentError: If Q and U are incompatible in their respective ranks.\nArgumentError: If R is specified and has an incompatible number of mode dimensions or rank.\n\nExtended Error List:\n\nArgumentError: If the mode sizes of Q and U are incompatible.\nArgumentError: If R and Q have incompatible number of mode dimensions or incompatible number of unitary mode sizes.\nArgumentError: If R and Q have incompatible rank.\nArgumentError: If Q and U have incompatible second rank.\nArgumentError: If R  has a different number of mode dimensions as Q or different unitary mode sizes.\nArgumentError: If Q and R have incompatible rank.\nArgumentError: If Q and U have incompatible first rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factorsvd!","page":"Home","title":"TensorRefinement.TensorTrain.factorsvd!","text":"factorsvd!(W::Factor{T,N},\n           m::Union{FactorSize,Colon},\n           n::Union{FactorSize,Colon};\n           soft::S=zero(S),\n           hard::S=zero(S),\n           atol::S=zero(S),\n           rtol::S=zero(S),\n           rank::Int=0,\n           major::String=\"last\",\n           rev::Bool=false,\n           factf=(A -> LinearAlgebra.svd!(A; full=false, alg=LinearAlgebra.QRIteration())) )\n where {S<:AbstractFloat,T<:FloatRC{S},N}\n\nPerform a singular value decomposition (SVD) of the factor W where the factor dimensions are adjusted accordingly and optional thresholding is carried out based on specified parameters. \n\nArguments\n\nW::Factor{T, N}: Input factor of type Factor with elements of type T and N dimensions.\nm::Union{FactorSize, Colon}: Mode-size parameter for first dimension. Can be a FactorSize vector specifying the sizes of the mode dimensions or Colon to represent all indices.\nn::Union{FactorSize, Colon}: Mode-size parameter for second dimension. Can also be a FactorSize vector or Colon.\nsoft::S=zero(S): Keyword argument specifying the soft threshold for singular value truncation. Must be nonnegative and finite.\nhard::S=zero(S): Keyword argument specifying the hard threshold for singular value truncation. Must be nonnegative and finite.\natol::S=zero(S): Absolute tolerance for singular values. Must be nonnegative and finite.\nrtol::S=zero(S): Relative tolerance for singular values. Must be nonnegative and finite.\nrank::Int=0: Maximum allowable rank for the truncated SVD. Must be nonnegative.\nmajor::String=\"last\": Specifies the major contraction order. Must be either \"last\" (default) or \"first\".\nrev::Bool=false: Boolean indicating whether to reverse the dimensions in the output.\nfactf: Function used to perform the SVD. Default sets it to a function using LinearAlgebra.svd! with QRIteration.\n\nReturns\n\nU: The left singular vectors after applying SVD, reshaped based on the specified parameters (and potentially truncated).\nV: The right singular vectors after applying SVD, reshaped similarly (and also potentially truncated).\nε: The effective noise level that stems from thresholding.\nδ: The relative noise level, calculated as ε / μ.\nμ: The norm of the input factor W.\nρ: The rank of the truncated SVD.\nσ: A vector of the singular values (after thresholding).\n\nThrows\n\nSummarized Error List:\n\nArgumentError: If both m and n are specified as Colon, this causes ambiguity.\nArgumentError: If either m or n is specified with non-positive or inconsistent dimensions.\nArgumentError: If major is neither \"first\" nor \"last\".\nArgumentError: If soft, hard, atol, or rtol are negative or not finite.\nArgumentError: If rank is negative.\nDimensionMismatch: If mode-size vectors m and n are inconsistent with dimensions of W.\nErrorException: If numerical issues such as overflow or underflow occur during computations.\n\nFull Error List:\n\nArgumentError: If both m and n are specified as Colon, this causes ambiguity.\nArgumentError: If the elements of the first mode-size vector are not positive.\nArgumentError: If the elements of the second mode-size vector are not positive.\nArgumentError: If major is neither \"last\" (default) nor \"first\".\nArgumentError: If soft is negative or infinite.\nArgumentError: If hard is negative or finite.\nArgumentError: If atol is negative or infinte.\nArgumentError:  If rtol is negative or infinte.\nArgumentError: If optional argument rank is negative.\nDimensionMismatch: If the number of entries in the first mode-size vector is inconsistent with the specified factor.\nDimensionMismatch: If the number of entries in the second mode-size vector is inconsistent with the specified factor.\nDimensionMismatch: If not every mode dimension of W is divisible by the corresponding element of the specified mode-size vector\nDimensionMismatch: If specified mode-size vectors are inconsistent with the specified factor.\nErrorException: If squaring soft leads to overflow and it was passed finite.\nErrorException: If squaring soft leads to underflow and it was passed positive.\nErrorException: If sqauring hard leads to overflow and it was passed finite.\nErrorException: If squaring hard leads to underflow and it was passed positive.\nErrorException: If squaring atol leads to overflow and it was passed finite.\nErrorException: If squaring atol leads to underflow and it was passed positive.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorTrainFactorization","page":"Home","title":"TensorTrainFactorization","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the TensorTrainFactorization module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"DecSize \nDecRank\nDec\nVectorDec \nMatrixDec\ncheckndims\nchecklength\nchecksize\ncheckrank\ncheckranks\ndeclength\ndecndims\ndecsize\ndecranks\ndecrank\ndec\ndec!\nvector\ndecrankselect!\ndecrankselect\nfactor!\nblock! \ndecvcat \ndechcat\ndecdcat\ndecscale!\ndecreverse!\ndecmodetranspose!\ndecmodereshape\ndecfill!\ndecrand!\ndeczeros \ndecones \ndecrand\ndecappend!\ndecprepend! \ndecpush!\ndecpushfirst! \ndecpop!\ndecpopfirst!\ndecinsert!\ndecdeleteat!\ndecinsertidentity!\ndecskp!\ndecskp\ndecmp \ndeckp \ndecaxpby!\ndecadd!\ndecaxpby\ndecadd \ndechp\ndecqr! \ndecsvd!","category":"page"},{"location":"index.html#TensorRefinement.TensorTrain.DecSize","page":"Home","title":"TensorRefinement.TensorTrain.DecSize","text":"DecSize is an alias for a Matrix with integer entries of type Matrix{Int}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.DecRank","page":"Home","title":"TensorRefinement.TensorTrain.DecRank","text":"DecRank is an alias for a Vector with integer entries of type Vector{Int}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.Dec","page":"Home","title":"TensorRefinement.TensorTrain.Dec","text":"Dec is an alias for a Vector{Factor{T,N}}.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.VectorDec","page":"Home","title":"TensorRefinement.TensorTrain.VectorDec","text":"VectorDec{T} is an alias for Vector{VectorFactor{T}}`.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.MatrixDec","page":"Home","title":"TensorRefinement.TensorTrain.MatrixDec","text":"MatrixDec{T} is an alias for Vector{MatrixFactor{T}}`.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TensorRefinement.TensorTrain.checkndims","page":"Home","title":"TensorRefinement.TensorTrain.checkndims","text":"checkndims(d::Int)\n\nCheck the correctness of the numbers of dimensions.\n\nArguments\n\nd::Int: Input dimension.\n\nReturns\n\nNo Return. Function flags negative dimensions.\n\nThrows\n\nArgumentError: If d is negative.\n\n\n\n\n\ncheckndims(d::Vector{Int})\n\nCheck whether a given vector exhibits uniform values.\n\nArguments\n\nd::Vector{Int}: Input vector of integers.\n\nReturns\n\nNo Return. Function flags incorrent vectors.\n\nThrows\n\nArgumentError: If d does not contain elements.\nBoundsError: If the elements of d are negative or zero.\nArgumentError: If the values in the dimension vector differ.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.checklength","page":"Home","title":"TensorRefinement.TensorTrain.checklength","text":"checklength(L::Int)\n\nCheck the correctness of the length L.\n\nArguments\n\nL::Int: Input length.\n\nReturns\n\nNo Return. Function flags negative length.\n\nThrows\n\nArgumentError: If L is negative.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.checksize","page":"Home","title":"TensorRefinement.TensorTrain.checksize","text":"checksize(n::DecSize; len::Int=0, dim::Int=0)\n\nCheck the correctness of a given size matrix with integer entries (Type: Decsize).\n\nArguments\n\nn::DecSize: Input size matrix with integer entries.\nlen::Int=0: Length of the size matrix. By default, it is 0.\ndim::Int=0: Dimension of the size matrix. By default, it is 0.\n\nReturns\n\nNo Return. Function flags incorrent size matrix.\n\nThrows\n\nArgumentError: If n does not contain elements.\nArgumentError: If n contains negative or zero elements.\nArgumentError: If the number of factors is negative or zero.\nArgumentError: If the number of mode dimensions is negative or zero.\nArgumentError: If the number of rows is incorrect.\nArgumentError: If the number of columns is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.checkrank","page":"Home","title":"TensorRefinement.TensorTrain.checkrank","text":"checkrank(r::DecRank; len::Int=0)\n\nCheck the correctness of a given rank vector with integer entries (Type: DecRank).\n\nArguments\n\nr::DecRank: Input rank vector with integer entries.\nlen::Int=0: Length of the size matrix. By default, it is 0.\n\nReturns\n\nNo Return. Function flags incorrent rank vectors.\n\nThrows\n\nArgumentError: If r does not contain at least two elements.\nArgumentError: If r contains negative elements.\nArgumentError: If the number of elements in the rank vector is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.checkranks","page":"Home","title":"TensorRefinement.TensorTrain.checkranks","text":"checkranks(p::Vector{Int}, q::Vector{Int}; len::Int=0)\n\nCheck the correctness of two given rank vectors with integer entries.\n\nArguments\n\np::Vector{Int}: First input vector with integer entries.\nq::Vector{Int}: Second input vector with integer entries.\nlen::Int=0: Length of the vectors. By default, it is 0.\n\nReturns\n\nNo Return. Function flags incorrent rank vectors.\n\nThrows\n\nArgumentError: If p and q do not have the same length.\nArgumentError: If p or q contain negative elements.\nArgumentError: If the number of elements in the rank vectors is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.declength","page":"Home","title":"TensorRefinement.TensorTrain.declength","text":"function declength(U::Dec{T,N}) where {T<:Number,N}\n\nCheck the correctness of two given rank vectors with integer entries.\n\nArguments\n\nU::Dec{T,N}: Decomposition of N Factors of type Factor.\n\nReturns\n\nAn integer: the length of the decomposition.\n\nThrows\n\nArgumentError: If L is negative.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decndims","page":"Home","title":"TensorRefinement.TensorTrain.decndims","text":"decndims(U::Dec{T,N}) where {T<:Number,N}\n\nReturn the number of contraction dimensions of the decomposition.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec with elements of type T and with N as the number of factors.\n\nReturns\n\nAn integer representing the number of contraction dimensions, which is N - 2.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decsize","page":"Home","title":"TensorRefinement.TensorTrain.decsize","text":"decsize(U::Dec{T,N}) where {T<:Number,N}\n\nReturn a matrix representing the mode sizes of each factor in the decomposition U.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nA matrix of integers, where each column represents the different mode sizes for each factor contained in the decomposition U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decranks","page":"Home","title":"TensorRefinement.TensorTrain.decranks","text":"decranks(U::Dec{T,N}) where {T<:Number,N}\n\nReturn two vectors, which represent the first and last ranks, respectively, of each factor in the decomposition type U.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nTwo vectors of length L: p and q where p[ℓ] is the first rank and q[ℓ] is the last rank of the ℓ-th factor in U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decrank","page":"Home","title":"TensorRefinement.TensorTrain.decrank","text":"decrank(U::Dec{T,N}) where {T<:Number,N}\n\nReturn a vector of ranks by combining all first ranks of the factors of U and appending the last rank of the last factor in the decomposition at the end of the vector.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nA vector containing the first rank of each factor in U as well as the last rank of the last factor in the decomposition.\n\nThrows\n\nDimensionMismatch: If the factors in U have inconsistent ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.dec","page":"Home","title":"TensorRefinement.TensorTrain.dec","text":"dec(::Type{T}, d::Int, L::Int) where {T<:Number}\n\nCreate an empty decomposition with L factors, with each factor exhibiting d mode dimensions and entries of data type T.\n\nArguments\n\n::Type{T}: Data type of the elements in each factor.\nd::Int: Number of mode dimensions.\nL::Int: Number of factors.\n\nReturns\n\nVector of uninitialized arrays representing the decomposition.\n\nThrows\n\nArgumentError: If d or L is negative.\n\n\n\n\n\ndec(d::Int, L::Int)\n\nCreate an empty decomposition with L factors, with each factor exhibiting d mode dimensions and entries of default data type Float64.\n\nArguments\n\nd::Int: Number of mode dimensions.\nL::Int: Number of factors.\n\nReturns\n\nVector of uninitialized arrays representing the decomposition, with entries of default data type Float64.\n\nThrows\n\nArgumentError: If d or L is negative.\n\n\n\n\n\ndec(::Type{T}, d::Int) where {T<:Number}\n\nCreate an empty decomposition with zero factors, each having d mode dimensions and data type T.\n\nArguments\n\n::Type{T}: Data type of the elements in each factor.\nd::Int: Number of mode dimensions.\n\nReturns\n\nVector of uninitialized arrays representing an empty decomposition.\n\nThrows\n\nArgumentError: If d is invalid (i.e., if d is negative).\n\n\n\n\n\ndec(d::Int)\n\nCreate an empty decomposition with zero factors, each having d mode dimensions and default data type Float64.\n\nArguments\n\nd::Int: Number of mode dimensions.\n\nReturns\n\nVector of uninitialized arrays representing an empty decomposition with default data type Float64.\n\n\n\n\n\ndec(U::Dec{T,N}) where {T<:Number,N}\n\nReturn the decomposition U as is.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nThe decomposition object U as is.\n\n\n\n\n\ndec(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T<:Number}\n\nCreate a decomposition with specified size, rank, and further optional parameters.\n\nArguments\n\n::Type{T}: Data type of the elements in each factor.\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r was not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r was not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA vector of arrays representing the decomposition with each factor exibiting the size and rank specified in advance.\n\nThrows\n\nArgumentError: If the rank is not a nonnegative integer or a vector of such\nArgumentError: If the rank parameter does not contain at least two entries, when the rank parameter is specified as a vector.\nArgumentError: If the rank parameter does not contain L+1 entries, when the size parameter is specified as a matrix with L columns and the rank parameter is specified as a vector.\nArgumentError: If the first rank, when specified separately, is not positive.\nArgumentError: If the last rank, when specified separately, is not positive.\nArgumentError: If the first and last ranks are specified separately, even though the rank parameter is not specified as an integer.\nArgumentError: If the number of factors, when specified, is not positive.\nArgumentError: If the number of rows in the size matrix and the number of factors are not equal, when the number of rows in the size matrix is larger than one and the number of factors is specified.\nArgumentError: If len is not equal to L, when the rank parameter is specified as a vector with L+1 entries and the number of factors len is specified.\n\n\n\n\n\ndec(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)\n\nCreate a decomposition with default type Float64 using the specified size, rank, and optional parameters.\n\nArguments\n\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec with Float64 elements and the specified sizes, ranks, and parameters.\n\nThrows\n\nArgumentError: If invalid size, rank, or other parameters are provided (see detailed error control in the dec function with type specification).\n\n\n\n\n\ndec(U::Factor{T,N}; len::Int=1) where {T<:Number,N}\n\nCreate a decomposition type Dec (vector of factors) with a specified length, each factor being a copy of the factor U.\n\nArguments\n\nU::Factor{T,N}: Factor, whose entries are in T and with N dimensions, to use for creating the decomposition type.\nlen::Int=1: Length of the created decomposition, whose factors are copies of U.\n\nReturns\n\nDecomposition type whose factors consist of copies of U.\n\nThrows\n\nArgumentError: If the number of factors len, when specified, is not positive.\nArgumentError: If the two ranks of U are not equal when the number of factors len is specified as larger than one.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.dec!","page":"Home","title":"TensorRefinement.TensorTrain.dec!","text":"dec!(U::Factor{T,N}) where {T<:Number,N}\n\nConvert a single factor U into a decomposition object containing merely that factor.\n\nArguments\n\nU::Factor{T,N}: Factor of type factor to be turned into a decomposition.\n\nReturns\n\nDecomposition object Dec{T,N} containing the single factor U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.vector","page":"Home","title":"TensorRefinement.TensorTrain.vector","text":"vector(U::Dec{T,N}) where {T<:Number,N}\n\nReturn the decomposition U as is; since a decomposition type (vector of factors) is already a vector. \n\nArguments\n\nU::Dec{T,N}: Decomposition, whose entries are in T and with N dimensions.\n\nReturns\n\nThe input decomposition object U as is. \n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decrankselect!","page":"Home","title":"TensorRefinement.TensorTrain.decrankselect!","text":"decrankselect!(U::Dec{T,N}, α::Indices, β::Indices) where {T<:Number,N}\n\nSelect the first rank dimensions of the first factor and the last rank dimensions of the last factor in the decomposition U based on the provided indices α and β, modifying U in place.\n\nArguments\n\nU::Dec{T,N}: Decomposition, whose entries are in T and with N dimensions, to select ranks from.\nα::Indices: Reference numbers for selecting the first rank dimensions of the first factor of U.\nβ::Indices: Reference numbers for selecting the last rank dimensions of the last factor of U.\n\nReturns\n\nU: Decomposition type Dec, with the selected ranks. \n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decomposition is empty, or if α or β contain invalid or empty ranges.\n\nExtended Error list:\n\nArgumentError: If the range for the first rank is empty.\nArgumentError: If the range for the first rank is incorrect.\nArgumentError: If the range for the second rank is empty.\nArgumentError: If the range for the second rank is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decrankselect","page":"Home","title":"TensorRefinement.TensorTrain.decrankselect","text":"decrankselect(U::Dec{T,N}, α::Indices, β::Indices) where {T<:Number,N}\n\nCreate a new decomposition object by selecting the first rank dimensions of the first factor and the last rank dimensions of the last factor in the decomposition U based on the provided indices α and β.\n\nArguments\n\nU::Dec{T,N}: Decomposition, whose entries are in T and with N dimensions, to select ranks from.\nα::Indices: Reference numbers for selecting the first rank dimensions of the first factor of U.\nβ::Indices: Reference numbers for selecting the last rank dimensions of the last factor of U.\n\nReturns\n\nV: Decomposition type Dec, with the selected ranks. \n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decomposition is empty, or if α or β contain invalid or empty ranges.\n\nExtended Error list:\n\nArgumentError: If the range for the first rank is empty.\nArgumentError: If the range for the first rank is incorrect.\nArgumentError: If the range for the second rank is empty.\nArgumentError: If the range for the second rank is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.factor!","page":"Home","title":"TensorRefinement.TensorTrain.factor!","text":"factor!(U::Dec{T,N}; major::String=\"last\") where {T<:Number,N}\n\nFactorize the decomposition U in place to a single factor (by contracting along all mode dimensions).\n\nArguments\n\nU::Dec{T,N}: Decomposition, whose entries are in T and with N dimensions, to factorize.\nmajor::String=\"last\": Specifies the major ordering of the contraction. Can be \"first\" or \"last\".\n\nReturns\n\nSingle factor object obtained by contracting all factors in the input decomposition object U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.block!","page":"Home","title":"TensorRefinement.TensorTrain.block!","text":"block!(U::Dec{T,N}, α::Int, β::Int; major::String=\"last\") where {T<:Number,N}\n\nSelects first ranks of the first and last ranks of the last factor of the decomposition U specified by the indices α and β, contract all factors together in place and yield the resulting block.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, which to modify.\nα::Int: The index to select from the first rank.\nβ::Int: The index to select from the last rank.\nmajor::String=\"last\": Specifies the major ordering of the contraction. Can be \"first\" or \"last\".\n\nReturns\n\nResulting factor type U after rank selection and contraction to a block.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decvcat","page":"Home","title":"TensorRefinement.TensorTrain.decvcat","text":"decvcat(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T<:Number,N,M}\n\nVertically concatenate the factors of multiple decomposition types (vectors of factors).\n\nArguments\n\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nW::Vararg{Dec{T,N},M}: Additional decomposition types to concatenate.\n\nReturns\n\nNew decomposition type obtained by vertically concatenating the given decomposition types (vectors of factors).\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decompositions are incompatible in the number of factors, mode size, or last rank.\n\nExtended Error list:\n\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\nArgumentError: If the decompositions are incompatible in the last rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.dechcat","page":"Home","title":"TensorRefinement.TensorTrain.dechcat","text":"dechcat(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T<:Number,N,M}\n\nHorizontally concatenate the factors of multiple decomposition types (vectors of factors).\n\nArguments\n\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nW::Vararg{Dec{T,N},M}: Additional decompositions types to concatenate.\n\nReturns\n\nNew decomposition type obtained by horizontally concatenating the given decomposition types (vectors of factors).\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decompositions are incompatible in the number of factors, mode size, or first rank.\n\nExtended Error list:\n\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\nArgumentError: If the decompositions are incompatible in the first rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decdcat","page":"Home","title":"TensorRefinement.TensorTrain.decdcat","text":"decdcat(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T<:Number,N,M}\n\nConcatenates the factors of multiple decomposition types (vectors of factors) along a diagonal mode.\n\nArguments\n\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nW::Vararg{Dec{T,N},M}: Additional decomposition types to concatenate.\n\nReturns\n\nNew decomposition obtained by diagonally concatenating the factors of the given decomposition types.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decompositions are incompatible in the number of factors or mode size.\n\nExtended Error list:\n\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decscale!","page":"Home","title":"TensorRefinement.TensorTrain.decscale!","text":"decscale!(U::Dec{T,N}, α::T) where {T<:Number,N}\n\nScale the last factor of the decomposition type U in place by a scalar α.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, which is to be scaled.\nα::T: The scalar factor to multiply the last factor by.\n\nReturns\n\nU: Decomposition type with the last factor scaled by α.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decreverse!","page":"Home","title":"TensorRefinement.TensorTrain.decreverse!","text":"decreverse!(W::Dec{T,N}) where {T<:Number,N}\n\nReverse the order of factors in the decomposition W in place and transposes their ranks.\n\nArguments\n\nW::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, which is to be reversed.\n\nReturns\n\nW: The reversed decomposition of type Dec with transposed ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decmodetranspose!","page":"Home","title":"TensorRefinement.TensorTrain.decmodetranspose!","text":"decmodetranspose!(U::Dec{T,N}, τ::Union{NTuple{K,Int},Vector{Int}}) where {T<:Number,N,K}\n\nTranspose the mode dimensions of each factor in the decomposition type U according to the permutation τ.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, whose factors' modes are to be transposed.\nτ::Union{NTuple{K,Int},Vector{Int}}: A tuple or vector of integers specifiying the permutation of the mode dimensions.\n\nReturns\n\nU: Decomposition type, whose factors exhibit transposed mode dimensions.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decomposition has no mode dimensions or if τ is not a valid permutation.\n\nExtended Error list:\n\nArgumentError: If the decomposition has no mode dimensions.\nArgumentError: If τ is not a valid permutation of the mode dimensions of U.\n\n\n\n\n\ndecmodetranspose!(U::Dec{T,N}) where {T<:Number,N}\n\nTranspose the mode dimensions of each factor in the decomposition U by reversing the mode dimensions.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec whose factors' mode dimensions are to be reversed.\n\nReturns\n\nU: Decomposition of type Dec with the mode dimensions of each factor reversed.\n\nThrows\n\nArgumentError: If the decomposition has no mode dimensions.\nArgumentError: If the transpose operation is not applicable.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decmodereshape","page":"Home","title":"TensorRefinement.TensorTrain.decmodereshape","text":"decmodereshape(U::Dec{T,N}, n::DecSize) where {T<:Number,N}\n\nReshape each factor of the decomposition type (vector of factors) U to have new mode sizes specified by n.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, which is to be reshaped.\nn::DecSize: Size matrix specifying the new sizes for each mode of the factors of U.\n\nReturns\n\nNew decomposition with reshaped factors.\n\nThrows\n\nArgumentError: If the decomposition does not have at least one mode dimension\nArgumentError: If the number of columns in nis inconsistent with U.\nDimensionMismatch: If n is inconsistent with U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decfill!","page":"Home","title":"TensorRefinement.TensorTrain.decfill!","text":"decfill!(U::Dec{T,N}, v::T) where {T<:Number,N}\n\nFill each factor of the decomposition type U with the value v in place.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec whose factors are to be filled.\nv::T: The value to fill each element of the factors with.\n\nReturns\n\nU: Decomposition of type Dec with each factor filled with value v.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decrand!","page":"Home","title":"TensorRefinement.TensorTrain.decrand!","text":"decrand!(rng::AbstractRNG, U::Dec{T,N}) where {T<:Number,N}\n\nFill each factor of the decomposition type U with random numbers generated from the provided random number generator rng.\n\nArguments\n\nrng::AbstractRNG: Random number generator to utilize for generating random values.\nU::Dec{T,N}: Decomposition of type Dec, whose factors are to be filled with random numbers.\n\nReturns\n\nU: Decomposition of type Dec with each factor filled with random numbers.\n\n\n\n\n\ndecrand!(U::Dec{T,N}) where {T<:Number,N}\n\nFill each factor of the decomposition U with random numbers using the global random number generator.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec whose factors are to be filled with random numbers generated from the global RNG (Random.GLOBAL_RNG).\n\nReturns\n\nU: Decomposition of type Dec with each factor filled with random numbers.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.deczeros","page":"Home","title":"TensorRefinement.TensorTrain.deczeros","text":"deczeros(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T<:Number}\n\nCreate a decomposition of the specified type T where each factor is initialized to contain only zeros.\n\nArguments\n\n::Type{T}: Data type of the elements in each factor.\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec where each factor is filled with zeros.\n\n\n\n\n\ndeczeros(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)\n\nCreate a decomposition of type Float64 where each factor is initialized to contain only zeros.\n\nArguments\n\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec (with Float64 elements) where each factor is filled with zeros.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decones","page":"Home","title":"TensorRefinement.TensorTrain.decones","text":"decones(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T<:Number}\n\nCreate a decomposition of the specified type T where each factor is initialized to contain only ones.\n\nArguments\n\n::Type{T}: Data type of the elements in each factor.\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec with the specified data type T, where each factor is filled with ones.\n\n\n\n\n\ndecones(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)\n\nCreate a decomposition of type Float64 where each factor is initialized to contain only ones.\n\nArguments\n\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec with Float64 elements, where each factor is filled with ones.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decrand","page":"Home","title":"TensorRefinement.TensorTrain.decrand","text":"decrand(rng::AbstractRNG, ::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T<:Number}\n\nCreate a decomposition of the specified type T and fill each factor with random numbers generated by the provided random number generator rng.\n\nArguments\n\nrng::AbstractRNG: Random number generator to use for filling the decomposition with random numbers.\n::Type{T}: Data type of the elements in each factor.\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec with the specified data type T, where each factor is filled with random numbers generated by the provided rng.\n\n\n\n\n\ndecrand(rng::AbstractRNG, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)\n\nCreate a decomposition of type Float64 and fill each factor with random numbers generated by the provided random number generator rng.\n\nArguments\n\nrng::AbstractRNG: Random number generator to use for filling the decomposition with random numbers.\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec with Float64 elements, where each factor is filled with random numbers generated by the provided rng.\n\n\n\n\n\ndecrand(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T<:Number}\n\nCreate a decomposition of the specified type T and fill each factor with random numbers using the global random number generator (Random.GLOBAL_RNG).\n\nArguments\n\n::Type{T}: Data type of the elements in each factor.\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec with the specified data type T, where each factor is filled with random numbers generated by Random.GLOBAL_RNG.\n\n\n\n\n\ndecrand(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)\n\nCreate a decomposition of type Float64 and fill each factor with random numbers using the global random number generator (Random.GLOBAL_RNG).\n\nArguments\n\nn::Union{DecSize,FactorSize}: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.\nr::Union{Int,DecRank}: Rank or rank vector, representing the ranks of the decomposition.\nfirst::Int=0: Optional first rank. Specifies the rank of the first mode dimension if r is not expressed using a vector.\nlast::Int=0: Optional last rank. Specifies the rank of the last mode dimension if r is not expressed using a vector.\nlen::Int=0: Number of factors. Specifies the number of factors in the decomposition.\n\nReturns\n\nA decomposition of type Dec with Float64 elements, where each factor is filled with random numbers generated by Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decappend!","page":"Home","title":"TensorRefinement.TensorTrain.decappend!","text":"decappend!(U::Dec{T,N}, V::Dec{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number, N}\n\nAppend the decomposition type (vector of factors) V to the end of the decomposition type U in place. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\nU::Dec{T,N}: Target decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, to which V will be appended.\nV::Dec{T,N}: Decomposition of type Dec, which to append to U.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U and V before appending.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the combined result after appending.\n\nReturns\n\nU: Modified decomposition type U after appending V.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V are inconsistent in the number of dimensions.\nArgumentError:If the factors of U have incorrect or inconsistent ranks.\nArgumentError: If the factors of V have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decprepend!","page":"Home","title":"TensorRefinement.TensorTrain.decprepend!","text":"decprepend!(U::Dec{T,N}, V::Dec{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number, N}\n\nPrepend the decomposition type (vector of factors) V to the beginning of the decomposition type (vector of factors) U in place. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\nU::Dec{T,N}: Target decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, to which V will be prepended.\nV::Dec{T,N}: Decomposition of type Dec, which to append to U.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U and V before prepending.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the combined result after prepending.\n\nReturns\n\nU: Modified decomposition type U after prepending V.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions.\nArgumentError: If the factors of U have incorrect or inconsistent ranks.\nArgumentError: If the factors of V have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decpush!","page":"Home","title":"TensorRefinement.TensorTrain.decpush!","text":"decpush!(U::Dec{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number, N}\n\nPush a factor V to the end of the decomposition type (vector of factors) U in place. Optionally, the ranks before and after the operation are checked.\n\nArguments\n\nU::Dec{T,N}: Target decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, to which the factor V will be pushed.\nV::Factor{T,N}: The factor to push to the decomposition type (vector of factors) U.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U before pushing.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the result after pushing.\n\nReturns\n\nU: Modified decomposition type (vector of factors) U after pushing V.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if their ranks (in case of U, the ranks of its factors) are inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions.\nArgumentError: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decpushfirst!","page":"Home","title":"TensorRefinement.TensorTrain.decpushfirst!","text":"decpushfirst!(U::Dec{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number, N}\n\nPush a factor V to the beginning of the decomposition type (vector of factors) U in place. Optionally, the ranks before and after the operation are checked.\n\nArguments\n\nU::Dec{T,N}: Target decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, to which the factor V will be pushed at the beginning.\nV::Factor{T,N}: The factor to push to the beginning of U.\nrankprecheck::Bool=true: If true (by default), the ranks of U are checked before pushing.\nrankpostcheck::Bool=true: If true (by default), the ranks of the result are checked after pushing.\n\nReturns\n\nU: Modified decomposition type (vector of factors) U after pushing V at the beginning.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if their ranks (in case of U, the ranks of its factors) are inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions.\nDimensionMismatch: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decpop!","page":"Home","title":"TensorRefinement.TensorTrain.decpop!","text":"decpop!(U::Dec{T,N}) where {T<:Number, N}\n\nPop the last factor from the decomposition type (vector of factors) U and return it.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, from which to pop the last factor.\n\nReturns\n\nV: The last factor that was removed from U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decpopfirst!","page":"Home","title":"TensorRefinement.TensorTrain.decpopfirst!","text":"decpopfirst!(U::Dec{T,N}) where {T<:Number,N}\n\nPop the first factor from the decomposition type (vector of factors) U and return it.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, from which to pop the first factor.\n\nReturns\n\nV: The first factor that was removed from U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decinsert!","page":"Home","title":"TensorRefinement.TensorTrain.decinsert!","text":"decinsert!(U::Dec{T,N}, ℓ::Int, V::Factor{T,N}; path::String=\"\", rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number, N}\n\nInsert a factor V into the decomposition type (vector of factors) U at the specified index ℓ. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, in which to insert the factor V.\nℓ::Int: The index at which to insert the factor V.\nV::Factor{T,N}: The factor to insert into the decomposition U.\npath::String=\"\": The path direction for insertion; should be \"forward\" or \"backward\".\nrankprecheck::Bool=true: If true (by default), checks the ranks of U before insertion.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the result after insertion.\n\nReturns\n\nU: Modified decomposition type U after inserting V.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If path is neither \"forward\" nor \"backward\".\nDimensionMismatch: If ℓ is out of range or if the ranks (of U, V or the factors of U) are inconsistent for the operation.\n\nExtended Error list:\n\nArgumentError:  If path is neither \"forward\" nor \"backward\"\nArgumentError: If ℓ is not from 1:L, where L is the number of factors in `U\nDimensionMismatch: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decdeleteat!","page":"Home","title":"TensorRefinement.TensorTrain.decdeleteat!","text":"decdeleteat!(U::Dec{T,N}, Λ::Union{Int,Vector{Int},NTuple{M,Int} where M}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number, N}\n\nDelete factors from the decomposition type (vector of factors) U at the specified indices Λ in place. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, from which factors will be deleted.\nΛ::Union{Int,Vector{Int},NTuple{M,Int} where M}: Indices of factors to delete. Can be a single integer, a vector of integers, or a tuple of integers.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U before deletion.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the result after deletion.\n\nReturns\n\nU: Modified decomposition type U after deleting the specified factors.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the entries of Λ are not unique or are not within the valid range.\nDimensionMismatch: If the ranks of U are inconsistent for this operation.\n\nExtended Error list:\n\nArgumentError:  If the entries of Λ are not unique.\nArgumentError: If Λ is not an element or a subset of 1:L with unique entries, where L is the number of factors in U.\nDimensionMismatch: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decinsertidentity!","page":"Home","title":"TensorRefinement.TensorTrain.decinsertidentity!","text":"decinsertidentity!(U::Dec{T,N}, ℓ::Int; path::String=\"\", rankprecheck::Bool=true) where {T<:Number, N}\n\nInsert an identity factor into the decomposition type (vector of factors) U at the specified index ℓ. Optionally, the ranks are checked before the operation.\n\nArguments\n\nU::Dec{T,N}: Decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions, in which to insert the identity factor.\nℓ::Int: The index at which to insert the identity factor.\npath::String=\"\": The path direction for insertion (should be \"forward\" or \"backward\").\nrankprecheck::Bool=true: If true (by default), the ranks of U are checked before insertion.\n\nReturns\n\nU: Modified decomposition type U after inserting the identity factor.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If path is neither \"forward\" nor \"backward\".\nDimensionMismatch: If ℓ is out of range or if the ranks are inconsistent for this operation.\n\nExtended Error list:\n\nArgumentError:  If the is neither \"forward\" nor \"backward\".\nArgumentError: If ℓ is not from 1:L, where L is the number of factors in U.\nDimensionMismatch: If the factors of U have inconsistent ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decskp!","page":"Home","title":"TensorRefinement.TensorTrain.decskp!","text":"decskp!(W::Dec{T,N}, Λ::Indices; path::String=\"\", major::String=\"last\") where {T<:Number, N}\n\nPerform sequential contraction of components of a vector of factors W based on specified indices Λ, following a specified path and contraction order.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, which represents a vector of factors with elements of type T and with N as the number dimensions.\nΛ::Indices: reference numbers specifying which components of (the vector of factors) W to contract. Can be a colon Colon (indicating all indices) or a Vector{Int} specifying particular indices.\npath::String=\"\": Keyword argument specifying the order of contraction. \n\"\" (default): Path can be deduced from Λ if Λ is a colon or empty.\n\"forward\": Contraction of components in a forward sequence.\n\"backward\": Contraction of components in a backward sequence.\nmajor::String=\"last\": Keyword argument indicating the primary direction for the contraction operation.\n\"last\" (default): Contraction focuses on the last dimension.\n\"first\": Contraction focuses on the first dimension.\n\nReturns\n\nW: modified decomposition object (vector of factors) after performing the contractions on the specified components.\n\nThrows\n\nArgumentError: If path is not one of \"\", \"forward\", or \"backward\".\nArgumentError: If  major is neither \"first\" nor \"last\".\nArgumentError: If the decomposition object W is empty (L == 0).\nArgumentError: If Λ is a colon, but path is specified as non-empty.\nArgumentError: If Λ is neither empty nor a colon and path is neither \"forward\" nor \"backward\".\nArgumentError: If Λ has duplicate entries.\nArgumentError: If Λ contains invalid indices that do not match the expected range based on path and the number of factors in W.\n\n\n\n\n\ndecskp!(W::Dec{T,N}; path::String=\"\", major::String=\"last\") where {T<:Number,N}\n\nPerform sequential contraction of all components of a decomposition W following the specified contraction path and direction. This function carries out the « Strong Kronecker Product » in place.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, which represents a vector of factors with elements of type T and with N as the number of dimensions.\npath::String=\"\": Keyword argument specifying the order of contraction.\n\"\" (default): Path can be deduced if all indices are used.\n\"forward\": Contract components in a forward sequence.\n\"backward\": Contract components in a backward sequence.\nmajor::String=\"last\": Keyword argument indicating the primary direction for the contraction.\n\"last\" (default): Focuses on the last dimension.\n\"first\": Focuses on the first dimension.\n\nReturns\n\nW: The modified decomposition object after performing the contractions.\n\nThrows\n\nArgumentError: If path is not one of \"\", \"forward\", or \"backward\".\nArgumentError: If major is neither \"first\" nor \"last\".\nArgumentError: If the decomposition object W is empty (L == 0).\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decskp","page":"Home","title":"TensorRefinement.TensorTrain.decskp","text":"decskp(W::Dec{T,N}, Λ::Indices; path::String=\"\", major::String=\"last\") where {T<:Number,N}\n\nPerform a sequential contraction of selected components of a decomposition object (vector of factors) W based on specified indices Λ, a path (\"forward\", \"backward\", or \"\"), and a major contraction direction. This function carries out the « Strong Kronecker Product » for specified factors in a decomposition and yields a new decomposition as result.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, which represents a vector of factors with elements of type T and with N as the number dimensions.\nΛ::Indices: Reference numbers specifying which components of the decomposition obeject W to contract. Can be a colon Colon (indicating all indices), a Vector{Int}, or other types convertible to an index vector.\npath::String=\"\": Keyword argument specifying the order of contraction. \n\"\" (default): Approved only if Λ is empty or Λ is a colon.\n\"forward\": Contraction of components in a forward sequence.\n\"backward\": Contraction of components in a backward sequence.\nmajor::String=\"last\": Keyword argument determining the primary direction for the contraction operation.\n\"last\" (default): Contraction focuses on last dimension.\n\"first\": Contraction focuses on first dimension.\n\nReturns\n\nU: Result of contracting the selected components of W based on the provided indices Λ and the specified path and major direction.\n\nThrows\n\nArgumentError: If path is not one of \"\", \"forward\", or \"backward\".\nArgumentError: If major is neither \"first\" nor \"last\".\nArgumentError: If the decomposition object W is empty (L == 0).\nArgumentError: If Λ is empty.\nArgumentError: If Λ is not a contiguous set of integers.\nArgumentError: If Λ is a colon, but path is specified as non-empty.\nArgumentError: If Λ is neither empty nor a colon and path is not specified (\"forward\", or \"backward\") .\nArgumentError: If Λ has duplicate entries.\nArgumentError: If Λ contains invalid indices that do not match the expected range based on path and the number of factors in W.\n\n\n\n\n\ndecskp(W::Dec{T,N}; path::String=\"\", major::String=\"last\") where {T<:Number,N}\n\nPerform sequential contraction of all components of a decomposition W, following the specified contraction path and direction. This function carries out the « Strong Kronecker Product » for all factors in a decomposition and yields a new decomposition as result.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, which represents a vector of factors with elements of type T and with N as the number of dimensions.\npath::String=\"\": Keyword argument specifying the order of contraction.\n\"\" (default): Path can be deduced if all indices are used.\n\"forward\": Contract components in a forward sequence.\n\"backward\": Contract components in a backward sequence.\nmajor::String=\"last\": Keyword argument indicating the primary direction for the contraction.\n\"last\" (default): Focuses on the last dimension.\n\"first\": Focuses on the first dimension.\n\nReturns\n\nThe contracted decomposition of type Dec.\n\nThrows\n\nArgumentError: If path is not one of \"\", \"forward\", or \"backward\".\nArgumentError: If  major is neither \"first\" nor \"last\".\nArgumentError: If the decomposition object W is empty (L == 0).\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decmp","page":"Home","title":"TensorRefinement.TensorTrain.decmp","text":"decmp(U₁::Dec{T,N₁}, σ₁::Indices, U₂::Dec{T,N₂}, σ₂::Indices) where {T<:Number, N₁, N₂}\n\nPerform the mode product of two decomposition objects U₁ and U₂ along specified sets of modes and returns a new decomposition object resulting from the multiplication.\n\nArguments\n\nU₁::Dec{T,N₁}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N₁ dimensions.\nσ₁::Indices: A set of mode indices for U₁. Specifies which modes of U₁ to multiply.\nU₂::Dec{T,N₂}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N₂ dimensions.\nσ₂::Indices: A set of mode indices for U₂. Specifies which modes of U₂ to multiply.\n\nReturns\n\nU: A new decomposition object resulting from the mode product of U₁ and U₂ along the specified modes.\n\nThrows\n\nArgumentError: If σ₁ is passed as a vector, and it is not a vector of the type Vector{Int} and not an empty vector of the type Vector{Any}.\nArgumentError: If σ₂ is passed as a vector, and it is not a vector of the type Vector{Int} and not an empty vector of the type Vector{Any}.\nArgumentError: If U₁ and U₂ differ in the number of factors.\nArgumentError: If the specified sets of modes of σ₁ and σ₂ are inconsistent.\nArgumentError: If the set of modes of U₁ is specified incorrectly.\nArgumentError: If the set of modes of U₂ is specified incorrectly.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.deckp","page":"Home","title":"TensorRefinement.TensorTrain.deckp","text":"deckp(U::Union{Dec{T,N}, Pair{Dec{T,N}, Int}}, V::Vararg{Union{Dec{T,N}, Pair{Dec{T,N}, Int}}, M}) where {T<:Number, N, M}\n\nPerform the Kronecker product on multiple decomposition objects, optionally with specified exponents for each decomposition object, and return a new decomposition object resulting from the product.\n\nArguments\n\nU::Union{Dec{T,N}, Pair{Dec{T,N}, Int}}: First decomposition object or a pair of a decomposition object and an exponent. If a pair, the exponent specifies how many times the decomposition object is repeated in the Kronecker product.\nV::Vararg{Union{Dec{T,N}, Pair{Dec{T,N}, Int}}, M}: Additional decomposition objects or pairs of decomposition objects and exponents to include in the Kronecker product.\n\nReturns\n\nW: A new decomposition object resulting from the Kronecker product of the input decompositions, each raised to its corresponding exponent.\n\nThrows\n\nArgumentError: If any specified exponent is negative.\nArgumentError: If the input decompositions differ in the number of factors.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decaxpby!","page":"Home","title":"TensorRefinement.TensorTrain.decaxpby!","text":"decaxpby!(α::Vector{T}, U::Dec{T,N}, β::Vector{T}, V::Dec{T,N}) where {T<:Number,N}\n\nPerform the operation U = α .* U + β .* V for decompositions U and V, where α and β are vectors of scalars that scale the corresponding factors of U and V respectively. The operation modifies U directly.\n\nArguments\n\nα::Vector{T}: Vector of scaling factors for the decomposition object U. Must have the same length as the number of factors in U.\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nβ::Vector{T}: Vector of scaling factors for the decomposition object V. Must have the same length as the number of factors in V.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nU: Modified decomposition object U after applying the operation.\n\nThrows\n\nSummarized Error List:\n\nArgumentError: If U and V have a different number of factors, differ in mode sizes, are incompatible in ranks, or if α and β do not have the correct lengths.\n\nExtended Error List:\n\nArgumentError: If U and V differ in the number of factors\nArgumentError: If U and V are inconsistent in mode size\nArgumentError: If α does not have the same length as U and V\nArgumentError: If β does not have the same length as U and V\nArgumentError: If the decompositions is incompatible in the first rank.\nArgumentError: If the decompositions is incompatible in the last rank.\n\n\n\n\n\ndecaxpby!(α::T, U::Dec{T,N}, β::T, V::Dec{T,N}) where {T<:Number,N}\n\nPerform the operation U = α .* U + β .* V for decompositions U and V, where α and β are scalar values that scale all factors of U and V respectively. The operation modifies U directly.\n\nArguments\n\nα::T: Scalar value to scale all factors of U.\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nβ::T: Scalar value to scale all factors of V.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nU: Modified decomposition object U after applying the operation.\n\nThrows\n\nArgumentError: If U and V have a different number of factors, differ in mode sizes, or are incompatible in ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decadd!","page":"Home","title":"TensorRefinement.TensorTrain.decadd!","text":"decadd!(U::Dec{T,N}, V::Dec{T,N}) where {T<:Number,N}\n\nPerform the operation U = U + V , adding decomposition V to U and modifying U directly.\n\nArguments\n\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nU: The modified decomposition object U after the addition.\n\nThrows\n\nSummarized Error List:\n\nArgumentError: If U and V are incompatible in the number of factors, mode size, the first or the last rank.\n\nExtended Error List:\n\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\nArgumentError: If the decompositions are incompatible in the first rank.\nArgumentError: If the decompositions are incompatible in the last rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decaxpby","page":"Home","title":"TensorRefinement.TensorTrain.decaxpby","text":"decaxpby(α::Vector{T}, U::Dec{T,N}, β::Vector{T}, V::Dec{T,N}) where {T<:Number,N}\n\nPerform the operation U = α .* U + β .* V for decompositions U and V, where α and β are vectors of scalars that scale the corresponding factors of U and V respectively. The result is returned as a new decomposition.\n\nArguments\n\nα::Vector{T}: Vector of scaling factors for the decomposition object U. Must have the same length as the number of factors in U.\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nβ::Vector{T}: Vector of scaling factors for the decomposition object V. Must have the same length as the number of factors in V.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nA new decomposition resulting from the operation α .* U + β .* V.\n\nThrows\n\nArgumentError: If U and V have a different number of factors, differ in mode sizes, or are incompatible in ranks, or if α and β do not have the correct lengths.\n\n\n\n\n\ndecaxpby(α::T, U::Dec{T,N}, β::T, V::Dec{T,N}) where {T<:Number,N}\n\nPerform the operation U = α .* U + β .* V for decompositions U and V, where α and β are scalar values that scale all factors of U and V respectively. The result is returned as a new decomposition.\n\nArguments\n\nα::T: Scalar value to scale all factors of U.\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nβ::T: Scalar value to scale all factors of V.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nA new decomposition resulting from the operation α .* U + β .* V.\n\nThrows\n\nArgumentError: If U and V have a different number of factors, differ in mode sizes, or are incompatible in ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decadd","page":"Home","title":"TensorRefinement.TensorTrain.decadd","text":"decadd(U::Dec{T,N}, V::Dec{T,N}) where {T<:Number,N}\n\nPerform the element-wise addition of two decompositions U and V. The result is returned as a new decomposition.\n\nArguments\n\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nA new decomposition resulting from the element-wise addition of U and V.\n\nThrows\n\nArgumentError: If U and V have a different number of factors, differ in mode sizes, or are incompatible in ranks.\n\n\n\n\n\ndecadd(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T<:Number,N,M}\n\nAdd multiple decompositions U, V and W... by stacking their factors and return a new decomposition object that represents their sum.\n\nArguments\n\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nW::Vararg{Dec{T,N},M}: Additional decomposition objects to add.\n\nReturns\n\nA new decomposition object obtained by horizontal and vertical concatenation of the factors of all given decompositions.\n\nThrows\n\nSummarized error list:\n\nArgumentError: Thrown if any of the decompositions have incompatible dimensions or ranks.\n\nExtended error list:\n\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\nArgumentError: If the decompositions are incompatible in the first rank.\nArgumentError: If the decompositions are incompatible in the last rank.\n\nDetails\n\nThe factors of each decomposition are stacked together as follows:\nThe first factor is concatenated horizontally.\nThe middle factors are concatenated diagonally.\nThe last factor is concatenated vertically.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.dechp","page":"Home","title":"TensorRefinement.TensorTrain.dechp","text":"dechp(U::Dec{T,N}, V::Dec{T,N}) where {T<:Number,N}\n\nPerform the Hadamard product (element-wise multiplication) of two decompositions U and V and return a new decomposition object W.\n\nArguments\n\nU::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\nV::Dec{T,N}: Second decomposition of type Dec, which represents a vector of factors whose entries are in T and with N dimensions.\n\nReturns\n\nW: A new decomposition  of type Dec, which results from the Hadamard product of U and V.\n\nThrows\n\nArgumentError: If U and V have a different number of factors or are inconsistent in mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decqr!","page":"Home","title":"TensorRefinement.TensorTrain.decqr!","text":"decqr!(W::Dec{T,N}, Λ::Indices; pivot::Bool=false, path::String=\"\", returnRfactors::Bool=false) where {T<:FloatRC, N}\n\nPerform a QR decomposition on the components of a decomposition object (vector of factors) W with specified indices Λ, following a given path, and optional pivoting.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, which represents a vector of factors with elements of type T and with N as the number dimensions.\nΛ::Indices: reference numbers specifying which components of the decomposition object W to apply the QR decomposition to. Can be a colon Colon (indicating all indices) or a Vector{Int}.\npivot::Bool=false: keyword argument indicating whether pivoting should be used in the QR decomposition.\npath::String=\"\": keyword argument specifying the order of decomposition. \n\"\" (default): The path is deduced from Λ if possible.\n\"forward\": Performs decomposition in a forward sequence.\n\"backward\": Performs decomposition in a backward sequence.\nreturnRfactors::Bool=false: keyword argument indicating whether to return the R factors from the QR decomposition along with the modified decomposition object W.\n\nReturns\n\nW: modified decomposition object after performing the QR decomposition on the specified components.\nRfactors (optional): vector of Matrix{T} containing the R factors from the QR decompositions; returned if returnRfactors is true.\n\nThrows\n\nArgumentError: If the decomposition object W is empty (L == 0).\nArgumentError: If path is not one of \"\", \"forward\", or \"backward\".\nArgumentError: If path cannot be deduced from Λ when path is \"\".\nArgumentError: If Λ contains duplicate entries.\nArgumentError: If Λ is not a contiguous set of integers.\nArgumentError: If Λ is out of the valid range for the indices of W.\nArgumentError: If Λ is neither sorted in ascending nor in descending order, leading to inconsitency with either \"forward\" or \"backward\" path.\nArgumentError: If Λ is not sorted in a consistent order with the path (ascending order matches \"forward\"path; descending order matches\"backward\"path`).\n\n\n\n\n\ndecqr!(W::Dec{T,N}; pivot::Bool=false, path::String=\"\", returnRfactors::Bool=false) where {T<:FloatRC,N}\n\nPerform a QR decomposition on all factors of a decomposition object (vector of factors) W, using optional pivoting and following the specified contraction path.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, which represents a vector of factors with elements of type T and N dimensions.\npivot::Bool=false: Keyword argument indicating whether to apply pivoting during the QR decomposition.\npath::String=\"\": Specifies the contraction path for the decomposition, either \"\" (default), \"forward\", or \"backward\". \n\"\": The path is deduced from the indices if possible.\n\"forward\": Decomposes in a forward sequence.\n\"backward\": Decomposes in a backward sequence.\nreturnRfactors::Bool=false: Whether to return the R factors from the QR decompositions.\n\nReturns\n\nW: Modified decomposition object after applying the QR decomposition.\nRfactors (optional): If returnRfactors is set to true, a vector of Matrix{T} containing the R factors from the QR decomposition is returned.\n\nThrows\n\nArgumentError: If the decomposition object W is empty (L == 0).\nArgumentError: If path is neither \"forward\" nor \"backward\".\nArgumentError: If path is \"\", because the path cannot be deduced when Λ is a colon.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.decsvd!","page":"Home","title":"TensorRefinement.TensorTrain.decsvd!","text":"decsvd!(W::Dec{T,N}, Λ::Indices, n::Union{Colon,DecSize}; \n        path::String=\"\", \n        soft::Float2{AbstractFloat}=zero(S), \n        hard::Float2{AbstractFloat}=zero(S), \n        aTol::Float2{AbstractFloat}=zero(S), \n        aTolDistr::Float2{AbstractFloat}=zero(S), \n        rTol::Float2{AbstractFloat}=zero(S), \n        rTolDistr::Float2{AbstractFloat}=zero(S), \n        rank::Int2=0, \n        major::String=\"last\")\nwhere {S<:AbstractFloat,T<:FloatRC{S},N}\n\nPerform a truncated Singular Value Decomposition (SVD) on a decomposition object (vector of factors) W.\n\nArguments\n\nW::Dec{T,N}: Decomposition object of type Dec, which represents a vector of factors with elements of type T and with N as the number dimensions.\nΛ::Indices: Reference number or a vector of reference numbers specifying the factors of W to be decomposed.\nn::Union{Colon,DecSize}: Specifies the mode sizes for the factors to be decomposed. If Colon, the mode sizes of the factors are deduced from W.\npath::String=\"\": Specifies the path for decomposition, either \"forward\" or \"backward\". Defaults to \"\", which means the path will be automatically deduced.\nsoft::Float2{AbstractFloat}=zero(S): Soft threshold for truncation, either non-negative scalar or vector of such (one per decomposition step).\nhard::Float2{AbstractFloat}=zero(S): Hard threshold for truncation, either non-negative scalar or vector of such, (one per decomposition step).\naTol::Float2{AbstractFloat}=zero(S): Absolute tolerance for SVD, either non-negative scalar or vector of such, (one per decomposition step).\naTolDistr::Float2{AbstractFloat}=zero(S): Distributed absolute tolerance for SVD, either a non-negative scalar or a vector of such, (one per decomposition step).\nrTol::Float2{AbstractFloat}=zero(S): Relative tolerance for SVD, either a non-negative scalar or a vector of such, (one per decomposition step).\nrTolDistr::Float2{AbstractFloat}=zero(S): Distributed relative tolerance for SVD, either a non-negative scalar or a vector of such, (one per decomposition step).\nrank::Int2=0: Rank for truncation, either a non-negative integer or a vector of such, (one per decomposition step).\nmajor::String=\"last\": Specifies the major ordering of the modes in the vector of factors. Must be either \"first\" or \"last\". Default is set to \"last\".\n\nReturns\n\nW: Updated decomposition object with SVD applied.\nε: Vector of float numbers representing the computed truncation error for each decomposition step.\nδ: Vector of float numbers representing the relative error for each decomposition step.\nμ: Norm of the decomposition object.\nρ: Vector of integers representing the ranks after truncation for each decomposition step.\nσ: Vector of vectors containing the singular values for each decomposition step.\n\nThrows\n\nSummarized Error List:\n\nArgumentError: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.\n\nExtended Error List:\n\nArgumentError: If the decomposition is empty.\nArgumentError: If path is none of the following: \"\" (default, accepted only when path can be deduced from Λ), \"forward\" or \"backward\".\nArgumentError: If path cannot be deduced from Λ or is the path is neither \"forward\" nor \"backward\" when Λ is a colon.\nArgumentError: If the entries of Λ do not form a set of contiguous integers.\nArgumentError: If Λ is out of range.\nArgumentError: If Λ is not sorted in ascending or descending order, rendering it inconsistent with any forward or backward path.\nArgumentError: If Λ is not sorted in ascending order, rendering it inconsistent with any forward path.\nArgumentError: If Λ is not sorted in descending order, rendering it inconsistent with any backward path.\nArgumentError: If the number of rows in n is not equal to the number of dimensions in each factor of W.\nArgumentError: If the number of columns in n is not equal to the number of elements in Λ.\nArgumentError: If n and Λ are incompatible with the size of the factors of W.\nArgumentError: If soft is not a nonnegative Float or a vector of such.\nArgumentError: If soft, passed as a vector, has incorrect length.\nArgumentError: If hard is not a nonnegative Float or a vector of such.\nArgumentError: If hard, passed as a vector, has incorrect length.\nArgumentError: If aTol is not a nonnegative Float64 or a vector of such.\nArgumentError: If aTol, passed as a vector, has incorrect length.\nArgumentError: If aTolDistr is not a nonnegative Float64 or a vector of such.\nArgumentError: If aTolDistr, passed as a vector, has incorrect length.\nArgumentError: If rTol is not a nonnegative Float or a vector of such.\nArgumentError: If rTol, passed as a vector, has incorrect length.\nArgumentError: If rTolDistr is not a nonnegative Float or a vector of such.\nArgumentError: If rTolDistr, passed as a vector, has incorrect length.\nArgumentError: If rank is not a nonnegative Int or a vector of such.\nArgumentError: If rank, passed as a vector, has incorrect length.\nArgumentError: If major is neither \"last\" (default) nor \"first\".\n\n\n\n\n\ndecsvd!(W::Dec{T,N}, Λ::Indices; path::String=\"\", soft::Float2{AbstractFloat}=zero(S), \n        hard::Float2{AbstractFloat}=zero(S), aTol::Float2{AbstractFloat}=zero(S), \n        aTolDistr::Float2{AbstractFloat}=zero(S), rTol::Float2{AbstractFloat}=zero(S), \n        rTolDistr::Float2{AbstractFloat}=zero(S), rank::Int2=0, major::String=\"last\") \nwhere {S<:AbstractFloat, T<:FloatRC{S}, N}\n\nPerform a truncated Singular Value Decomposition (SVD) on the components of a decomposition object (vector of factors) W with specified indices Λ, applying truncation based on thresholds, tolerances, and ranks. Function deduces mode sizes from the Dec object W.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, representing a vector of factors with elements of type T and N dimensions.\nΛ::Indices: Indices specifying which factors of W to apply the SVD to.\npath::String=\"\": Specifies the contraction path for the decomposition. Can be \"forward\", \"backward\", or \"\" (default, where the path is deduced).\nsoft::Float2{AbstractFloat}=zero(S): Soft threshold for truncation.\nhard::Float2{AbstractFloat}=zero(S): Hard threshold for truncation.\naTol::Float2{AbstractFloat}=zero(S): Absolute tolerance for SVD.\naTolDistr::Float2{AbstractFloat}=zero(S): Distributed absolute tolerance for SVD.\nrTol::Float2{AbstractFloat}=zero(S): Relative tolerance for SVD.\nrTolDistr::Float2{AbstractFloat}=zero(S): Distributed relative tolerance for SVD.\nrank::Int2=0: Rank for truncation.\nmajor::String=\"last\": Specifies whether to focus on the \"first\" or \"last\" mode during truncation. Defaults to \"last\".\n\nReturns\n\nW: Modified decomposition object after performing the truncated SVD.\nε: Vector of truncation errors for each step.\nδ: Vector of relative errors for each step.\nμ: Norm of the decomposition object.\nρ: Vector of post-truncation ranks for each step.\nσ: Vector of vectors containing the singular values for each step.\n\nThrows\n\nArgumentError: If any arguments are invalid, for example incorrect dimensions or invalid thresholds.\nFor an extended error list, see the default version of decsvd!.\n\n\n\n\n\ndecsvd!(W::Dec{T,N}; path::String=\"\", soft::Float2{AbstractFloat}=zero(S), \n        hard::Float2{AbstractFloat}=zero(S), aTol::Float2{AbstractFloat}=zero(S), \n        aTolDistr::Float2{AbstractFloat}=zero(S), rTol::Float2{AbstractFloat}=zero(S), \n        rTolDistr::Float2{AbstractFloat}=zero(S), rank::Int2=0, major::String=\"last\") \nwhere {S<:AbstractFloat, T<:FloatRC{S}, N}\n\nPerform a truncated Singular Value Decomposition (SVD) on all components of a decomposition object (vector of factors) W with optional truncation based on thresholds, tolerances, and ranks.\n\nArguments\n\nW::Dec{T, N}: Decomposition object of type Dec, representing a vector of factors with elements of type T and N dimensions.\npath::String=\"\": Specifies the contraction path for the decomposition. Can be \"forward\", \"backward\", or \"\" (default, where the path is deduced).\nsoft::Float2{AbstractFloat}=zero(S): Soft threshold for truncation.\nhard::Float2{AbstractFloat}=zero(S): Hard threshold for truncation.\naTol::Float2{AbstractFloat}=zero(S): Absolute tolerance for SVD.\naTolDistr::Float2{AbstractFloat}=zero(S): Distributed absolute tolerance for SVD.\nrTol::Float2{AbstractFloat}=zero(S): Relative tolerance for SVD.\nrTolDistr::Float2{AbstractFloat}=zero(S): Distributed relative tolerance for SVD.\nrank::Int2=0: Rank for truncation.\nmajor::String=\"last\": Specifies whether to focus on the \"first\" or \"last\" mode during truncation. Defaults to \"last\".\n\nReturns\n\nW: Modified decomposition object after performing the truncated SVD.\nε: Vector of truncation errors for each step.\nδ: Vector of relative errors for each step.\nμ: Norm of the decomposition object.\nρ: Vector of post-truncation ranks for each step.\nσ: Vector of vectors containing the singular values for each step.\n\nThrows\n\nArgumentError: If any arguments are invalid, such as incorrect dimensions, invalid thresholds, or mismatched sizes for paths or ranks.\nFor an extended error list, see the default version of decsvd!.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TT","page":"Home","title":"TT","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This section covers functions related to the TT module of the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"TT\nTensorRefinement.TensorTrain.length\nTensorRefinement.TensorTrain.ndims \nTensorRefinement.TensorTrain.size \nTensorRefinement.TensorTrain.rank \nranks\nTensorRefinement.TensorTrain.deepcopy\nTensorRefinement.TensorTrain.reverse! \nTensorRefinement.TensorTrain.permutedims!\nTensorRefinement.TensorTrain.fill!\nTensorRefinement.TensorTrain.rand!\ngetfirstfactor\ngetlastfactor \ngetfactor\nsetfirstfactor! \nsetlastfactor!\nsetfactor!\nrankselect! \nrankselect\nTensorRefinement.TensorTrain.getindex\nTensorRefinement.TensorTrain.append!\nTensorRefinement.TensorTrain.prepend!\nTensorRefinement.TensorTrain.push!\nTensorRefinement.TensorTrain.pushfirst!\nTensorRefinement.TensorTrain.pop!\nTensorRefinement.TensorTrain.popfirst!\nTensorRefinement.TensorTrain.insert!\nTensorRefinement.TensorTrain.deleteat!\ncompose!\ncompose\ncomposecore!\ncomposecore\ncomposeblock!\ncomposeblock\nTensorRefinement.TensorTrain.vcat\nTensorRefinement.TensorTrain.hcat\ndcat\nTensorRefinement.TensorTrain.lmul!\nTensorRefinement.TensorTrain.rmul!\nmul\nhad \n*\nTensorRefinement.TensorTrain.kron\n⊗\nadd\n+\nTensorRefinement.TensorTrain.qr!\nTensorRefinement.TensorTrain.svd!","category":"page"},{"location":"index.html#TensorRefinement.TensorTrain.TT","page":"Home","title":"TensorRefinement.TensorTrain.TT","text":"struct TT{T<:Number, N}\n\nA tensor train (TT) structure that represents a given tensor in the TT format. \n\nFields\n\nfactors::Dec{T,N}: A decomposition that contains the factors of the tensor train. \n\nConstructor\n\nTT(factors::Dec{T,N}): Construct a TT object with the specified factors. \n\nThrow an ArgumentError if N < 2, since no factor should have less than two rank indices.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Base.length","page":"Home","title":"Base.length","text":"length(U::TT{T,N})\n\nReturn the number of factors in the tensor train U.\n\nArguments\n\nU::TT{T,N}: Tensor train object of type TT.\n\nReturns\n\nInt: Number of factors in U.\n\nThrows\n\nArgumentError: If the lenght L is negative.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.ndims","page":"Home","title":"Base.ndims","text":"ndims(U::TT{T,N})\n\nReturn the number of mode dimensions of the tensor train object U.\n\nArguments\n\nU::TT{T,N}: Tensor train object of type TT.\n\nReturns\n\nInt: Number of mode dimensions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.size","page":"Home","title":"Base.size","text":"size(U::TT{T,N})\n\nReturn the sizes of each mode of the tensor train object U.\n\nArguments\n\nU::TT{T,N}: Tensor train object of type TT.\n\nReturns\n\nA matrix of integers, where each column represents the different mode sizes for each factor contained in the tensor train.\n\n\n\n\n\n","category":"function"},{"location":"index.html#LinearAlgebra.rank","page":"Home","title":"LinearAlgebra.rank","text":"rank(U::TT{T,N}) where {T<:Number,N}\n\nReturn a vector of ranks, which consists of all first ranks of the factors in the given tensor train and the last rank of the last factor.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\n\nReturns\n\nA vector containing the first rank of each factor in U as well as the last rank of the last factor in the decomposition.\n\nThrows\n\nDimensionMismatch: If the factors in U have inconsistent ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.ranks","page":"Home","title":"TensorRefinement.TensorTrain.ranks","text":"ranks(U::TT{T,N})\n\nReturn the ranks of the tensor train object U.\n\nArguments\n\nU::TT{T,N}: Tensor train object of type TT.\n\nReturns\n\nTwo vectors of length L: p and q where p[ℓ] is the first rank and q[ℓ] is the last rank of the ℓ-th factor in the tensor train U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.deepcopy","page":"Home","title":"TensorRefinement.TensorTrain.deepcopy","text":"deepcopy(U::TT{T,N})\n\nReturn a deep copy of the tensor train object U.\n\nArguments\n\nU::TT{T,N}: Tensor train object.\n\nReturns\n\nTT{T,N}: A deep copy of U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.reverse!","page":"Home","title":"Base.reverse!","text":"reverse!(W::TT{T,N})\n\nReverse the order of factors in the tensor train W in place and transpose their ranks.\n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\n\nReturns\n\nW: The reversed tensor train of type TT with transposed ranks.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.permutedims!","page":"Home","title":"Base.permutedims!","text":"permutedims!(U::TT{T,N}, τ::Permutation)\n\nPermute the mode dimensions of each factor in the tensor train U in place.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nτ::Permutation: Permutation representing the new ordering of mode dimensions.\n\nReturns\n\nTT{T,N}: The tensor train U with permuted dimensions.\n\nThrows\n\nArgumentError: If the decomposition exhibits zero mode dimensions.\nArgumentError: If τ is not a valid permutation of the mode dimensions of U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.fill!","page":"Home","title":"Base.fill!","text":"fill!(U::TT{T,N}, v::T)\n\nFill each factor contained in the tensor train U with the value v in place.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nv::T: Value to fill each factor with.\n\nReturns\n\nU: Tensor train of type TT with each factor filled with value v.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Random.rand!","page":"Home","title":"Random.rand!","text":"rand!(rng::AbstractRNG, U::TT{T,N})\n\nFill each factor in the tensor train U in place with random values using the provided random number generator rng.\n\nArguments\n\nrng::AbstractRNG: Random number generator to utilize for generating random values.\nU::TT{T,N}: Tensor train of type TT, whose factors are to be filled with random numbers.\n\nReturns\n\nU: Tensor train of type TT with each factor filled with random values.\n\n\n\n\n\nrand!(U::TT{T,N}) where {T<:Number,N}\n\nFill each factor in the tensor train U with random values in place, using the default global random number generator (Random.GLOBAL_RNG).\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT, whose factors are to be filled with random values.\n\nReturns\n\nU: Tensor train of type TT with random values filled in its factors.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.getfirstfactor","page":"Home","title":"TensorRefinement.TensorTrain.getfirstfactor","text":"getfirstfactor(U::TT{T,N}) where {T<:Number,N}\n\nRetrieve the first factor of the tensor train U.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT, where T is the element type and N is the number of dimensions.\n\nReturns\n\nThe first factor in the tensor train U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.getlastfactor","page":"Home","title":"TensorRefinement.TensorTrain.getlastfactor","text":"getlastfactor(U::TT{T,N}) where {T<:Number,N}\n\nRetrieve the last factor of the tensor train U.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT, where T is the element type and N is the number of dimensions.\n\nReturns\n\nThe last factor in the tensor train U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.getfactor","page":"Home","title":"TensorRefinement.TensorTrain.getfactor","text":"getfactor(U::TT{T,N}, ℓ::Int)\n\nReturn the factor at position ℓ in the tensor train U.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nℓ::Int: Index of the factor to retrieve.\n\nReturns\n\nFactor{T,N}: The factor at the specified index ℓ of the tensor train.\n\nThrows\n\nArgumentError: If ℓ is out of valid range.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.setfirstfactor!","page":"Home","title":"TensorRefinement.TensorTrain.setfirstfactor!","text":"setfirstfactor!(U::TT{T,N}, F::Array{T,N})\n\nSet the first factor of the tensor train U to F in place.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nF::Array{T,N}: New factor to replace the current first factor with.\n\nReturns\n\nTT{T,N}: Modified tensor train U with the first factor set to F.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.setlastfactor!","page":"Home","title":"TensorRefinement.TensorTrain.setlastfactor!","text":"setlastfactor!(U::TT{T,N}, F::Array{T,N})\n\nSet the last factor of the tensor train U to F in place.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nF::Array{T,N}: New factor to replace the current last factor with.\n\nReturns\n\nTT{T,N}: Modified tensor train U with the last factor set to F.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.setfactor!","page":"Home","title":"TensorRefinement.TensorTrain.setfactor!","text":"setfactor!(U::TT{T,N}, F::Array{T,N}, ℓ::Int)\n\nSet the factor at position ℓ in the tensor train U to F in place.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nF::Array{T,N}: New factor to replace the current factor at index ℓ with.\nℓ::Int: The index of the factor to set.\n\nReturns\n\nTT{T,N}: Modified tensor train U with the factor at index ℓ set to F.\n\nThrows\n\nArgumentError: If ℓ is out of valid range.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.rankselect!","page":"Home","title":"TensorRefinement.TensorTrain.rankselect!","text":"rankselect!(U::TT{T,N}, α::Indices, β::Indices)\n\nSelect the first rank dimensions of the first factor and the last rank dimensions of the last factor in the tensor train U based on the provided indices α and β, modifying U in place.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nα::Indices: Reference numbers for selecting the first rank dimensions of the first factor of U.\nβ::Indices: Reference numbers for selecting the last rank dimensions of the last factor of U.\n\nReturns\n\nU: Tensor train type TT, with the selected ranks. \n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the tensor train is empty, or if α or β contain invalid or empty ranges.\n\nExtended Error list:\n\nArgumentError: If the range for the first rank is empty.\nArgumentError: If the range for the first rank is incorrect.\nArgumentError: If the range for the second rank is empty.\nArgumentError: If the range for the second rank is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.rankselect","page":"Home","title":"TensorRefinement.TensorTrain.rankselect","text":"rankselect(U::TT{T,N}, α::Indices, β::Indices)\n\nCreate a new tensor train object by selecting the first rank dimensions of the first factor and the last rank dimensions of the last factor in the tensor train U based on the provided indices α and β.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nα::Indices: Reference numbers for selecting the first rank dimensions of the first factor of U.\nβ::Indices: Reference numbers for selecting the last rank dimensions of the last factor of U.\n\nReturns\n\nV: New tensor train object, with the selected ranks.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decomposition is empty, or if α or β contain invalid or empty ranges.\n\nExtended Error list:\n\nArgumentError: If the range for the first rank is empty.\nArgumentError: If the range for the first rank is incorrect.\nArgumentError: If the range for the second rank is empty.\nArgumentError: If the range for the second rank is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.getindex","page":"Home","title":"Base.getindex","text":"getindex(U::TT{T,N}, α::Indices, β::Indices) where {T<:Number,N}\n\nCreate a new tensor train object by selecting the first rank dimensions of the first factor and the last rank dimensions of the last factor in the tensor train U based on the provided indices α and β. Function acts as an alias for rankselect.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nα::Indices: Reference numbers for selecting the first rank dimensions of the first factor of U.\nβ::Indices: Reference numbers for selecting the last rank dimensions of the last factor of U.\n\nReturns\n\nV: New tensor train object, with the selected ranks.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the decomposition is empty, or if α or β contain invalid or empty ranges.\n\nExtended Error list:\n\nArgumentError: If the range for the first rank is empty.\nArgumentError: If the range for the first rank is incorrect.\nArgumentError: If the range for the second rank is empty.\nArgumentError: If the range for the second rank is incorrect.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.append!","page":"Home","title":"Base.append!","text":"append!(U::TT{T,N}, V::TT{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number,N}\n\nAppend the tensor train type V to the end of the tensor train type U in place. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\nU::TT{T,N}: Target tensor train of type TT to which V will be appended.\nV::TT{T,N}: Tensor Train of type TT, which to append to U.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U and V before appending.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the combined result after appending.\n\nReturns\n\nU: Modified tensor train type U after appending V.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V are inconsistent in the number of dimensions.\nArgumentError:If the factors of U have incorrect or inconsistent ranks.\nArgumentError: If the factors of V have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.prepend!","page":"Home","title":"Base.prepend!","text":"prepend!(U::TT{T,N}, V::TT{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number,N}\n\nPrepend the tensor train type V to the beginnning of the tensor train type U in place. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\nU::TT{T,N}: Target tensor train of type TT, to which V will be prepended.\nV::TT{T,N}: Tensor train of type TT, which to append to U.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U and V before prepending.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the combined result after prepending.\n\nReturns\n\nU: Modified tensor train type U after prepending V.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions.\nArgumentError: If the factors of U have incorrect or inconsistent ranks.\nArgumentError: If the factors of V have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.push!","page":"Home","title":"Base.push!","text":"push!(U::TT{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number,N}\n\nPush a factor V to the end of the tensor train type U in place. Optionally, the ranks before and after the operation are checked.\n\nArguments\n\nU::TT{T,N}: Target tensor train of type TT, to which the factor V will be pushed.\nV::Factor{T,N}: The factor to push to the tensor train type U.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U before pushing.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the result after pushing.\n\nReturns\n\nU: Modified tensor train type U after pushing V.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if their ranks (in case of U, the ranks of its factors) are inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions.\nArgumentError: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.pushfirst!","page":"Home","title":"Base.pushfirst!","text":"pushfirst!(U::TT{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number,N}\n\nPush a factor V to the beginning of the tensor train type U in place. Optionally, the ranks before and after the operation are checked.\n\nArguments\n\nU::TT{T,N}: Target tensor train of type TT, to which the factor V will be pushed at the beginning.\nV::Factor{T,N}: The factor to push to the beginning of U.\nrankprecheck::Bool=true: If true (by default), the ranks of U are checked before pushing.\nrankpostcheck::Bool=true: If true (by default), the ranks of the result are checked after pushing.\n\nReturns\n\nU: Modified tensor train type U after pushing V at the beginning.\n\nThrows\n\nSummarized Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions, or if their ranks (in case of U, the ranks of its factors) are inconsistent with the operation.\n\nExtended Error list:\n\nDimensionMismatch: If U and V have different numbers of dimensions.\nDimensionMismatch: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.pop!","page":"Home","title":"Base.pop!","text":"pop!(U::TT{T,N}) where {T<:Number,N}\n\nPop the last factor from the tensor train type U and return it.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT, from which to pop the last factor.\n\nReturns\n\nV: The last factor that was removed from U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.popfirst!","page":"Home","title":"Base.popfirst!","text":"popfirst!(U::TT{T,N}) where {T<:Number,N}\n\nPop the first factor from the tensor train type U and return it.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT, from which to pop the first factor.\n\nReturns\n\nV: The first factor that was removed from U.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.insert!","page":"Home","title":"Base.insert!","text":"insert!(U::TT{T,N}, ℓ::Int, V::Factor{T,N}; path::String=\"\", rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number,N}\n\nInsert a factor V into the tensor train type U at the specified index ℓ. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\n(U::TT{T,N}: Tensor train of type TT, in which to insert the factor V.\nℓ::Int: The index at which to insert the factor V.\nV::Factor{T,N}: The factor to insert into the decomposition U.\npath::String=\"\": The path direction for insertion; should be \"forward\" or \"backward\".\nrankprecheck::Bool=true: If true (by default), checks the ranks of U before insertion.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the result after insertion.\n\nReturns\n\nU: Modified tensor train type U after inserting V.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If path is not \"forward\" or \"backward\".\nDimensionMismatch: If ℓ is out of range or if the ranks (of U, V or the factors of U) are inconsistent for the operation.\n\nExtended Error list:\n\nArgumentError:  If path is neither \"forward\" nor \"backward\"\nArgumentError: If ℓ is not from 1:L, where L is the number of factors in U.\nDimensionMismatch: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U and V are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.deleteat!","page":"Home","title":"Base.deleteat!","text":"deleteat!(U::TT{T,N}, Λ::Path; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T<:Number,N}\n\nDelete factors from the tensor train type U at the specified indices Λ in place. Optionally, the ranks are checked before and after the operation.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT, from which factors will be deleted.\nΛ::Path: Indices of factors to delete. Can be a single integer, a vector of integers, or a tuple of integers.\nrankprecheck::Bool=true: If true (by default), checks the ranks of U before deletion.\nrankpostcheck::Bool=true: If true (by default), checks the ranks of the result after deletion.\n\nReturns\n\nU: Modified tensor train type U after deleting the specified factors.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If the entries of Λ are not unique or are not within the valid range.\nDimensionMismatch: If the ranks of U are inconsistent for this operation.\n\nExtended Error list:\n\nArgumentError:  If the entries of Λ are not unique.\nArgumentError: If Λ is not an element or a subset of 1:L with unique entries, where L is the number of factors in U.\nDimensionMismatch: If the factors of U have incorrect or inconsistent ranks.\nDimensionMismatch: If the ranks of U are inconsistent for this operation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.compose!","page":"Home","title":"TensorRefinement.TensorTrain.compose!","text":"compose!(W::TT{T,N}, Λ::Path; path::String=\"\", major::String=\"last\")\n\nContract the factors of the tensor train W along the path specified by Λ, modifying W in place.\n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\nΛ::Path: Indices along which to perform contractions. Can be a Colon to select all factors or a vector of integers.\npath::String=\"\": Direction of contraction, either \"forward\" or \"backward\". Defaults to \"\", which deduces the path from Λ.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\".\n\nReturns\n\nW: Modified tensor train W with factors contracted along the specified path.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If Λ has duplicate entries, is out of the valid range, or if path or major are set to invalid values.\n\nExtended Error list:\n\nArgumentError: If path is none of the following: \"\",  \"forward\" or \"backward\".\nArgumentError: If major is none of the following: \"last\" (default) or \"first\".\nArgumentError: If path is neither \"forward\" nor \"backward\", when Λ is neither empty nor a colon.\nArgumentError: If Λ has duplicate entries.\nArgumentError: If non-empty Λ is neither a colon nor a Vector/NTuple/UnitRange of Int (from 1:L-1 for path=\"forward\" and from 2:L for path=\"backward\", where L is the number of factors in W)\n\n\n\n\n\ncompose!(W::TT{T,N}; path::String=\"\", major::String=\"last\") where {T<:Number,N}\n\nContract all factors of the tensor train W in place along the specified path.\n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\npath::String=\"\": Direction of contraction.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\".\n\nReturns\n\nW: The modified tensor train after performing the contraction of all factors along the specified path.\n\nThrows\n\nArgumentError: If path is none of the following: \"\",  \"forward\" or \"backward\".\nArgumentError: If major is none of the following: \"last\" (default) or \"first\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.compose","page":"Home","title":"TensorRefinement.TensorTrain.compose","text":"compose(W::TT{T,N}, Λ::Path; path::String=\"\", major::String=\"last\")\n\nCreate a new tensor train that is a deepcopy of W, with the factors along the path specified by Λ contracted.\n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\nΛ::Path: Indices along which to perform contractions. Can be a Colon to select all factors or a vector of integers.\npath::String=\"\": Direction of contraction, either \"forward\" or \"backward\". Defaults to \"\", which deduces the path from Λ.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\".\n\nReturns\n\nU: New tensor train object of type TT, obtained by contracting a deepcopy of W along the specified path.\n\nThrows\n\nSummarized Error list:\n\nArgumentError: If Λ has duplicate entries, is out of the valid range, or if path or major are set to invalid values.\n\nExtended Error list:\n\nArgumentError: If path is none of the following: \"\",  \"forward\" or \"backward\".\nArgumentError: If major is none of the following: \"last\" (default) or \"first\".\nArgumentError: If path is neither \"forward\" nor \"backward\", when Λ is neither empty nor a colon.\nArgumentError: If Λ has duplicate entries.\nArgumentError: If non-empty Λ is neither a colon nor a Vector/NTuple/UnitRange of Int (from 1:L-1 for path=\"forward\" and from 2:L for path=\"backward\", where L is the number of factors in W)\n\n\n\n\n\ncompose(W::TT{T,N}; path::String=\"\", major::String=\"last\") where {T<:Number,N}\n\nContract all the factors of the tensor train W along the specified path and return a new tensor train.\n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\npath::String=\"\": Direction of contraction.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\".\n\nReturns\n\nA new tensor train with all the factors contracted along the specified path.\n\nThrows\n\nArgumentError: If path is none of the following: \"\",  \"forward\" or \"backward\".\nArgumentError: If major is none of the following: \"last\" (default) or \"first\".\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.composecore!","page":"Home","title":"TensorRefinement.TensorTrain.composecore!","text":"composecore!(U::TT{T,N}; major::String=\"last\")\n\nContract all factors of the tensor train U in place and return the resulting tensor.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\". Defaults to \"last\".\n\nReturns\n\nFactor{T,N}: Final tensor obtained by contracting all the factors of U.\n\nThrows\n\nArgumentError: If major is set to a value different from \"last\" (default) or \"first\"\".\nArgumentError: If the decomposition is empty.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.composecore","page":"Home","title":"TensorRefinement.TensorTrain.composecore","text":"composecore(W::TT{T,N}; major::String=\"last\")\n\nCompute the tensor of a tensor train W, which results from contracting all its factors.\n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\". Defaults to \"last\".\n\nReturns\n\nFactor{T,N}: Final tensor obtained by contracting all the factors of W.\n\nThrows\n\nArgumentError: If major is set to a value different from \"last\" (default) or \"first\"\".\nArgumentError: If the decomposition is empty.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.composeblock!","page":"Home","title":"TensorRefinement.TensorTrain.composeblock!","text":"composeblock!(U::TT{T,N}, α::Int, β::Int; major::String=\"last\")\n\nContract the factors of the tensor train U after having selected the first and last rank of the tensor train via indices α and β, modifying U in place.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nα::Int: Index for the first rank of the block.\nβ::Int: Index for the second rank of the block.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\". Defaults to \"last\".\n\nReturns\n\nFactor{T,N}: Final tensor after contracting the factors of U exhibiting the selected first and last rank.\n\nThrows\n\nArgumentError: If α or β are out of range.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.composeblock","page":"Home","title":"TensorRefinement.TensorTrain.composeblock","text":"composeblock(U::TT{T,N}, α::Int, β::Int; major::String=\"last\")\n\nCreate a new tensor obtained by contracting the factors of a deep copy of the tensor train U after having selected the first and last rank of the tensor train via indices α and β.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nα::Int: Index for the first rank of the block.\nβ::Int: Index for the second rank of the block.\nmajor::String=\"last\": The major ordering of dimensions for the contraction. Either \"first\" or \"last\". Defaults to \"last\".\n\nReturns\n\nFactor{T,N}: Final tensor after contracting the factors of the deepcopy of U exhibiting the selected first and last rank.\n\nThrows\n\nArgumentError: If α or β are out of range.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.vcat","page":"Home","title":"Base.vcat","text":"vcat(U::TT{T,N}, V::TT{T,N}, W::Vararg{TT{T,N},M})\n\nVertically concatenate the given tensor trains U, V and any additional tensor trains W..., to form a new tensor train Z.\n\nArguments\n\nU::TT{T,N}: First tensor train of type TT.\nV::TT{T,N}: Second tensor train of type TT.\nW::Vararg{TT{T,N},M}: Additional tensor trains to include in the concatenation.\n\nReturns\n\nTT{T,N}: New tensor train Z that is the vertical concatenation of U, V, and any additional tensor trains.\n\nThrows\n\nArgumentError: If the number of factors, mode size, or ranks of the tensor trains are incompatible.\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\nArgumentError: If the decompositions are incompatible in the last rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.hcat","page":"Home","title":"Base.hcat","text":"hcat(U::TT{T,N}, V::TT{T,N}, W::Vararg{TT{T,N},M})\n\nHorizontally concatenate the given tensor trains U, V and any additional tensor trains W..., to form a new tensor train Z.\n\nArguments\n\nU::TT{T,N}: First tensor train of type TT.\nV::TT{T,N}: Second tensor train of type TT.\nW::Vararg{TT{T,N},M}: Additional tensor trains to concatenate.\n\nReturns\n\nTT{T,N}: New tensor train Z that is the horizontal concatenation of U, V, and any additional tensor trains.\n\nThrows\n\nArgumentError: If the number of factors, mode size, or ranks of the tensor trains are incompatible.\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\nArgumentError: If the decompositions are incompatible in the first rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.dcat","page":"Home","title":"TensorRefinement.TensorTrain.dcat","text":"dcat(U::TT{T,N}, V::TT{T,N}, W::Vararg{TT{T,N},M})\n\nDiagonally concatenate the given tensor trains U, V and any additional tensor trains W..., to form a new tensor train Z.\n\nArguments\n\nU::TT{T,N}: First tensor train of type TT.\nV::TT{T,N}: Second tensor train of type TT.\nW::Vararg{TT{T,N},M}: Additional tensor trains to concatenate.\n\nReturns\n\nTT{T,N}: New tensor train Z that is the diagonal concatenation of U, V and any additional tensor trains.\n\nThrows\n\nArgumentError: If the decompositions are incompatible in the number of factors.\nArgumentError: If the decompositions are incompatible in mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#LinearAlgebra.lmul!","page":"Home","title":"LinearAlgebra.lmul!","text":"lmul!(α::T, U::TT{T,N})\n\nScale the tensor train U in place by multiplying its last factor by a value α.\n\nArguments\n\nα::T: Value of type T to multiply with.\nU::TT{T,N}: Tensor train of type TT.\n\nReturns\n\nTT{T,N}: Modified tensor train U after scaling its last factor by α.\n\n\n\n\n\n","category":"function"},{"location":"index.html#LinearAlgebra.rmul!","page":"Home","title":"LinearAlgebra.rmul!","text":"rmul!(U::TT{T,N}, α::T) where {T<:Number,N}\n\nScale the tensor train U in place by multiplying its last factor by a value α. Function acts as a wrapper around lmul! to allow for the arguments' order to be changed.\n\nArguments\n\nα::T: Value of type T to multiply with.\nU::TT{T,N}: Tensor train of type TT.\n\nReturns\n\nTT{T,N}: Modified tensor train U after scaling its last factor by α.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.mul","page":"Home","title":"TensorRefinement.TensorTrain.mul","text":"mul(U₁::TT{T,N₁}, σ₁::Indices, U₂::TT{T,N₂}, σ₂::Indices)\n\nMultiply two tensor trains U₁ and U₂ along the specified sets of modes σ₁ and σ₂, respectively, and return a new tensor train.\n\nArguments\n\nU₁::TT{T,N₁}: First tensor train of type TT.\nσ₁::Indices: Indices of modes for the first tensor train to be contracted along.\nU₂::TT{T,N₂}: Second tensor train of type TT.\nσ₂::Indices: Indices of modes for the second tensor train to be contracted along.\n\nReturns\n\nTT{T,N}: New tensor train obtaied by the multiplication of U₁ and U₂ along the specified modes.\n\nThrows\n\nArgumentError: If U₁ and U₂ differ in the number of factors.\nArgumentError: If σ₁ is passed as a vector, and it is not a vector of type Vector{Int} or an empty vector of type Vector{Any}.\nArgumentError: If σ₂ is passed as a vector, and it is not a vector of type Vector{Int} or an empty vector of type Vector{Any}.\nArgumentError: If the specified sets of modes of σ₁ and σ₂ are inconsistent.\nArgumentError: If the set of modes of U₁ is specified incorrectly.\nArgumentError: If the set of modes of U₂ is specified incorrectly.\nArgumentError: If U₁ and U₂ are inconsistent with respect to the specified modes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.had","page":"Home","title":"TensorRefinement.TensorTrain.had","text":"had(U::TT{T,N}, V::TT{T,N})\n\nPerform the Hadamard product of two tensor trains U and V, and yield the new tensor train.\n\nArguments\n\nU::TT{T,N}: First tensor train of type TT.\nV::TT{T,N}: Second tensor train of type TT.\n\nReturns\n\nTT{T,N}: New tensor train obtained by the element-wise multiplication of the factors of tensor trains U and V.\n\nThrows\n\nArgumentError: If U and V differ in the number of factors.\nArgumentError: If U and V are inconsistent in mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.:*","page":"Home","title":"Base.:*","text":"*(α::T, U::TT{T,N})\n\nCreate a new tensor train by multiplying the last factor of the deepcopy of U by a value α.\n\nArguments\n\nα::T: Value of type T to multiply with.\nU::TT{T,N}: Tensor train of type TT.\n\nReturns\n\nTT{T,N}: New tensor train V that is a deepcopy of U with its last factor scaled by α.\n\n\n\n\n\n*(U::TT{T,N}, α::T) where {T<:Number,N}\n\nCreate a new tensor train by multiplying the last factor of the deepcopy of U by a value α. Function acts as a wrapper around the default function * to allow for the arguments' order to be interchanged.\n\nArguments\n\nU::TT{T,N}: Tensor train of type TT.\nα::T: Value of type T to multiply with.\n\nReturns\n\nTT{T,N}: New tensor train V that is a deepcopy of U with its last factor scaled by α.\n\n\n\n\n\n*(U::TT{T,N}, V::TT{T,N}) where {T<:Number,N}\n\nPerform the Hadamard product of two tensor trains U and V, and yield the new tensor train. Funcion is an alias for had.\n\nArguments\n\nU::TT{T,N}: First tensor train of type TT.\nV::TT{T,N}: Second tensor train of type TT.\n\nReturns\n\nTT{T,N}: New tensor train obtained by the element-wise multiplication of the factors of tensor trains U and V.\n\nThrows\n\nArgumentError: If U and V differ in the number of factors.\nArgumentError: If U and V are inconsistent in mode size.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.kron","page":"Home","title":"Base.kron","text":"kron(U₁::Dec{T,N}, U₂::Dec{T,N})\n\nCompute the Kronecker product of two decompositions U₁ and U₂ of type Dec, and return the result as a new tensor train.\n\nArguments\n\nU₁::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors with elements of type T and with N as the number dimensions.\nU₂::Dec{T,N}: Second decomposition of type Dec, , which represents a vector of factors with elements of type T and with N as the number dimensions.\n\nReturns\n\nTT{T,N}: New tensor train of type TT obtained as the Kronecker product of U₁ and U₂.\n\nThrows\n\nArgumentError: If U₁ and U₂ differ in the number of factors. \nArgumentError: If U₁ and U₂ are inconsistent in the number of mode dimensions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.:⊗","page":"Home","title":"TensorRefinement.TensorTrain.:⊗","text":"⊗(U₁::Dec{T,N}, U₂::Dec{T,N})\n\nAn alias for kron. Compute the Kronecker product of two decompositions U₁ and U₂.\n\nArguments\n\nU₁::Dec{T,N}: First decomposition of type Dec, which represents a vector of factors with elements of type T and with N as the number dimensions.\nU₂::Dec{T,N}: Second decomposition of type Dec, , which represents a vector of factors with elements of type T and with N as the number dimensions.\n\nReturns\n\nTT{T,N}: New tensor train of type TT obtained as the Kronecker product of U₁ and U₂.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TensorRefinement.TensorTrain.add","page":"Home","title":"TensorRefinement.TensorTrain.add","text":"add(U::TT{T,N}, V::TT{T,N})\n\nAdd two tensor trains U and V and return a new tensor train object that represents their sum.\n\nArguments\n\nU::TT{T,N}: First tensor train of type TT.\nV::TT{T,N}: Second tensor train of type TT.\n\nReturns\n\nTT{T,N}: New tensor train W obtained as the sum of U and V.\n\nThrows\n\nArgumentError: If U and V differ in the number of factors.\nArgumentError: If U and V are inconsistent in mode size.\nArgumentError: If the decompositions are incompatible in the first rank.\nArgumentError: If the decompositions are incompatible in the last rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.:+","page":"Home","title":"Base.:+","text":"+(U::TT{T,N}, V::TT{T,N}) where {T<:Number,N}\n\nAdd two tensor trains U and V and return a new tensor train object that represents their sum. Function is an alias for add.\n\nArguments\n\nU::TT{T,N}: First tensor train of type TT.\nV::TT{T,N}: Second tensor train of type TT.\n\nReturns\n\nTT{T,N}: New tensor train W obtained as the sum of U and V.\n\nThrows\n\nArgumentError: If U and V differ in the number of factors.\nArgumentError: If U and V are inconsistent in mode size.\nArgumentError: If the decompositions are incompatible in the first rank.\nArgumentError: If the decompositions are incompatible in the last rank.\n\n\n\n\n\n","category":"function"},{"location":"index.html#LinearAlgebra.qr!","page":"Home","title":"LinearAlgebra.qr!","text":"qr!(W::TT{T,N}, Λ::Path; path::String=\"\") where {T<:FloatRC,N}\n\nPerform an in-place QR decomposition on the specified factors of the tensor train W. \n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\nΛ::Path: Path along which to perform the QR decomposition. Can be specified as a range, a vector of integers, or Colon.\npath::String=\"\": Specifies the direction of the decomposition. Can be \"forward\" for left-to-right decomposition, \"backward\" for right-to-left decomposition, or an empty string \"\" to automatically deduce the path based on Λ.\n\nReturns\n\nModified tensor train W after performing the QR decomposition along the specified path.\n\nThrows\n\nArgumentError: If the tensor train W is empty.\nArgumentError: If path is none of the following: \"forward\", \"backward\", or an empty string.\nArgumentError: If path cannot be deduced from Λ or path is not specified when Λ is a colon.\nArgumentError: If Λ has duplicate entries.\nArgumentError: If the entries of Λ do not form a set of contiguous integers.\nArgumentError: If Λ is out of the valid range 1:L where L is the length of the tensor train W.\nArgumentError: If Λ is neither sorted in ascending nor in descending order, leading to inconsitency with either \"forward\" or \"backward\" path.\nArgumentError: If Λ is not sorted in ascending order, rendering it inconsistent with any forward path.\nArgumentError: If Λ is not sorted in descending order, rendering it inconsistent with any backward path.\n\n\n\n\n\nqr!(W::TT{T,N}; path::String=\"\") where {T<:FloatRC,N}\n\nPerform an in-place QR decomposition on all the factors of the tensor train W.\n\nArguments\n\nW::TT{T,N}: Tensor train of type TT.\npath::String=\"\": Specifies the direction of the decomposition. Can be \"forward\" for left-to-right decomposition or \"backward\" for right-to-left decomposition.\n\nReturns\n\nModified tensor train W after performing the QR decomposition along the specified path.\n\nThrows\n\nArgumentError: If the tensor train W is empty.\nArgumentError: If path is not specified as \"forward\" or \"backward\" (Notice: Λ is a colon, thus path must be specified)\n\n\n\n\n\n","category":"function"},{"location":"index.html#LinearAlgebra.svd!","page":"Home","title":"LinearAlgebra.svd!","text":"svd!(W::TT{T,N}, Λ::Path, n::Union{Colon,DecSize}; path::String=\"\", aTol::Float2=0.0, aTolDistr::Float2=0.0, rTol::Float2=0.0, rTolDistr::Float2=0.0, maxrank::Int2=0, major::String=\"last\")\n\nPerform an in-place singular value decomposition (SVD) with specified path and tolerances on the tensor train W. Assume that the decomposition W is orthogonal.\n\nArguments\n\nW::TT{T,N}: Tensor train to be decomposed in-place.\nΛ::Path: Path along which to perform the SVD. Can be a colon (:) or a vector of integers.\nn::Union{Colon,DecSize}: Specifies target dimensions of the factors after decomposition. Can be a colon (:) or a size matrix.\npath::String: Specifies the direction of the decomposition. Accepts \"\" (default), \"forward\", or \"backward\".\naTol::Float2: Absolute tolerance for truncation. Can be a single float or a vector of floats.\naTolDistr::Float2: Absolute tolerance for distributed truncation. Can be a single float or a vector of floats.\nrTol::Float2: Relative tolerance for truncation. Can be a single float or a vector of floats.\nrTolDistr::Float2: Relative tolerance for distributed truncation. Can be a single float or a vector of floats.\nmaxrank::Int2: Maximum rank for truncation. Can be a single integer or a vector of integers.\nmajor::String: Specifies whether to prioritize the first or last indices during the operation. Acceptable values are \"last\" (default) or \"first\".\n\nReturns\n\nW::TT{T,N}: Modified tensor train after performing the in-place SVD.\nε::Vector{Float64}: Vector of absolute errors for each factor.\nδ::Vector{Float64}: Vector of relative errors for each factor.\nμ::Float64: Norm of the core tensor after the decomposition.\nρ::Vector{Int}: Vector of ranks for each factor.\nσ::Vector{Vector{Float64}}: Vector of singular values for each factor.\n\nThrows\n\nSummarized Error List:\n\nArgumentError: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.\n\nExtended Error List:\n\nArgumentError: If the decomposition is empty.\nArgumentError: If path is none of the following: \"\" (default, accepted only when path can be deduced from Λ), \"forward\" or \"backward\"\".\nArgumentError: If path cannot be deduced from Λ or is the path is neither \"forward\" nor \"backward\" when Λ is a colon.\nArgumentError: If the entries of Λ should form a set of contiguous integers\")\nArgumentError: If Λ is out of range.\nArgumentError: If Λ is not sorted in ascending or descending order, rendering it inconsistent with any forward or backward path.\nArgumentError: If Λ is not sorted in ascending order, rendering it inconsistent with any forward path.\nArgumentError: If Λ is not sorted in descending order, rendering it inconsistent with any backward path.\nArgumentError: If the number of rows in n is not equal to the number of dimensions in each factor of W.\nArgumentError: If the number of columns in n is not equal to the number of elements in Λ.\nArgumentError: If n and Λ are incompatible with the size of the factors of W.\nArgumentError: If aTol is not a nonnegative Float64 or a vector of such.\nArgumentError: If aTol, passed as a vector, has incorrect length.\nArgumentError: If aTolDistr is not a nonnegative Float64 or a vector of such.\nArgumentError: If aTolDistr, passed as a vector, has incorrect length.\nArgumentError: If rTol is not a nonnegative Float64 or a vector of such.\nArgumentError: If rTol, passed as a vector, has incorrect length.\nArgumentError: If rTolDistr is not a nonnegative Float64 or a vector of such.\nArgumentError: If rTolDistr, passed as a vector, has incorrect length.\nArgumentError: If maxrank is not a nonnegative Int or a vector of such.\nArgumentError: If maxrank, passed as a vector, has incorrect length.\nArgumentError: If major is neither \"last\" (default) nor \"first\"\".\n\n\n\n\n\nsvd!(W::TT{T,N}, Λ::Path, n::Union{Colon,DecSize}; path::String=\"\", aTol::Float2=0.0, aTolDistr::Float2=0.0, rTol::Float2=0.0, rTolDistr::Float2=0.0, maxrank::Int2=0, major::String=\"last\")\n\nPerform an in-place singular value decomposition (SVD) of the in Λ specified factors with automatically deduced target dimensions of the factors. Consider specified path and tolerances on the tensor train W. Assume that the decomposition W is orthogonal.\n\nArguments\n\nW::TT{T,N}: Tensor train to be decomposed in-place.\nΛ::Path: Path along which to perform the SVD. Can be a colon (:) or a vector of integers.\npath::String: Specifies the direction of the decomposition. Accepts \"\" (default), \"forward\", or \"backward\".\naTol::Float2: Absolute tolerance for truncation. Can be a single float or a vector of floats.\naTolDistr::Float2: Absolute tolerance for distributed truncation. Can be a single float or a vector of floats.\nrTol::Float2: Relative tolerance for truncation. Can be a single float or a vector of floats.\nrTolDistr::Float2: Relative tolerance for distributed truncation. Can be a single float or a vector of floats.\nmaxrank::Int2: Maximum rank for truncation. Can be a single integer or a vector of integers.\nmajor::String: Specifies whether to prioritize the first or last indices during the operation. Acceptable values are \"last\" (default) or \"first\".\n\nReturns\n\nW::TT{T,N}: Modified tensor train after performing the in-place SVD.\nε::Vector{Float64}: Vector of absolute errors for each factor.\nδ::Vector{Float64}: Vector of relative errors for each factor.\nμ::Float64: Norm of the core tensor after the decomposition.\nρ::Vector{Int}: Vector of ranks for each factor.\nσ::Vector{Vector{Float64}}: Vector of singular values for each factor.\n\nThrows\n\nArgumentError: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.\nFor full error control, see default svd!.\n\n\n\n\n\nsvd!(W::TT{T,N}, Λ::Path, n::Union{Colon,DecSize}; path::String=\"\", aTol::Float2=0.0, aTolDistr::Float2=0.0, rTol::Float2=0.0, rTolDistr::Float2=0.0, maxrank::Int2=0, major::String=\"last\")\n\nPerform an in-place singular value decomposition (SVD) of all factors with automatically deduced target dimensions of the factors. Consider specified path and tolerances on the tensor train W. Assume that the decomposition W is orthogonal.\n\nArguments\n\nW::TT{T,N}: Tensor train to be decomposed in-place.\npath::String: Specifies the direction of the decomposition. Accepts \"\" (default), \"forward\", or \"backward\".\naTol::Float2: Absolute tolerance for truncation. Can be a single float or a vector of floats.\naTolDistr::Float2: Absolute tolerance for distributed truncation. Can be a single float or a vector of floats.\nrTol::Float2: Relative tolerance for truncation. Can be a single float or a vector of floats.\nrTolDistr::Float2: Relative tolerance for distributed truncation. Can be a single float or a vector of floats.\nmaxrank::Int2: Maximum rank for truncation. Can be a single integer or a vector of integers.\nmajor::String: Specifies whether to prioritize the first or last indices during the operation. Acceptable values are \"last\" (default) or \"first\".\n\nReturns\n\nW::TT{T,N}: Modified tensor train after performing the in-place SVD.\nε::Vector{Float64}: Vector of absolute errors for each factor.\nδ::Vector{Float64}: Vector of relative errors for each factor.\nμ::Float64: Norm of the core tensor after the decomposition.\nρ::Vector{Int}: Vector of ranks for each factor.\nσ::Vector{Vector{Float64}}: Vector of singular values for each factor.\n\nThrows\n\nArgumentError: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.\nFor full error control, see default svd!.\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"Modules = [TensorRefinement]\nOrder = [:function, :type]\nPrivate = true","category":"page"}]
}
