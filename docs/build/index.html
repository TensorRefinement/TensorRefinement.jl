<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TensorRefinement.jl</title><meta name="title" content="Home · TensorRefinement.jl"/><meta property="og:title" content="Home · TensorRefinement.jl"/><meta property="twitter:title" content="Home · TensorRefinement.jl"/><meta name="description" content="Documentation for TensorRefinement.jl."/><meta property="og:description" content="Documentation for TensorRefinement.jl."/><meta property="twitter:description" content="Documentation for TensorRefinement.jl."/><meta property="og:url" content="https://TensorRefinement.github.io/TensorRefinement.jl/index.html"/><meta property="twitter:url" content="https://TensorRefinement.github.io/TensorRefinement.jl/index.html"/><link rel="canonical" href="https://TensorRefinement.github.io/TensorRefinement.jl/index.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">TensorRefinement.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Auxiliary"><span>Auxiliary</span></a></li><li class="toplevel"><a class="tocitem" href="#Chebyshev"><span>Chebyshev</span></a></li><li class="toplevel"><a class="tocitem" href="#Exponential"><span>Exponential</span></a></li><li class="toplevel"><a class="tocitem" href="#FEM"><span>FEM</span></a></li><li class="toplevel"><a class="tocitem" href="#Legendre"><span>Legendre</span></a></li><li class="toplevel"><a class="tocitem" href="#TensorTrainFactor"><span>TensorTrainFactor</span></a></li><li class="toplevel"><a class="tocitem" href="#TensorTrainFactorization"><span>TensorTrainFactorization</span></a></li><li class="toplevel"><a class="tocitem" href="#TT"><span>TT</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/master/docs/src/index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TensorRefinement"><a class="docs-heading-anchor" href="#TensorRefinement">TensorRefinement</a><a id="TensorRefinement-1"></a><a class="docs-heading-anchor-permalink" href="#TensorRefinement" title="Permalink"></a></h1><p>Welcome to the documentation for TensorRefinement.jl. Below you will find the index followed by the different sections of the package:</p><ul><li><a href="index.html#TensorRefinement.Auxiliary.Float2"><code>TensorRefinement.Auxiliary.Float2</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.Float3"><code>TensorRefinement.Auxiliary.Float3</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.FloatRC"><code>TensorRefinement.Auxiliary.FloatRC</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.Indices"><code>TensorRefinement.Auxiliary.Indices</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.Int2"><code>TensorRefinement.Auxiliary.Int2</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.Int3"><code>TensorRefinement.Auxiliary.Int3</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.Dec"><code>TensorRefinement.TensorTrain.Dec</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.DecRank"><code>TensorRefinement.TensorTrain.DecRank</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.DecSize"><code>TensorRefinement.TensorTrain.DecSize</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.Factor"><code>TensorRefinement.TensorTrain.Factor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.FactorSize"><code>TensorRefinement.TensorTrain.FactorSize</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.MatrixDec"><code>TensorRefinement.TensorTrain.MatrixDec</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.MatrixFactor"><code>TensorRefinement.TensorTrain.MatrixFactor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.TT"><code>TensorRefinement.TensorTrain.TT</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.VectorDec"><code>TensorRefinement.TensorTrain.VectorDec</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.VectorFactor"><code>TensorRefinement.TensorTrain.VectorFactor</code></a></li><li><a href="index.html#Base.:*"><code>Base.:*</code></a></li><li><a href="index.html#Base.:+"><code>Base.:+</code></a></li><li><a href="index.html#Base.append!"><code>Base.append!</code></a></li><li><a href="index.html#Base.deepcopy"><code>Base.deepcopy</code></a></li><li><a href="index.html#Base.deleteat!"><code>Base.deleteat!</code></a></li><li><a href="index.html#Base.fill!"><code>Base.fill!</code></a></li><li><a href="index.html#Base.getindex"><code>Base.getindex</code></a></li><li><a href="index.html#Base.hcat"><code>Base.hcat</code></a></li><li><a href="index.html#Base.insert!"><code>Base.insert!</code></a></li><li><a href="index.html#Base.kron"><code>Base.kron</code></a></li><li><a href="index.html#Base.length"><code>Base.length</code></a></li><li><a href="index.html#Base.ndims"><code>Base.ndims</code></a></li><li><a href="index.html#Base.permutedims!"><code>Base.permutedims!</code></a></li><li><a href="index.html#Base.pop!"><code>Base.pop!</code></a></li><li><a href="index.html#Base.popfirst!"><code>Base.popfirst!</code></a></li><li><a href="index.html#Base.prepend!"><code>Base.prepend!</code></a></li><li><a href="index.html#Base.push!"><code>Base.push!</code></a></li><li><a href="index.html#Base.pushfirst!"><code>Base.pushfirst!</code></a></li><li><a href="index.html#Base.reverse!"><code>Base.reverse!</code></a></li><li><a href="index.html#Base.size"><code>Base.size</code></a></li><li><a href="index.html#Base.vcat"><code>Base.vcat</code></a></li><li><a href="index.html#LinearAlgebra.lmul!"><code>LinearAlgebra.lmul!</code></a></li><li><a href="index.html#LinearAlgebra.qr!"><code>LinearAlgebra.qr!</code></a></li><li><a href="index.html#LinearAlgebra.rank"><code>LinearAlgebra.rank</code></a></li><li><a href="index.html#LinearAlgebra.rmul!"><code>LinearAlgebra.rmul!</code></a></li><li><a href="index.html#LinearAlgebra.svd!"><code>LinearAlgebra.svd!</code></a></li><li><a href="index.html#Random.rand!"><code>Random.rand!</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.compfloateps"><code>TensorRefinement.Auxiliary.compfloateps</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.indvec"><code>TensorRefinement.Auxiliary.indvec</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.lqaddrows"><code>TensorRefinement.Auxiliary.lqaddrows</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.modemul"><code>TensorRefinement.Auxiliary.modemul</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.qraddcols"><code>TensorRefinement.Auxiliary.qraddcols</code></a></li><li><a href="index.html#TensorRefinement.Auxiliary.threshold"><code>TensorRefinement.Auxiliary.threshold</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebdec"><code>TensorRefinement.Chebyshev.chebdec</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebdeceval!"><code>TensorRefinement.Chebyshev.chebdeceval!</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebdiff"><code>TensorRefinement.Chebyshev.chebdiff</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebeval"><code>TensorRefinement.Chebyshev.chebeval</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebexdiff"><code>TensorRefinement.Chebyshev.chebexdiff</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebexnodes"><code>TensorRefinement.Chebyshev.chebexnodes</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebextocheb"><code>TensorRefinement.Chebyshev.chebextocheb</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebextoleg"><code>TensorRefinement.Chebyshev.chebextoleg</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebextolegn"><code>TensorRefinement.Chebyshev.chebextolegn</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebref"><code>TensorRefinement.Chebyshev.chebref</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebrtnodes"><code>TensorRefinement.Chebyshev.chebrtnodes</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebrttocheb"><code>TensorRefinement.Chebyshev.chebrttocheb</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebrttoleg"><code>TensorRefinement.Chebyshev.chebrttoleg</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebrttolegn"><code>TensorRefinement.Chebyshev.chebrttolegn</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebtochebex"><code>TensorRefinement.Chebyshev.chebtochebex</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebtochebrt"><code>TensorRefinement.Chebyshev.chebtochebrt</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebtoleg"><code>TensorRefinement.Chebyshev.chebtoleg</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.chebtolegn"><code>TensorRefinement.Chebyshev.chebtolegn</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.legntocheb"><code>TensorRefinement.Chebyshev.legntocheb</code></a></li><li><a href="index.html#TensorRefinement.Chebyshev.legtocheb"><code>TensorRefinement.Chebyshev.legtocheb</code></a></li><li><a href="index.html#TensorRefinement.Exponential.cosdec"><code>TensorRefinement.Exponential.cosdec</code></a></li><li><a href="index.html#TensorRefinement.Exponential.cosfactor"><code>TensorRefinement.Exponential.cosfactor</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigdec"><code>TensorRefinement.Exponential.trigdec</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigdeceval!"><code>TensorRefinement.Exponential.trigdeceval!</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigdiff"><code>TensorRefinement.Exponential.trigdiff</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigdiffmask"><code>TensorRefinement.Exponential.trigdiffmask</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigeval"><code>TensorRefinement.Exponential.trigeval</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigevalmask"><code>TensorRefinement.Exponential.trigevalmask</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigrefmask"><code>TensorRefinement.Exponential.trigrefmask</code></a></li><li><a href="index.html#TensorRefinement.Exponential.trigrefmask2"><code>TensorRefinement.Exponential.trigrefmask2</code></a></li><li><a href="index.html#TensorRefinement.FEM.bpxdd"><code>TensorRefinement.FEM.bpxdd</code></a></li><li><a href="index.html#TensorRefinement.FEM.bpxdn"><code>TensorRefinement.FEM.bpxdn</code></a></li><li><a href="index.html#TensorRefinement.FEM.diffbpxdd"><code>TensorRefinement.FEM.diffbpxdd</code></a></li><li><a href="index.html#TensorRefinement.FEM.diffbpxdn"><code>TensorRefinement.FEM.diffbpxdn</code></a></li><li><a href="index.html#TensorRefinement.FEM.diffdd"><code>TensorRefinement.FEM.diffdd</code></a></li><li><a href="index.html#TensorRefinement.FEM.diffdn"><code>TensorRefinement.FEM.diffdn</code></a></li><li><a href="index.html#TensorRefinement.FEM.dint"><code>TensorRefinement.FEM.dint</code></a></li><li><a href="index.html#TensorRefinement.FEM.dintf"><code>TensorRefinement.FEM.dintf</code></a></li><li><a href="index.html#TensorRefinement.FEM.extdd"><code>TensorRefinement.FEM.extdd</code></a></li><li><a href="index.html#TensorRefinement.FEM.extdn"><code>TensorRefinement.FEM.extdn</code></a></li><li><a href="index.html#TensorRefinement.FEM.extmix"><code>TensorRefinement.FEM.extmix</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legdec"><code>TensorRefinement.Legendre.legdec</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legdeceval!"><code>TensorRefinement.Legendre.legdeceval!</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legdiff"><code>TensorRefinement.Legendre.legdiff</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legeval"><code>TensorRefinement.Legendre.legeval</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legndiff"><code>TensorRefinement.Legendre.legndiff</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legneval"><code>TensorRefinement.Legendre.legneval</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legnref"><code>TensorRefinement.Legendre.legnref</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legntoleg"><code>TensorRefinement.Legendre.legntoleg</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legref"><code>TensorRefinement.Legendre.legref</code></a></li><li><a href="index.html#TensorRefinement.Legendre.legtolegn"><code>TensorRefinement.Legendre.legtolegn</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.:⊗"><code>TensorRefinement.TensorTrain.:⊗</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.add"><code>TensorRefinement.TensorTrain.add</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.block"><code>TensorRefinement.TensorTrain.block</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.block!"><code>TensorRefinement.TensorTrain.block!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.checklength"><code>TensorRefinement.TensorTrain.checklength</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.checkndims"><code>TensorRefinement.TensorTrain.checkndims</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.checkrank"><code>TensorRefinement.TensorTrain.checkrank</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.checkranks"><code>TensorRefinement.TensorTrain.checkranks</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.checksize"><code>TensorRefinement.TensorTrain.checksize</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.compose"><code>TensorRefinement.TensorTrain.compose</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.compose!"><code>TensorRefinement.TensorTrain.compose!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.composeblock"><code>TensorRefinement.TensorTrain.composeblock</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.composeblock!"><code>TensorRefinement.TensorTrain.composeblock!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.composecore"><code>TensorRefinement.TensorTrain.composecore</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.composecore!"><code>TensorRefinement.TensorTrain.composecore!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.dcat"><code>TensorRefinement.TensorTrain.dcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.dec"><code>TensorRefinement.TensorTrain.dec</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.dec!"><code>TensorRefinement.TensorTrain.dec!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decadd"><code>TensorRefinement.TensorTrain.decadd</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decadd!"><code>TensorRefinement.TensorTrain.decadd!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decappend!"><code>TensorRefinement.TensorTrain.decappend!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decaxpby"><code>TensorRefinement.TensorTrain.decaxpby</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decaxpby!"><code>TensorRefinement.TensorTrain.decaxpby!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decdcat"><code>TensorRefinement.TensorTrain.decdcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decdeleteat!"><code>TensorRefinement.TensorTrain.decdeleteat!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decfill!"><code>TensorRefinement.TensorTrain.decfill!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.dechcat"><code>TensorRefinement.TensorTrain.dechcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.dechp"><code>TensorRefinement.TensorTrain.dechp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decinsert!"><code>TensorRefinement.TensorTrain.decinsert!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decinsertidentity!"><code>TensorRefinement.TensorTrain.decinsertidentity!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.deckp"><code>TensorRefinement.TensorTrain.deckp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.declength"><code>TensorRefinement.TensorTrain.declength</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decmodereshape"><code>TensorRefinement.TensorTrain.decmodereshape</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decmodetranspose!"><code>TensorRefinement.TensorTrain.decmodetranspose!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decmp"><code>TensorRefinement.TensorTrain.decmp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decndims"><code>TensorRefinement.TensorTrain.decndims</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decones"><code>TensorRefinement.TensorTrain.decones</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decpop!"><code>TensorRefinement.TensorTrain.decpop!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decpopfirst!"><code>TensorRefinement.TensorTrain.decpopfirst!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decprepend!"><code>TensorRefinement.TensorTrain.decprepend!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decpush!"><code>TensorRefinement.TensorTrain.decpush!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decpushfirst!"><code>TensorRefinement.TensorTrain.decpushfirst!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decqr!"><code>TensorRefinement.TensorTrain.decqr!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decrand"><code>TensorRefinement.TensorTrain.decrand</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decrand!"><code>TensorRefinement.TensorTrain.decrand!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decrank"><code>TensorRefinement.TensorTrain.decrank</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decranks"><code>TensorRefinement.TensorTrain.decranks</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decrankselect"><code>TensorRefinement.TensorTrain.decrankselect</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decrankselect!"><code>TensorRefinement.TensorTrain.decrankselect!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decreverse!"><code>TensorRefinement.TensorTrain.decreverse!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decscale!"><code>TensorRefinement.TensorTrain.decscale!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decsize"><code>TensorRefinement.TensorTrain.decsize</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decskp"><code>TensorRefinement.TensorTrain.decskp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decskp!"><code>TensorRefinement.TensorTrain.decskp!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decsvd!"><code>TensorRefinement.TensorTrain.decsvd!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.decvcat"><code>TensorRefinement.TensorTrain.decvcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.deczeros"><code>TensorRefinement.TensorTrain.deczeros</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factor"><code>TensorRefinement.TensorTrain.factor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factor!"><code>TensorRefinement.TensorTrain.factor!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorcontract"><code>TensorRefinement.TensorTrain.factorcontract</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factordcat"><code>TensorRefinement.TensorTrain.factordcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factordiagm"><code>TensorRefinement.TensorTrain.factordiagm</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorhcat"><code>TensorRefinement.TensorTrain.factorhcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorhp"><code>TensorRefinement.TensorTrain.factorhp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorkp"><code>TensorRefinement.TensorTrain.factorkp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorltcat"><code>TensorRefinement.TensorTrain.factorltcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormatrix"><code>TensorRefinement.TensorTrain.factormatrix</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormodereshape"><code>TensorRefinement.TensorTrain.factormodereshape</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormodetranspose"><code>TensorRefinement.TensorTrain.factormodetranspose</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormp"><code>TensorRefinement.TensorTrain.factormp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorndims"><code>TensorRefinement.TensorTrain.factorndims</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factornumentries"><code>TensorRefinement.TensorTrain.factornumentries</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorqr!"><code>TensorRefinement.TensorTrain.factorqr!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorqradd"><code>TensorRefinement.TensorTrain.factorqradd</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorranks"><code>TensorRefinement.TensorTrain.factorranks</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorrankselect"><code>TensorRefinement.TensorTrain.factorrankselect</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorranktranspose"><code>TensorRefinement.TensorTrain.factorranktranspose</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorsize"><code>TensorRefinement.TensorTrain.factorsize</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorstorage"><code>TensorRefinement.TensorTrain.factorstorage</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorsvd!"><code>TensorRefinement.TensorTrain.factorsvd!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorutcat"><code>TensorRefinement.TensorTrain.factorutcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorvcat"><code>TensorRefinement.TensorTrain.factorvcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.getfactor"><code>TensorRefinement.TensorTrain.getfactor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.getfirstfactor"><code>TensorRefinement.TensorTrain.getfirstfactor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.getlastfactor"><code>TensorRefinement.TensorTrain.getlastfactor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.had"><code>TensorRefinement.TensorTrain.had</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.mul"><code>TensorRefinement.TensorTrain.mul</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.ranks"><code>TensorRefinement.TensorTrain.ranks</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.rankselect"><code>TensorRefinement.TensorTrain.rankselect</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.rankselect!"><code>TensorRefinement.TensorTrain.rankselect!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.setfactor!"><code>TensorRefinement.TensorTrain.setfactor!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.setfirstfactor!"><code>TensorRefinement.TensorTrain.setfirstfactor!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.setlastfactor!"><code>TensorRefinement.TensorTrain.setlastfactor!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.vector"><code>TensorRefinement.TensorTrain.vector</code></a></li></ul><h1 id="Auxiliary"><a class="docs-heading-anchor" href="#Auxiliary">Auxiliary</a><a id="Auxiliary-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary" title="Permalink"></a></h1><p>This section covers functions related to the Auxiliary module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.Indices" href="#TensorRefinement.Auxiliary.Indices"><code>TensorRefinement.Auxiliary.Indices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Indices</code> is an alias for an object of type <code>Vector{Int}</code>, <code>Int</code>, <code>UnitRange{Int}</code>, <code>StepRange{Int}</code> or <code>NTuple{M,Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.FloatRC" href="#TensorRefinement.Auxiliary.FloatRC"><code>TensorRefinement.Auxiliary.FloatRC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>FloatRC{T}</code> is an alias for an object of type <code>T</code> or <code>Complex{T}</code>, where T is an <code>AbstractFloat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.Float2" href="#TensorRefinement.Auxiliary.Float2"><code>TensorRefinement.Auxiliary.Float2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Float2{T}</code> is an alias for an object of type <code>T</code> or <code>Vector{T}</code>, where T is an <code>AbstractFloat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.Float3" href="#TensorRefinement.Auxiliary.Float3"><code>TensorRefinement.Auxiliary.Float3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Float3{T}</code> is an alias for an object of type <code>T</code>, <code>Vector{T}</code> or <code>Vector{Vector{T}}</code>, where T is an <code>AbstractFloat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.Int2" href="#TensorRefinement.Auxiliary.Int2"><code>TensorRefinement.Auxiliary.Int2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Int2</code> is an alias for an object of type <code>Int</code> or <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.Int3" href="#TensorRefinement.Auxiliary.Int3"><code>TensorRefinement.Auxiliary.Int3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Int3</code> is an alias for an object of type <code>Int</code>, <code>Vector{Int}</code> or <code>Vector{Vector{Int}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.indvec" href="#TensorRefinement.Auxiliary.indvec"><code>TensorRefinement.Auxiliary.indvec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indvec(σ::Indices; min::Int=1, max::Int=0)</code></pre><p>Convert several index specifications to a vector of integers. Function supports Julia indexing types like <code>Colon</code>, <code>Int</code>, <code>UnitRange</code>, <code>StepRange</code>, <code>Tuple</code>, and <code>Nothing</code>.</p><p>Arguments</p><ul><li><code>σ::Indices</code>: Index specification. Can be of various types such as <code>Colon</code>, <code>Int</code>, <code>UnitRange</code>, <code>StepRange</code>, <code>Tuple</code>, <code>Vector{Any}</code>, or <code>Nothing</code>.</li><li><code>min::Int=1</code>: Minimum value for the range (applicable when <code>σ</code> is <code>Colon</code>).</li><li><code>max::Int=0</code>: Maximum value for the range (applicable when <code>σ</code> is <code>Colon</code>).</li></ul><p>Returns</p><ul><li><code>Vector{Int}</code>: Vector of integers derived from the specified index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.threshold" href="#TensorRefinement.Auxiliary.threshold"><code>TensorRefinement.Auxiliary.threshold</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">threshold(c::Vector{T}, τsoft::T, τhard::T, τ::T, r::Int)</code></pre><p>Apply thresholding to the vector <code>c</code> based on soft, hard, and overall thresholds (<code>τsoft</code>, <code>τhard</code>, and <code>τ</code>). Optional truncation of the vector to maintain a specified rank <code>r</code> available.</p><p>Arguments</p><ul><li><code>c::Vector{T}</code>: Vector of elements of Type <code>T</code>.</li><li><code>τsoft::T</code>: Soft threshold value. All elements less than or equal to this value are set to zero, all above are shrunken towards zero.</li><li><code>τhard::T</code>: Hard threshold value. All elements less than or equal to this value are set to zero.</li><li><code>τ::T</code>: Overall tolerance threshold. Elements are truncated based on this value.</li><li><code>r::Int</code>: Desired rank of the vector. Only the first <code>r</code> elements are kept, all others are being set to zero.</li></ul><p>Returns</p><ul><li><code>Tuple{Vector{T}, T, Int}</code>: Tuple containing the thresholded vector, the error (ε), and the new rank (ρ).</li></ul><p>Throws</p><ul><li><code>ArgumentError</code>: If <code>τsoft</code> is negative.</li><li><code>ArgumentError</code>: If <code>τhard</code> is negative.</li><li><code>ArgumentError</code>: If <code>τ</code> is negative.</li><li><code>ArgumentError</code>: If <code>r</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL91-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.compfloateps" href="#TensorRefinement.Auxiliary.compfloateps"><code>TensorRefinement.Auxiliary.compfloateps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compfloateps(::Type{S}) where {T&lt;:AbstractFloat, S&lt;:FloatRC{T}}</code></pre><p>Return the machine epsilon (smallest difference between distinct floating point numbers) for the floating-point type <code>T</code>.</p><p>Arguments</p><ul><li><code>S::Type{S}</code>: A type that is a subtype of <code>FloatRC{T}</code>, where <code>T</code> is a floating-point type (<code>AbstractFloat</code>).</li></ul><p>Returns</p><ul><li><code>T</code>: The machine epsilon of the floating-point type <code>T</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL40-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.modemul" href="#TensorRefinement.Auxiliary.modemul"><code>TensorRefinement.Auxiliary.modemul</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modemul(A::AbstractArray{&lt;:Number,N}, B::Vararg{Pair{Int,&lt;:AbstractMatrix{&lt;:Number}},M}) where {N,M}</code></pre><p>Perform a mode multiplication of an N-dimensional array <code>A</code> with multiple matrices, each matrix corresponding to a specific mode (dimension) of <code>A</code>. Function applies several mode multiplications to the tensor <code>A</code> such that it is transformed according to the provided matrices.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray{&lt;:Number,N}</code>: N-dimensional array of type <code>Number</code>.</li><li><code>B::Vararg{Pair{Int,&lt;:AbstractMatrix{&lt;:Number}},M}</code>: Variable number of pairs <code>(k, Bk)</code>, where <code>k</code> is the dimension index and <code>Bk</code> is a matrix to multiply <code>A</code> with along its <code>k</code>-th dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>A</code>: The result of applying the mode multiplications, eventually, reshaped back to an N-dimensional array.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any dimension index is out of bounds 1:ndims(A), or if any dimension indices are not distinct.</li><li><code>ArgumentError</code>: If any matrix does not match the corresponding dimension size of the tensor.</li><li><code>ArgumentError</code>: If the dimenion indices are not distinct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL270-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.qraddcols" href="#TensorRefinement.Auxiliary.qraddcols"><code>TensorRefinement.Auxiliary.qraddcols</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qraddcols(Q::Matrix{T}, R::Matrix{T}, U::Matrix{T}) where T&lt;:FloatRC</code></pre><p>Extend the QR decomposition by adding additional columns. Given an existing QR decomposition <code>Q * R = A</code> and a new matrix <code>U</code>, this function computes the QR decomposition of <code>[A U]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Q::Matrix{T}</code>: Orthogonal matrix from the QR decomposition of type <code>T</code>.</li><li><code>R::Matrix{T}</code>: Upper triangular matrix from the QR decomposition of type <code>T</code>.</li><li><code>U::Matrix{T}</code>: Matrix to be added to the existing QR decomposition of type <code>T</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Q</code>: Updated orthogonal matrix after adding new columns.</li><li><code>R</code>: Updated upper triangular matrix after adding new columns.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>Q</code> and <code>R</code> are incompatible in rank.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> are incompatible in the first rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL179-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Auxiliary.lqaddrows" href="#TensorRefinement.Auxiliary.lqaddrows"><code>TensorRefinement.Auxiliary.lqaddrows</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lqaddrows(L::Matrix{T}, Q::Matrix{T}, U::Matrix{T}) where T&lt;:FloatRC</code></pre><p>Extend the LQ decomposition by adding additional rows. Given an existing LQ decomposition <code>L * Q = A</code> and a new matrix <code>U</code>, this function computes the LQ decomposition of <code>[L U]&#39;</code>. Currently, this function is not implemented.</p><p><strong>Arguments</strong></p><ul><li><code>L::Matrix{T}</code>: Lower triangular matrix from the LQ decomposition of type <code>T</code>.</li><li><code>Q::Matrix{T}</code>: Orthogonal matrix from the LQ decomposition of type <code>T</code>.</li><li><code>U::Matrix{T}</code>: Matrix to be added to the existing QR decomposition of type <code>T</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>L</code>: Updated lower triangular matrix after adding new rows. </li><li><code>Q</code>: Updated orthogonal matrix after adding new rows.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> and <code>Q</code> are incompatible in size.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> are incompatible in size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Auxiliary.jl#LL215-L234">source</a></section></article><h1 id="Chebyshev"><a class="docs-heading-anchor" href="#Chebyshev">Chebyshev</a><a id="Chebyshev-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev" title="Permalink"></a></h1><p>This section covers functions related to the Chebyshev module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebeval" href="#TensorRefinement.Chebyshev.chebeval"><code>TensorRefinement.Chebyshev.chebeval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebeval(t::Vector{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate the first <code>r</code> Chebyshev polynomials at the points specified in the vector <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{T}</code>: Vector of points at which to evaluate the Chebyshev polynomials.</li><li><code>r::Int</code>: Number of Chebyshev polynomials to evaluate.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: An <code>n</code> x <code>r</code> matrix <code>V</code>, where <code>n</code> is the length of <code>t</code>. The entry <code>V[i,j]</code>  contains the value of the <code>(j-1)</code>-th Legendre polynomial evaluated at <code>t[i]</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL7-L22">source</a></section><section><div><pre><code class="language-julia hljs">chebeval(t::Vector{T}, c::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate a Chebyshev series for a given coefficient vector <code>c</code> at the points in <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{T}</code>: Input vector of points specifying where the series is evaluated.</li><li><code>c::Vector{T}</code>: Coefficients of the Chebyshev series.</li></ul><p><strong>Returns</strong></p><p>Vector <code>u</code> containing the evaluation of the Chebyshev series at each point in <code>t</code>. That means, u[i] contains the evalutation of the Chebyshev series at point t[i] with coefficients from <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebexnodes" href="#TensorRefinement.Chebyshev.chebexnodes"><code>TensorRefinement.Chebyshev.chebexnodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebexnodes(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the Chebyshev nodes of the second kind (also called « Chebyshev extrema ») on the interval [-1, 1].</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev nodes to compute.</li></ul><p><strong>Returns</strong></p><p>Vector of <code>r</code> Chebyshev nodes of the second kind.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL55-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebtochebex" href="#TensorRefinement.Chebyshev.chebtochebex"><code>TensorRefinement.Chebyshev.chebtochebex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebtochebex(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev coefficients to Chebyshev extrema coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev coefficients to Chebyshev extrema coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL83-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebextocheb" href="#TensorRefinement.Chebyshev.chebextocheb"><code>TensorRefinement.Chebyshev.chebextocheb</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebextocheb(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev extrema coefficients to Chebyshev coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev extrema coefficients to Chebyshev coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL105-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebextoleg" href="#TensorRefinement.Chebyshev.chebextoleg"><code>TensorRefinement.Chebyshev.chebextoleg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebextoleg(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev extrema coefficients to Legendre coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev extrema coefficients to Legendre coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL131-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebextolegn" href="#TensorRefinement.Chebyshev.chebextolegn"><code>TensorRefinement.Chebyshev.chebextolegn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebextolegn(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev extrema coefficients to normalized Legendre coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev extrema coefficients to normalized Legendre coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL148-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebrtnodes" href="#TensorRefinement.Chebyshev.chebrtnodes"><code>TensorRefinement.Chebyshev.chebrtnodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebrtnodes(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the Chebyshev nodes of the first kind (also called « Chebyshev roots ») on the interval (-1, 1).</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev roots to compute.</li></ul><p><strong>Returns</strong></p><p>Vector of <code>r</code> Chebyshev nodes of the first kind.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL165-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebtochebrt" href="#TensorRefinement.Chebyshev.chebtochebrt"><code>TensorRefinement.Chebyshev.chebtochebrt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebtochebrt(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix from Chebyshev polynomial coefficients to Chebyshev root polynomial coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix representing the transformation from Chebyshev coefficients to Chebyshev root coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL193-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebrttocheb" href="#TensorRefinement.Chebyshev.chebrttocheb"><code>TensorRefinement.Chebyshev.chebrttocheb</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebrttocheb(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix from Chebyshev root polynomial coefficients to Chebyshev polynomial coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix representing the transformation from Chebyshev root coefficients to Chebyshev coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL217-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebrttoleg" href="#TensorRefinement.Chebyshev.chebrttoleg"><code>TensorRefinement.Chebyshev.chebrttoleg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebrttoleg(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev root coefficients to Legendre coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev root coefficients to Legendre coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL242-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebrttolegn" href="#TensorRefinement.Chebyshev.chebrttolegn"><code>TensorRefinement.Chebyshev.chebrttolegn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebrttolegn(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev root coefficients to normalized Legendre coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev root coefficients to normalized Legendre coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL259-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebtoleg" href="#TensorRefinement.Chebyshev.chebtoleg"><code>TensorRefinement.Chebyshev.chebtoleg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebtoleg(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev coefficients to Legendre coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev coefficients to Legendre coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL276-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebtolegn" href="#TensorRefinement.Chebyshev.chebtolegn"><code>TensorRefinement.Chebyshev.chebtolegn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebtolegn(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Chebyshev coefficients to normalized Legendre coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Chebyshev coefficients to normalized Legendre coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL315-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.legtocheb" href="#TensorRefinement.Chebyshev.legtocheb"><code>TensorRefinement.Chebyshev.legtocheb</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legtocheb(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from Legendre coefficients to Chebyshev coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Legendre polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from Legendre coefficients to Chebyshev coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL332-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.legntocheb" href="#TensorRefinement.Chebyshev.legntocheb"><code>TensorRefinement.Chebyshev.legntocheb</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legntocheb(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the transformation matrix that converts from normalized Legendre coefficients to Chebyshev coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of the floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Matrix that represents the transformation from normalized Legendre coefficients to Chebyshev coefficients.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL369-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebref" href="#TensorRefinement.Chebyshev.chebref"><code>TensorRefinement.Chebyshev.chebref</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebref(ξ::T, η::T, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the Chebyshev reference matrix for interpolation between two points <code>ξ</code> and <code>η</code>. Currently, this function is not implemented.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: First one of the two points which are to be interpolated.</li><li><code>η::T</code>: Second one of the two points which are to be interpolated.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: A matrix of size <code>r x r</code> representing the reference for interpolation between <code>ξ</code> and <code>η</code> using the Chebyshev polynomials up to a degree of <code>r-1</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL553-L569">source</a></section><section><div><pre><code class="language-julia hljs">chebref(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute the Chebyshev reference matrix (with entries of type <code>T</code>) for Chebyshev polynomials up to a degree of <code>r-1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Type of floating-point numbers.</li><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: A matrix of size <code>r x r</code> representing the reference for the Chebyshev polynomials up to a degree of <code>r-1</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL576-L590">source</a></section><section><div><pre><code class="language-julia hljs">chebref(r::Int)</code></pre><p>Convenience function to call <code>chebref(Float64, r)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r::Int</code>: Number of Chebyshev polynomials.</li></ul><p><strong>Returns</strong></p><p>Chebyshev reference matrix of size <code>r × r</code>, whose entries are of Type <code>Float64</code>.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL597-L610">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebdiff" href="#TensorRefinement.Chebyshev.chebdiff"><code>TensorRefinement.Chebyshev.chebdiff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebdiff(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Computes the differentiation matrix for Chebyshev polynomials of degree up to <code>r-1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Numeric type for the matrix elements; subtype of <code>AbstractFloat</code>.</li><li><code>r::Int</code>: Number of Chebyshev polynomials (degree).</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: A matrix of size <code>r</code> x <code>r</code> representing the differentiation operator for Chebyshev polynomials of degree up to <code>r-1</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL386-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebexdiff" href="#TensorRefinement.Chebyshev.chebexdiff"><code>TensorRefinement.Chebyshev.chebexdiff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebexdiff(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Computes the differentiation matrix for <code>r</code> Chebyshev extrema nodes.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Numeric type for the matrix elements; subtype of <code>AbstractFloat</code>.</li><li><code>r::Int</code>: Number of extrema nodes.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: A matrix of size <code>r</code> x <code>r</code> representing the differentiation operator for <code>r</code> Chebyshev extrema nodes.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL419-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebdec" href="#TensorRefinement.Chebyshev.chebdec"><code>TensorRefinement.Chebyshev.chebdec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebdec(c::Vector{T}, L::Int; major::String=&quot;last&quot;) where {T&lt;:AbstractFloat}</code></pre><p>Construct a Chebyshev decomposition based on the coefficients <code>c</code> and the number of terms <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>c::Vector{T}</code>: Vector of Chebyshev coefficients.</li><li><code>L::Int</code>: Number of terms in the decomposition.</li><li><code>major::String</code>: Order of decomposition, either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code> (default is <code>&quot;last&quot;</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: A decomposition consisting of factors obtained by the reference matrices of Chebyshev polynomials.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If major<code>is neither</code>&quot;first&quot;<code>nor</code>&quot;last&quot;`.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL613-L628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Chebyshev.chebdeceval!" href="#TensorRefinement.Chebyshev.chebdeceval!"><code>TensorRefinement.Chebyshev.chebdeceval!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebdeceval!(U::Dec{T,N}, t::Vector{T}; major::String=&quot;last&quot;) where {T&lt;:AbstractFloat,N}</code></pre><p>Evaluate a Chebyshev decomposition <code>U</code> at the points specified in <code>t</code>, and modify it in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Chebyshev decomposition to evaluate.</li><li><code>t::Vector{T}</code>: Vector of points at which to evaluate the decomposition.</li><li><code>major::String</code>: Order of decomposition, either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code> (default is <code>&quot;last&quot;</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>:The evaluated decomposition <code>U</code> at points <code>t</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>major</code> is not <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Chebyshev.jl#LL643-L658">source</a></section></article><h1 id="Exponential"><a class="docs-heading-anchor" href="#Exponential">Exponential</a><a id="Exponential-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential" title="Permalink"></a></h1><p>This section covers functions related to the Exponential module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigevalmask" href="#TensorRefinement.Exponential.trigevalmask"><code>TensorRefinement.Exponential.trigevalmask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigevalmask(t::Vector{T}, ν::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate the trigonometric functions cosine and sine at a set of points <code>t</code> for a given set of frequencies <code>ν</code>.</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{T}</code>: Vector of points where the trigonometric functions are evaluated.</li><li><code>ν::Vector{T}</code>: Vector of frequencies for which the trigonometric functions are computed. Length of <code>ν</code> determines the number of cosine-sine pairs.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: A matrix of size <code>(n, 2*r)</code>, where <code>n</code> is the length of <code>t</code> and <code>r</code> is the length of <code>ν</code>. Each row contains alternating cosine and sine values for the corresponding point in <code>t</code> and frequency in <code>ν</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of frequencies <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigeval" href="#TensorRefinement.Exponential.trigeval"><code>TensorRefinement.Exponential.trigeval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigeval(t::Vector{T}, ν::Vector{T}, c::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate a trigonometric series with given frequencies <code>ν</code> and coefficients <code>c</code> at a set of points <code>t</code>. Each element in <code>t</code> is evaluated as the sum of cosine and sine terms for  each frequency in <code>ν</code> with the weight corresponding to the coefficients in <code>c</code>.</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{T}</code>: Vector of points where the trigonometric series is evaluated.</li><li><code>ν::Vector{T}</code>: Vector of frequencies for the trigonometric series. Length of <code>ν</code> determines the number of cosine-sine pairs.</li><li><code>c::Vector{T}</code>: Vector of coefficients, where each pair of consecutive elements corresponds to the cosine and sine weights for a particular frequency.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{T}</code>: Vector of length <code>n</code> (the length of <code>t</code>) which represents the values of the trigonometric series evaluated at each point in <code>t</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of frequencies <code>r</code> is not positive.</li><li><code>ArgumentError</code>: If the length of <code>c</code> is not <code>2*r</code>, rendering <code>ν</code> and <code>c</code> incompatible in size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL39-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigrefmask" href="#TensorRefinement.Exponential.trigrefmask"><code>TensorRefinement.Exponential.trigrefmask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigrefmask(η::T, ν::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Construct a reference mask for trigonometric transformations, based on a shift <code>η</code> and a set of frequencies <code>ν</code>.</p><p><strong>Arguments</strong></p><ul><li><code>η::T</code>: Shift value for the trigonometric transformations.</li><li><code>ν::Vector{T}</code>: Vector of frequencies. Each frequency corresponds to a 2x2 block in the resulting matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: Square matrix of size <code>2*r × 2*r</code>, where <code>r</code> is the length of <code>ν</code>. Each 2x2 block contains the sine and cosine values for the corresponding frequency in <code>ν</code>, rotated by <code>η</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of frequencies <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL75-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigrefmask2" href="#TensorRefinement.Exponential.trigrefmask2"><code>TensorRefinement.Exponential.trigrefmask2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigrefmask2(ν::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Construct a reference mask for trigonometric interpolation using two points at <code>-1/2</code> and <code>1/2</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ν::Vector{T}</code>: Vector of frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T,3}</code>: Three-dimensional array of size <code>2r × 2r × 2</code>, where <code>r</code> is the length of <code>ν</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>ν</code> is empty (i.e., <code>r == 0</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL106-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigdiffmask" href="#TensorRefinement.Exponential.trigdiffmask"><code>TensorRefinement.Exponential.trigdiffmask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigdiffmask(ν::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Constructs a differentiation mask for trigonometric functions based on the given frequencies.</p><p><strong>Arguments</strong></p><ul><li><code>ν::Vector{T}</code>: Vector of frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: Square matrix of size <code>2r × 2r</code>, where <code>r</code> is the length of <code>ν</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of frequencies <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL132-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigdiff" href="#TensorRefinement.Exponential.trigdiff"><code>TensorRefinement.Exponential.trigdiff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigdiff(ν::Vector{T}, c::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Perform differentiation on trigonometric functions with the given frequencies <code>ν</code> and coefficients <code>c</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ν::Vector{T}</code>: Vector of frequencies.</li><li><code>c::Vector{T}</code>: Vector of coefficients, which must be of length <code>2r</code>, where <code>r</code> is the length of <code>ν</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{T}</code>: Vector of differentiated coefficients of length <code>2r</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the length of <code>c</code> does not match <code>2r</code>, rendering <code>v</code> and <code>c</code> incompatible in size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL159-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigdec" href="#TensorRefinement.Exponential.trigdec"><code>TensorRefinement.Exponential.trigdec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigdec(ν::Vector{T}, c::Vector{T}, L::Int; major::String=&quot;last&quot;) where {T&lt;:AbstractFloat}</code></pre><p>Construct a trigonometric decomposition based on frequencies <code>ν</code> and coefficients <code>c</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ν::Vector{T}</code>: Vector of frequencies.</li><li><code>c::Vector{T}</code>: Vector of coefficients, which must be twice the length of <code>ν</code>.</li><li><code>L::Int</code>: Length of the decomposition.</li><li><code>major::String</code>: Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>, specifying the major dimension of the decomposition (default is <code>&quot;last&quot;</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Decomposition <code>U</code> of length <code>L</code> where the first factor is based on the coefficients <code>c</code>, and the remaining factors are based on trigonometric reference masks.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>ν</code> and <code>c</code> have incompatible sizes.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL251-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.trigdeceval!" href="#TensorRefinement.Exponential.trigdeceval!"><code>TensorRefinement.Exponential.trigdeceval!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigdeceval!(U::Dec{T,N}, t::Vector{T}, ν::Vector{T}; major::String=&quot;last&quot;) where {T&lt;:AbstractFloat,N}</code></pre><p>Evaluate a trigonometric decomposition <code>U</code> at a set of points <code>t</code> and frequencies <code>ν</code>, modifying the decomposition in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition to be evaluated.</li><li><code>t::Vector{T}</code>: Vector of points at which to evaluate the decomposition.</li><li><code>ν::Vector{T}</code>: Vector of frequencies.</li><li><code>major::String</code>: Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>, specifying the major dimension of the decomposition (default is <code>&quot;last&quot;</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Evaluated and accordingly updated decomposition <code>U</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li><li><code>ArgumentError</code>: If <code>N ≠ 3</code>, i.e., if there are factors whose number of mode indices is not 1.</li><li><code>ArgumentError</code> If the first or last rank of <code>U</code> and the size of <code>ν</code> are incompatible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL286-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.cosfactor" href="#TensorRefinement.Exponential.cosfactor"><code>TensorRefinement.Exponential.cosfactor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cosfactor(τ::Vector{T}, c::T) where {T&lt;:AbstractFloat}</code></pre><p>Construct a factorized cosine-sine matrix for each value of <code>τ</code> using the scaling value <code>c</code>.</p><p><strong>Arguments</strong></p><ul><li><code>τ::Vector{T}</code>: Vector of angles in radians.</li><li><code>c::T</code>: Value used in scaling the cosine and sine terms.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T,3}</code>: Three-dimensional array of size <code>2 × n × 2</code>, where <code>n</code> is the length of <code>τ</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>τ</code> is empty (i.e., <code>n == 0</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL187-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Exponential.cosdec" href="#TensorRefinement.Exponential.cosdec"><code>TensorRefinement.Exponential.cosdec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cosdec(τ::Vector{Vector{T}}, c::Vector{T}) where {T&lt;:AbstractFloat}</code></pre><p>Construct a cosine-based decomposition given a set of angles <code>τ</code> and coefficients <code>c</code>.</p><p><strong>Arguments</strong></p><ul><li><code>τ::Vector{Vector{T}}</code>: Vector whose elements are vectors of angles in radians.</li><li><code>c::Vector{T}</code>: Vector of coefficients corresponding to the angles in <code>τ</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Decomposition <code>U</code> where each of the <code>L</code> elements is a cosine matrix turned into a factor.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>τ</code> and <code>c</code> are of different lengths.</li><li><code>ArgumentError</code>: If any element of <code>τ</code> is empty.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Exponential.jl#LL219-L234">source</a></section></article><h1 id="FEM"><a class="docs-heading-anchor" href="#FEM">FEM</a><a id="FEM-1"></a><a class="docs-heading-anchor-permalink" href="#FEM" title="Permalink"></a></h1><p>This section covers functions related to the FEM module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.extdn" href="#TensorRefinement.FEM.extdn"><code>TensorRefinement.FEM.extdn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extdn(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Generate a matrix decomposition which specifies ... based on the parameters provided.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>ℓ::Int</code>: Index of the current factor.</li><li><code>d::Int</code>: ...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MatrixDec{T}</code>: Matrix decomposition <code>P</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is not positive.</li><li><code>ArgumentError</code>: If <code>ℓ</code> is not in <code>0:L</code>.</li><li><code>ArgumentError</code>: If <code>d</code> is not positive.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL7-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.extdd" href="#TensorRefinement.FEM.extdd"><code>TensorRefinement.FEM.extdd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extdd(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Generate a matrix decomposition specifiying... </p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>ℓ::Int</code>: Index of the current factor.</li><li><code>d::Int</code>: Size of the ...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MatrixDec{T}</code>: Matrix decomposition <code>P</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is not positive.</li><li><code>ArgumentError</code>: If <code>ℓ</code> is not in <code>1:L</code>.</li><li><code>ArgumentError</code>: If <code>d</code> is not positive.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL64-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.diffdn" href="#TensorRefinement.FEM.diffdn"><code>TensorRefinement.FEM.diffdn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffdn(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Construct a matrix decomposition that represents ...</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>ℓ::Int</code>: Index of the current factor.</li><li><code>d::Int</code>: Size of the ...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MatrixDec{T}</code>: Matrix decomposition <code>M</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is negative.</li><li><code>ArgumentError</code>: If <code>ℓ</code> is not in <code>0:L</code>.</li><li><code>ArgumentError</code>: If <code>d</code> is not positive.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL122-L142">source</a></section><section><div><pre><code class="language-julia hljs">diffdn(::Type{T}, L::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Sentence summarizing the function.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the ...</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major axis (&quot;first&quot; or &quot;last&quot;) for the operation. The default is <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><p>Returns the result ....</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is negative.</li><li><code>ArgumentError</code>: If <code>d</code> is not positive.</li><li><code>ArgumentError</code>: If <code>major</code> is not <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL221-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.diffdd" href="#TensorRefinement.FEM.diffdd"><code>TensorRefinement.FEM.diffdd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffdd(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Construct a matrix decomposition representing ... based on the parameters provided.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>ℓ::Int</code>: Index of the current factor. Should be in the range <code>1:L</code>.</li><li><code>d::Int</code>: Size of the...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MatrixDec{T}</code>: Matrix decomposition <code>M</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>ℓ</code> is not in <code>1:L</code>.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL242-L262">source</a></section><section><div><pre><code class="language-julia hljs">diffdd(::Type{T}, L::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Summary Sentence for function.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the...</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major axis (&quot;first&quot; or &quot;last&quot;) for the operation. The default is <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><p>Returns the result...</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL341-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.dint" href="#TensorRefinement.FEM.dint"><code>TensorRefinement.FEM.dint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dint(::Type{T}, L::Int, d::Int, K::AbstractMatrix{T}; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Construct a decomposition representing integration ... with a given coefficient matrix <code>K</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the ...</li><li><code>K::AbstractMatrix{T}</code>: Coefficient matrix, should be of size <code>(d+1, d+1)</code>.</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Decomposition <code>Λ</code> representing the integration.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>K</code> is not of size <code>(d+1, d+1)</code>.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL362-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.dintf" href="#TensorRefinement.FEM.dintf"><code>TensorRefinement.FEM.dintf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dintf(::Type{T}, L::Int, d::Int, K::AbstractMatrix{T}; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Construct a decomposition representing integration ... with a given coefficient matrix <code>K</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the ...</li><li><code>K::AbstractMatrix{T}</code>: Coefficient matrix, should be of size <code>(d+1, d+1)</code>.</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Decomposition <code>Λ</code> representing the integration...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>K</code> is not of size <code>(d+1, d+1)</code>.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL407-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.bpxdn" href="#TensorRefinement.FEM.bpxdn"><code>TensorRefinement.FEM.bpxdn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bpxdn(::Type{T}, L::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Construct a decomposition representing ...</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Decomposition <code>C</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL452-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.bpxdd" href="#TensorRefinement.FEM.bpxdd"><code>TensorRefinement.FEM.bpxdd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bpxdd(::Type{T}, L::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Construct a decomposition representing ...</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the ... </li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Decomposition <code>C</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL498-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.extmix" href="#TensorRefinement.FEM.extmix"><code>TensorRefinement.FEM.extmix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extmix(::Type{T}, L::Int, ℓ::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Construct a decomposition representing ... for a given set of parameters.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>ℓ::Int</code>: Current factor index (must be between 0 and L).</li><li><code>d::Int</code>: Size of the...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MatrixDec{T}</code>: Matrix decomposition <code>E</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>ℓ</code> is not in the range <code>0:L</code>.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL547-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.diffbpxdn" href="#TensorRefinement.FEM.diffbpxdn"><code>TensorRefinement.FEM.diffbpxdn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffbpxdn(::Type{T}, L::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Generate a decomposition representing ... using ...</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the ...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MatrixDec{T}</code>: Matrix decomposition <code>M</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL688-L706">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.FEM.diffbpxdd" href="#TensorRefinement.FEM.diffbpxdd"><code>TensorRefinement.FEM.diffbpxdd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffbpxdd(::Type{T}, L::Int, d::Int; major::String=&quot;last&quot;) where {T&lt;:FloatRC}</code></pre><p>Generate decomposition representing ... using ...</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>FloatRC</code>).</li><li><code>L::Int</code>: Total number of factors in the decomposition.</li><li><code>d::Int</code>: Size of the ...</li><li><code>major::String</code>: Specifies the major dimension of the decomposition, either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MatrixDec{T}</code>: Matrix decomposition <code>M</code> representing ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>d</code> is less than 1.</li><li><code>ArgumentError</code>: If <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/FEM.jl#LL793-L811">source</a></section></article><h1 id="Legendre"><a class="docs-heading-anchor" href="#Legendre">Legendre</a><a id="Legendre-1"></a><a class="docs-heading-anchor-permalink" href="#Legendre" title="Permalink"></a></h1><p>This section covers functions related to the Legendre module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legeval" href="#TensorRefinement.Legendre.legeval"><code>TensorRefinement.Legendre.legeval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legeval(t::Vector{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate the first <code>r</code> Legendre polynomials at the points specified in the vector <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{T}</code>: Vector of points at which to evaluate the Legendre polynomials.</li><li><code>r::Int</code>: Number of Legendre polynomials to evaluate.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: An <code>n</code> x <code>r</code> matrix <code>V</code>, where <code>n</code> is the length of <code>t</code>. The entry <code>V[i,j]</code>  contains the value of the <code>(j-1)</code>-th Legendre polynomial evaluated at <code>t[i]</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL51-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legneval" href="#TensorRefinement.Legendre.legneval"><code>TensorRefinement.Legendre.legneval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legneval(t::Vector{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate the first <code>r</code> normalized Legendre polynomials at the points specified in the vector <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{T}</code>: Vector of points at which to evaluate the normalized Legendre polynomials.</li><li><code>r::Int</code>: Number of normalized Legendre polynomials to evaluate.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: An <code>n</code> x <code>r</code> matrix <code>V</code>, where <code>n</code> is the length of <code>t</code>. The entry <code>V[i,j]</code>  contains the value of the <code>(j-1)</code>-th normalized Legendre polynomial evaluated at <code>t[i]</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of degrees of freedom <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL80-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legtolegn" href="#TensorRefinement.Legendre.legtolegn"><code>TensorRefinement.Legendre.legtolegn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legtolegn(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Construct a diagonal matrix that transforms coefficients in the Legendre polynomial basis  to coefficients in the normalized Legendre polynomial basis.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>AbstractFloat</code>) for the matrix elements.</li><li><code>r::Int</code>: Size of the matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Diagonal{T}</code>: Diagonal matrix of size <code>r</code> x <code>r</code> containing the scaling factors  to convert from Legendre polynomials to normalized Legendre polynomials.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legntoleg" href="#TensorRefinement.Legendre.legntoleg"><code>TensorRefinement.Legendre.legntoleg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legntoleg(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Construct a diagonal matrix that transforms coefficients in the normalized Legendre polynomial basis  to coefficients in the standard Legendre polynomial basis.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>AbstractFloat</code>) for the matrix elements.</li><li><code>r::Int</code>: Size of the matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Diagonal{T}</code>: Diagonal matrix of size <code>r</code> x <code>r</code> containing the scaling factors  to convert from normalized Legendre polynomials to Legendre polynomials.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legdiff" href="#TensorRefinement.Legendre.legdiff"><code>TensorRefinement.Legendre.legdiff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legdiff(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Construct a differentiation matrix for Legendre polynomials of degree up to <code>r-1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>AbstractFloat</code>) for the matrix elements.</li><li><code>r::Int</code>: Number of degrees of freedom (DOFs), i.e., the size of the matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: Matrix of size <code>r</code> x <code>r</code> representing the differentiation operator for Legendre polynomials of degree up to <code>r-1</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL98-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legndiff" href="#TensorRefinement.Legendre.legndiff"><code>TensorRefinement.Legendre.legndiff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legndiff(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Construct a differentiation matrix for normalized Legendre polynomials of degree up to <code>r-1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>AbstractFloat</code>) for matrix elements.</li><li><code>r::Int</code>: Number of degrees of freedom (DOFs), i.e., the size of the matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: Matrix of size <code>r</code> x <code>r</code> representing the differentiation operator for normalized Legendre polynomials of degree up to <code>r-1</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is not positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL127-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legref" href="#TensorRefinement.Legendre.legref"><code>TensorRefinement.Legendre.legref</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legref(ξ::T, η::T, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute a matrix related to the Legendre polynomials over a reference interval, parameterized by <code>ξ</code> and <code>η</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Float representing one of the parameters for the transformation.</li><li><code>η::T</code>: Float representing the other parameter for the transformation.</li><li><code>r::Int</code>: Number of degrees of freedom (DOFs), i.e., the size of the matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: An <code>r</code> x <code>r</code> matrix <code>W</code> that encodes the transformation in the Legendre polynomial basis for given parameters <code>ξ</code> and <code>η</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is less than 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL144-L159">source</a></section><section><div><pre><code class="language-julia hljs">legref(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute a matrix based on the Legendre polynomials that encodes specific transformations or relations.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>AbstractFloat</code>) for matrix elements.</li><li><code>r::Int</code>: Number of degrees of freedom (DOFs), i.e., the size of the matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T,3}</code>: An <code>r</code> x <code>r</code> x <code>2</code> array <code>W</code> where the first slice (<code>W[:,:,1]</code>) represents the transformation matrix in a standard basis   and the second slice (<code>W[:,:,2]</code>) ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is less than 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL179-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legnref" href="#TensorRefinement.Legendre.legnref"><code>TensorRefinement.Legendre.legnref</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lengref(::Type{T}, r::Int) where {T&lt;:AbstractFloat}</code></pre><p>Compute a matrix based on the normalized Legendre polynomials that encodes specific transformations or relations.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Numeric type (subtype of <code>AbstractFloat</code>) for matrix elements.</li><li><code>r::Int</code>: Number of degrees of freedom (DOFs), i.e., the size of the matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T,3}</code>: An <code>r</code> x <code>r</code> x <code>2</code> array <code>W</code> where the first slice (<code>W[:,:,1]</code>) represents the transformation matrix in a standard basis   and the second slice (<code>W[:,:,2]</code>) ...</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> is less than 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL223-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legdec" href="#TensorRefinement.Legendre.legdec"><code>TensorRefinement.Legendre.legdec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legdec(c::Vector{T}, L::Int; major::String=&quot;last&quot;) where {T&lt;:AbstractFloat}</code></pre><p>Construct a decomposition based on the Legendre polynomials for a given vector of coefficients <code>c</code> and a specified number of factors <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>c::Vector{T}</code>: Vector of coefficients for the Legendre polynomials. Length of this vector (<code>r</code>) determines the degree of the polynomial (maximal <code>r-1</code>).</li><li><code>L::Int</code>: Number of factors in the decomposition.</li><li><code>major::String</code>: Specifies the ordering of the decomposition, either &quot;last&quot; (default) or &quot;first&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Decomposition object based on the Legendre polynomials and the given vector of coefficients <code>c</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>major</code> is neither &quot;first&quot; nor &quot;last&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL328-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.Legendre.legdeceval!" href="#TensorRefinement.Legendre.legdeceval!"><code>TensorRefinement.Legendre.legdeceval!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legdeceval!(U::Dec{T,N}, t::Vector{T}; major::String=&quot;last&quot;) where {T&lt;:AbstractFloat,N}</code></pre><p>Evaluate a Legendre polynomial decomposition <code>U</code> at a set of points <code>t</code>, adding the reshaped evaluation matrix as a factor to <code>U</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition representing a Legendre polynomial; will be evaluated and modified in place.</li><li><code>t::Vector{T}</code>: Vector of points at which to evaluate the polynomial.</li><li><code>major::String</code>: Specifies the ordering of the decomposition, either &quot;last&quot; (default) or &quot;first&quot;. </li></ul><p><strong>Returns</strong></p><ul><li><code>Dec{T,N}</code>: Modified decomposition object <code>U</code>, now including a factor based on the reshaped evaluation matrix at points <code>t</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>major</code> is neither &quot;first&quot; nor &quot;last&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/Legendre.jl#LL358-L373">source</a></section></article><h1 id="TensorTrainFactor"><a class="docs-heading-anchor" href="#TensorTrainFactor">TensorTrainFactor</a><a id="TensorTrainFactor-1"></a><a class="docs-heading-anchor-permalink" href="#TensorTrainFactor" title="Permalink"></a></h1><p>This section covers functions related to the TensorTrainFactor module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.FactorSize" href="#TensorRefinement.TensorTrain.FactorSize"><code>TensorRefinement.TensorTrain.FactorSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Factorsize</code> is an alias for a <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.Factor" href="#TensorRefinement.TensorTrain.Factor"><code>TensorRefinement.TensorTrain.Factor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Factor{T,N}</code> is an alias for <code>Array{T,N}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.VectorFactor" href="#TensorRefinement.TensorTrain.VectorFactor"><code>TensorRefinement.TensorTrain.VectorFactor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>VectorFactor{T}</code> is a 3D tensor with entries of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.MatrixFactor" href="#TensorRefinement.TensorTrain.MatrixFactor"><code>TensorRefinement.TensorTrain.MatrixFactor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>MatrixFactor{T}</code> is a 4D tensor with entries of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorsize" href="#TensorRefinement.TensorTrain.factorsize"><code>TensorRefinement.TensorTrain.factorsize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorsize(U::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Determine the sizes of the mode dimensions of the given factor <code>U</code> in a vector, excluding the first and last dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>Factorsize(n)</code>: custom type <code>Factorsize</code> that holds the mode dimensions of <code>U</code> excluding the first and last dimension as a vector.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If factor exhibits only one or no rank dimension.</li><li><code>ArgumentError</code>: If factor exhibits negative mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL31-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorranks" href="#TensorRefinement.TensorTrain.factorranks"><code>TensorRefinement.TensorTrain.factorranks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorranks(U::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Determine the first and last rank dimension of a given factor <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple <code>(sz[1], sz[end])</code> where <code>sz[1]</code> is the first and <code>sz[end]</code> is the last dimension of the input tensor.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If factor exhibits only one or no rank dimension.</li><li><code>ArgumentError</code>: If factor exhibits negative mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL58-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorndims" href="#TensorRefinement.TensorTrain.factorndims"><code>TensorRefinement.TensorTrain.factorndims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorndims(::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Return the number of mode dimensions excluding the first and last dimension.</p><p><strong>Arguments</strong></p><ul><li><code>::Factor{T, N}</code>: factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>An integer representing the number of mode dimensions, which is <code>N - 2</code> (number of entries in <a href="index.html#TensorRefinement.TensorTrain.factorsize"><code>factorsize</code></a>).</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If factor exhibits only one or no rank dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL102-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factornumentries" href="#TensorRefinement.TensorTrain.factornumentries"><code>TensorRefinement.TensorTrain.factornumentries</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factornumentries(U::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Determine the number of entries in the given factor.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>An integer specifiying the number of entries in the given [<code>Factor</code>].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL84-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorstorage" href="#TensorRefinement.TensorTrain.factorstorage"><code>TensorRefinement.TensorTrain.factorstorage</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An alias for the function <a href="index.html#TensorRefinement.TensorTrain.factornumentries"><code>factornumentries</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL97-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factor" href="#TensorRefinement.TensorTrain.factor"><code>TensorRefinement.TensorTrain.factor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factor(U::Array{T,N}) where {T&lt;:Number,N}</code></pre><p>Reshape a given tensor <code>U</code> into a factor that can be used in further TT-operations.</p><p><strong>Arguments</strong></p><ul><li><code>U::Array{T, N}</code>: Multi-dimensional array with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped version of the tensor <code>U</code> with a single first and last dimension to facilitate TT-operations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL123-L133">source</a></section><section><div><pre><code class="language-julia hljs">factor(U::Matrix{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, 
       n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}, 
       π::Union{NTuple{K,Int}, Vector{Int}}) where {T&lt;:Number, K, M, N}</code></pre><p>Reshape a matrix <code>U</code> into a multi-dimensional array with specified mode sizes <code>m</code> and <code>n</code>,  and permute the mode dimensions according to the permutation <code>π</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Matrix{T}</code>: Input matrix with elements of type <code>T</code>.</li><li><code>m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the first dimension of <code>U</code>.</li><li><code>n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the second dimension of <code>U</code>.</li><li><code>π::Union{NTuple{K,Int}, Vector{Int}}</code>: Permutation of the mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped and permuted tensor based on the provided mode sizes <code>m</code>, <code>n</code>, and permutation <code>π</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>π</code> is empty or not a valid permutation of <code>1:length(m) + length(n)</code>.</li><li><code>ArgumentError</code>: If <code>m</code> or <code>n</code> is none of the following: integer, vector or tuple of integers, empty vector or tuple. </li><li><code>DimensionMismatch</code>: If the dimensions of <code>U</code> are not divisible by the products of <code>m</code> or <code>n</code>, respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL138-L159">source</a></section><section><div><pre><code class="language-julia hljs">factor(U::Matrix{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, 
       n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}) where {T&lt;:Number, M, N}</code></pre><p>Reshape a matrix <code>U</code> into a multi-dimensional array with mode sizes <code>m</code> and <code>n</code> and use <code>1:length(m)+length(n)</code> as permutation of dimensions.</p><p>Function is a variant of the more general <code>factor</code> function with an automatic permutation sequence <code>1:length(m)+length(n)</code> applied to the reshaped matrix.</p><p><strong>Arguments</strong></p><ul><li><code>U::Matrix{T}</code>: Input matrix with elements of type <code>T</code>.</li><li><code>m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the first dimension of <code>U</code>.</li><li><code>n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the second dimension of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped and permuted factor based on the mode sizes <code>m</code> and <code>n</code> with a permutation <code>1:length(m)+length(n)</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>m</code> or <code>n</code> is not an integer, a vector or tuple of integers, or an empty vector or tuple.</li><li><code>DimensionMismatch</code>: If the dimensions of <code>U</code> are not divisible by the products of <code>m</code> or <code>n</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL196-L215">source</a></section><section><div><pre><code class="language-julia hljs">factor(U::Vector{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, 
       π::Union{NTuple{M,Int}, Vector{Int}}) where {T&lt;:Number, M}</code></pre><p>Reshape a vector <code>U</code> into a two-dimensional array, then reshape it further into a multi-dimensional array based on the mode sizes <code>m</code> and apply the permutation <code>π</code>.</p><p>Function is a variant of the more general <code>factor</code> function, which allows reshaping a vector <code>U</code> into a matrix and then applying mode sizes and a custom permutation.</p><p><strong>Arguments</strong></p><ul><li><code>U::Vector{T}</code>: Input vector with elements of type <code>T</code>.</li><li><code>m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the reshaped array.</li><li><code>π::Union{NTuple{M,Int}, Vector{Int}}</code>: Permutation of the mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped and permuted factor based on the mode sizes <code>m</code> and permutation <code>π</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>m</code> is not an integer, a vector or tuple of integers, or an empty vector or tuple.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL218-L236">source</a></section><section><div><pre><code class="language-julia hljs">factor(U::Vector{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}) where {T&lt;:Number, M}</code></pre><p>Reshape a vector <code>U</code> into a two-dimensional array, then reshape it into a multi-dimensional array based on the mode sizes <code>m</code> with a natural permutation.</p><p>Function is a variant of the more general <code>factor</code> function, which reshapes a vector <code>U</code> into a matrix and then into an array with mode sizes <code>m</code>. It also applies a natural permutation <code>1:length(m)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Vector{T}</code>: Input vector with elements of type <code>T</code>.</li><li><code>m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the reshaped array.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped and permuted factor based on the mode sizes <code>m</code> with a natural permutation.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>m</code> is not an integer, a vector or tuple of integers, or an empty vector or tuple.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL239-L255">source</a></section><section><div><pre><code class="language-julia hljs">factor(U::Dec{T,N}; major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Create a new decomposition by factorizing the decomposition <code>U</code> to a single factor (contraction along all mode dimmensions).</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition, whose entries are in <code>T</code> and with <code>N</code> dimensions, to factorize.</li><li><code>major::String=&quot;last&quot;</code>: Reference numbers for selecting slices along the first rank dimension of the first factor of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: New factor object type <code>Factor</code> obtained by contracting the entire decomposition. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL659-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormatrix" href="#TensorRefinement.TensorTrain.factormatrix"><code>TensorRefinement.TensorTrain.factormatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormatrix(U::Factor{T,K}, π::Indices, σ::Indices) where {T&lt;:Number, K}</code></pre><p>Convert a factor <code>U</code> into a matrix by permuting and reshaping the mode dimensions according to the specified indices <code>π</code> and <code>σ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,K}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>K</code> dimensions.</li><li><code>π::Indices</code>: Reference numbers specifying the permutation of mode dimensions for the first dimension of the resulting matrix.</li><li><code>σ::Indices</code>: Reference numbers specifying the permutation of mode dimensions for the second dimension of the resulting matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix obtained by permuting and reshaping <code>U</code> according to the specified indices <code>π</code> and <code>σ</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> does not have at least one mode dimension.</li><li><code>ArgumentError</code>: If <code>π</code> or <code>σ</code> are not valid indices or do not constitute a valid permutation of mode dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL258-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorrankselect" href="#TensorRefinement.TensorTrain.factorrankselect"><code>TensorRefinement.TensorTrain.factorrankselect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorrankselect(U::Factor{T,N}, α::Indices, β::Indices) where {T&lt;:Number, N}</code></pre><p>Select specific slices from a factor <code>U</code> based on the provided rank indices <code>α</code> and <code>β</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>α::Indices</code>: Reference numbers for selecting slices along the first rank dimension.</li><li><code>β::Indices</code>: Reference numbers for selecting slices along the second rank dimension.</li></ul><p><strong>Returns</strong></p><ul><li>A sub-array of <code>U</code> corresponding to the specified slices.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the indices <code>α</code> or <code>β</code> are incorrect or out of range for the respective rank dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL299-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.block" href="#TensorRefinement.TensorTrain.block"><code>TensorRefinement.TensorTrain.block</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">block(U::Factor{T,N}, α::Int, β::Int) where {T&lt;:Number, N}</code></pre><p>Extracts a specific block from the factor <code>U</code> based on the provided rank indices <code>α</code> and <code>β</code>.</p><p>Detailed description: Function reshapes given factor into 3D array, selects all entries along second dimension, where <code>α</code> and <code>β</code> specify the first and third dimension, and reshapes selected entries into a block with sizes equivalent to the mode dimensions of the initial array.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>α::Int</code>: Reference numbers for selecting the slice along the first rank dimension.</li><li><code>β::Int</code>: Reference numbers for selecting the slice along the second rank dimension.</li></ul><p><strong>Returns</strong></p><ul><li>A sub-array representing the block corresponding to the specified rank indices.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the indices <code>α</code> or <code>β</code> are out of range for the respective rank dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL331-L350">source</a></section><section><div><pre><code class="language-julia hljs">block(U::Dec{T,N}, α::Int, β::Int; major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Create a new block by selecting the first ranks of the first and last ranks of the last factor of the decomposition <code>U</code> specified by the indices <code>α</code> and <code>β</code>, contract all factors together and yield the resulting block.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, to copy and modify.</li><li><code>α::Int</code>: The index to select from the first rank.</li><li><code>β::Int</code>: The index to select from the last rank.</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major order for the operation; default is &quot;last&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: New factor type obtained by rank selection and contraction to a block.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL706-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorvcat" href="#TensorRefinement.TensorTrain.factorvcat"><code>TensorRefinement.TensorTrain.factorvcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorvcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T&lt;:Number, N, M}</code></pre><p>Vertically concatenate the factors <code>U</code>, <code>V</code>, and additional factors in <code>W</code> along the first rank dimension.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor to be concatenated. Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor to be concatenated. Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>W::Vararg{Factor{T,N},M}</code>: Additional factors to be concatenated, each of Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the vertical concatenation of <code>U</code>, <code>V</code>, and the additional factors in <code>W</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the factors have incompatible mode sizes or second ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL365-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorhcat" href="#TensorRefinement.TensorTrain.factorhcat"><code>TensorRefinement.TensorTrain.factorhcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorhcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T&lt;:Number, N, M}</code></pre><p>Horizontally concatenate the factors <code>U</code>, <code>V</code>, and additional factors in <code>W</code> along the second rank dimension.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor to be concatenated. Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor to be concatenated. Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>W::Vararg{Factor{T,N},M}</code>: Additional factors to be concatenated, each of Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the horizontal concatenation of <code>U</code>, <code>V</code>, and the additional factors in <code>W</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the factors have incompatible mode sizes or first ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL396-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factordcat" href="#TensorRefinement.TensorTrain.factordcat"><code>TensorRefinement.TensorTrain.factordcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factordcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T&lt;:Number, N, M}</code></pre><p>Concatenate the factors <code>U</code>, <code>V</code>, and additional factors in <code>W</code> along the mode dimensions and the second rank dimension.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor to be concatenated. Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor to be concatenated. Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>W::Vararg{Factor{T,N},M}</code>: Additional factors to be concatenated, each of Of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the concatenation of <code>U</code>, <code>V</code>, and the additional factors in <code>W</code> along the mode dimensions and the second rank dimension.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the factors have incompatible mode sizes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL428-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorltcat" href="#TensorRefinement.TensorTrain.factorltcat"><code>TensorRefinement.TensorTrain.factorltcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorltcat(U₁₁::Factor{T,N}, U₂₁::Factor{T,N}, U₂₂::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Concatenate three factors <code>U₁₁</code>, <code>U₂₁</code>, and <code>U₂₂</code> in a lower triangular block matrix form.</p><p><strong>Arguments</strong></p><ul><li><code>U₁₁::Factor{T,N}</code>: First factor for the upper left block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₂₁::Factor{T,N}</code>: Second factor for the lower left block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₂₂::Factor{T,N}</code>: Third factor for the lower right block, with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor representing the lower triangular concatenation of <code>U₁₁</code>, <code>U₂₁</code>, and <code>U₂₂</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the factors are incompatible in mode size or rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL490-L505">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorutcat" href="#TensorRefinement.TensorTrain.factorutcat"><code>TensorRefinement.TensorTrain.factorutcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorutcat(U₁₁::Factor{T,N}, U₁₂::Factor{T,N}, U₂₂::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Concatenate three factors <code>U₁₁</code>, <code>U₁₂</code>, and <code>U₂₂</code> in an upper triangular block matrix form.</p><p><strong>Arguments</strong></p><ul><li><code>U₁₁::Factor{T,N}</code>: First factor for the upper left block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₁₂::Factor{T,N}</code>: Second factor for the upper right block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₂₂::Factor{T,N}</code>: Third factor for the lower right block, with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor representing the upper triangular concatenation of <code>U₁₁</code>, <code>U₁₂</code>, and <code>U₂₂</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the factors are incompatible in mode size or rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL456-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorranktranspose" href="#TensorRefinement.TensorTrain.factorranktranspose"><code>TensorRefinement.TensorTrain.factorranktranspose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorranktranspose(U::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Transpose the rank dimensions of the factor <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor with the rank dimensions of <code>U</code> transposed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL524-L534">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormodetranspose" href="#TensorRefinement.TensorTrain.factormodetranspose"><code>TensorRefinement.TensorTrain.factormodetranspose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormodetranspose(U::Factor{T,N}, π::NTuple{K,Int}) where {T&lt;:Number, N, K}</code></pre><p>Permute the mode dimensions of the factor <code>U</code> according to the permutation <code>π</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>π::NTuple{K,Int}</code>: Permutation of the mode dimensions of <code>U</code>. Should contain exactly <code>K = N - 2</code> elements, which are a valid permutation of <code>1:d</code> where <code>d</code> is the number of mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from permuting the mode dimensions of <code>U</code> according to <code>π</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> has fewer than one mode dimension.</li><li><code>ArgumentError</code>: If <code>π</code> is not a valid permutation of the mode dimensions of <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL541-L556">source</a></section><section><div><pre><code class="language-julia hljs">factormodetranspose(U::Factor{T,N}, π::Vector{Int}) where {T&lt;:Number,N}</code></pre><p>Permute the mode dimensions of the factor <code>U</code> according to the permutation <code>π</code>, where <code>π</code> is passed as a vector instead of a tuple.</p><p>Function acts as a wrapper around <code>factormodetranspose</code> to convert the vector <code>π</code> to a tuple and then call the main method.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>π::Vector{Int}</code>: Permutation of the mode dimensions of <code>U</code>. Should contain exactly <code>N - 2</code> elements to allow for permutation of the mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>New factor resulting from permuting the mode dimensions of <code>U</code> according to <code>π</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> has fewer than one mode dimension.</li><li><code>ArgumentError</code>: If <code>π</code> is not a valid permutation of the mode dimensions of <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL572-L589">source</a></section><section><div><pre><code class="language-julia hljs">factormodetranspose(U::Factor{T,2}) where {T&lt;:Number}</code></pre><p>Transpose the two dimensions of the factor <code>U</code>, assuming <code>U</code> has exactly two dimensions.</p><p>Function is a specialized version of <code>factormodetranspose</code> for the case when <code>U</code> has two dimensions. It transposes <code>U</code> by swapping the two dimensions, equivalent to the permutation <code>(2, 1)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,2}</code>: Two-dimensional factor with elements of type <code>T</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor obtained by transposing the two dimensions of <code>U</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> is not two-dimensional.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL592-L608">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormodereshape" href="#TensorRefinement.TensorTrain.factormodereshape"><code>TensorRefinement.TensorTrain.factormodereshape</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormodereshape(U::Factor{T,N}, n::FactorSize) where {T&lt;:Number, N}</code></pre><p>Reshape the mode dimensions of the factor <code>U</code> to the specified sizes in <code>n</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>n::FactorSize</code>: Vector specifying the new sizes for the mode dimensions. Product of <code>n</code> must equal the product of current mode sizes of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from reshaping the mode dimensions of <code>U</code> to <code>n</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the product of <code>n</code> does not equal the product of the current mode sizes of <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL611-L625">source</a></section><section><div><pre><code class="language-julia hljs">factormodereshape(U::Factor{T,N}, n::Vector{Any}) where {T&lt;:Number,N}</code></pre><p>Reshape the mode dimensions of the factor <code>U</code> to the specified sizes in <code>n</code>, which defaults to an empty vector if <code>n</code> is of type <code>Vector{Any}</code>.</p><p>Function acts as a specialized version of <a href="index.html#TensorRefinement.TensorTrain.factormodereshape"><code>factormodereshape</code></a> where the input vector <code>n</code> is replaced with an empty <code>Vector{Int}()</code>. </p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>n::Vector{Any}</code>: Vector specifying the new sizes for the mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped factor where the mode dimensions are modified, which defaults to use an empty vector of integers for mode reshaping.</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the product of <code>n</code> does not equal the product of the current mode sizes of <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL635-L651">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factordiagm" href="#TensorRefinement.TensorTrain.factordiagm"><code>TensorRefinement.TensorTrain.factordiagm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factordiagm(U::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Create a tensor with diagonal properties from the factor <code>U</code> by placing the elements of <code>U</code> along the diagonal of a larger-dimensional tensor.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor that represents a tensor with diagonal properties constructed from <code>U</code>, dimensions expanded.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> has fewer than one mode dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL654-L668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorcontract" href="#TensorRefinement.TensorTrain.factorcontract"><code>TensorRefinement.TensorTrain.factorcontract</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorcontract(U::Factor{T,N}, V::Factor{T,N}; rev::Bool=false, major::String=&quot;last&quot;) where {T&lt;:Number, N}</code></pre><p>Contract two factors <code>U</code> and <code>V</code> along their shared rank dimensions. Function supports contracting in different orientations and orders based on parameters <code>rev</code> and <code>major</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>rev::Bool=false</code>: If <code>true</code>, reverse the roles of <code>U</code> and <code>V</code> in the contraction.</li><li><code>major::String=&quot;last&quot;</code>: Specifies major contraction order. Must be either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from contracting <code>U</code> and <code>V</code> along their shared rank dimensions.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have inconsistent ranks</li><li><code>ArgumentError</code>: If <code>major</code> is not <code>&quot;last&quot;</code> or <code>&quot;first&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL683-L700">source</a></section><section><div><pre><code class="language-julia hljs">factorcontract(U::Factor{T,N}, V::S) where {T&lt;:Number, N, S&lt;:AbstractMatrix{T}}</code></pre><p>Contract a factor <code>U</code> with a matrix <code>V</code>, aligning the rank dimensions and performing matrix multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::S</code>: Matrix of type <code>S</code> and elements of type <code>T</code> to contract with <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the contraction of <code>U</code> with <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have inconsistent ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL726-L740">source</a></section><section><div><pre><code class="language-julia hljs">factorcontract(U::S, V::Factor{T,N}) where {T&lt;:Number, N, S&lt;:AbstractMatrix{T}}</code></pre><p>Contracts a matrix <code>U</code> with a factor <code>V</code>, aligning the rank dimensions and performing matrix multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>U::S</code>: Matrix of type <code>S</code> and elements of type <code>T</code> to contract with <code>V</code>.</li><li><code>V::Factor{T,N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the contraction of <code>U</code> with <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have inconsistent ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL753-L767">source</a></section><section><div><pre><code class="language-julia hljs">factorcontract(U::S, V::R) where {T&lt;:Number, S&lt;:AbstractMatrix{T}, R&lt;:AbstractMatrix{T}}</code></pre><p>Perform a matrix multiplication (contraction) of two factors <code>U</code> and <code>V</code>, which are matrices.</p><p><strong>Arguments</strong></p><ul><li><code>U::S</code>: First input matrix of type <code>AbstractMatrix{T}</code> with elements of type <code>T</code>.</li><li><code>V::R</code>: Second input matrix of type <code>AbstractMatrix{T}</code> with elements of type <code>T</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The result of matrix multiplication <code>U * V</code>, which contracts the two input matrices.</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the number of columns in <code>U</code> does not match the number of rows in <code>V</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL780-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormp" href="#TensorRefinement.TensorTrain.factormp"><code>TensorRefinement.TensorTrain.factormp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T&lt;:Number, N₁, N₂}</code></pre><p>Perform a mode-wise multiplication (contraction) of two factors <code>U₁</code> and <code>U₂</code> along specified modes <code>σ₁</code> and <code>σ₂</code>. Operation contracts the specified modes, while the remaining dimensions of the factors are combined.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::Factor{T,N₁}</code>: First factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N₁</code> dimensions.</li><li><code>σ₁::Indices</code>: Reference numbers specifying which modes of <code>U₁</code> to use in the contraction. Can be a vector of integers or an empty vector.</li><li><code>U₂::Factor{T,N₂}</code>: Second factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N₂</code> dimensions.</li><li><code>σ₂::Indices</code>: Reference numbers specifying which modes of <code>U₂</code> to use in the contraction. Can be a vector of integers or an empty vector.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the mode-wise multiplication of <code>U₁</code> and <code>U₂</code>, with contracted modes combined and the remaining dimensions preserved.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>σ₁</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If <code>σ₂</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If the specified sets of modes of σ₁ and σ₂ are inconsistent.</li><li><code>ArgumentError</code>: If the set of modes of <code>U₁</code> is specified incorrectly.</li><li><code>ArgumentError</code>: If the set of modes of U₂ is specified incorrectly.</li><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> are inconsistent with respect to the specified modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL798-L820">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorkp" href="#TensorRefinement.TensorTrain.factorkp"><code>TensorRefinement.TensorTrain.factorkp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorkp(U::Union{Factor{T,N}, Pair{Factor{T,N},Int}}, V::Vararg{Union{Factor{T,N}, Pair{Factor{T,N},Int}},M}) where {T&lt;:Number,N,M}</code></pre><p>Perform a Kronecker product of multiple factors (optionally raised to specified nonnegative integer exponents).</p><p><strong>Arguments</strong></p><ul><li><code>U::Union{Factor{T, N}, Pair{Factor{T, N}, Int}}</code>: first factor can either be a <code>Factor</code> type or a pair <code>(Factor, Int)</code>. If given as a pair, the integer is the exponent for the respective factor in the Kronecker product.</li><li><code>V::Vararg{Union{Factor{T, N}, Pair{Factor{T, N}, Int}}, M}</code>: variable number (denoted by M) of additional factors, each of which can also be either a <code>Factor</code> type or a pair <code>(Factor, Int)</code>. The same usage for the integer applies as in the above line.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: resulting tensor (or matrix if d = 0) after the Kronecker products of all provided factors (with optionally some factors exponentiated). Final tensor is a result of a series of multiplications and reshaping operations.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If a negative exponent is provided in a pair <code>(Factor, Int)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL893-L907">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorhp" href="#TensorRefinement.TensorTrain.factorhp"><code>TensorRefinement.TensorTrain.factorhp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorhp(U::Factor{T,N}, V::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Compute the higher-order tensor product of two factors <code>U</code> and <code>V</code>. Resulting factor has dimensions formed by multiplying the ranks and mode sizes of <code>U</code> and <code>V</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped tensor representing the higher-order product of <code>U</code> and <code>V</code>, with dimensions <code>(p * r, n..., q * s)</code> where:<ul><li><code>(p, q)</code> are the ranks of <code>U</code>.</li><li><code>(r, s)</code> are the ranks of <code>V</code>.</li><li><code>n</code> represents the mode sizes of <code>U</code> and <code>V</code>.</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> do not have the same mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL955-L972">source</a></section><section><div><pre><code class="language-julia hljs">factorhp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T&lt;:Number, N₁, N₂}</code></pre><p>Compute the higher-order tensor product of two factors <code>U₁</code> and <code>U₂</code> along specified modes <code>σ₁</code> and <code>σ₂</code>. Function allows for a flexible contraction over selected modes.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::Factor{T,N₁}</code>: First factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N₁</code> dimensions.</li><li><code>σ₁::Indices</code>: Reference numbers specifying which modes of <code>U₁</code> to use in the contraction. Can be a vector of integers or an empty vector.</li><li><code>U₂::Factor{T,N₂}</code>: Second factor of type <code>Factor</code> with elements of type <code>T</code> and <code>N₂</code> dimensions.</li><li><code>σ₂::Indices</code>: Reference numbers specifying which modes of <code>U₂</code> to use in the contraction. Can be a vector of integers or an empty vector.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped tensor representing the higher-order product of <code>U₁</code> and <code>U₂</code>, contracted over the specified modes.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If <code>σ₁</code> or <code>σ₂</code> are incorrectly specified or inconsistent with the dimensions of <code>U₁</code> or <code>U₂</code>.</li><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> are inconsistent with respect to the specified modes.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If <code>σ₁</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If <code>σ₂</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If the specified sets of modes of <code>σ₁</code> and <code>σ₂</code> are inconsistent.</li><li><code>ArgumentError</code>: If the set of modes of <code>U₁</code> is specified incorrectly.</li><li><code>ArgumentError</code>: If the set of modes of <code>U₂</code> is specified incorrectly.</li><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> are inconsistent with respect to the specified modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL987-L1014">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorqr!" href="#TensorRefinement.TensorTrain.factorqr!"><code>TensorRefinement.TensorTrain.factorqr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorqr!(U::Factor{T,N}; rev::Bool=false, factf=(rev ? A -&gt; LinearAlgebra.lq!(A) : A -&gt; LinearAlgebra.qr!(A))) where {T&lt;:FloatRC, N}</code></pre><p>Perform a QR or LQ factorization of the tensor <code>U</code>, depending on the value of the keyword argument <code>rev</code> (reverse). </p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: mutable factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li><li><code>rev::Bool=false</code>: keyword argument that determines the type of factorization. If <code>false</code>, performs a QR factorization; if <code>true</code>, performs an LQ factorization.</li><li><code>factf</code>: keyword argument that specifies the chosen factorization function. By default, <code>LinearAlgebra.qr!</code> and <code>LinearAlgebra.lq!</code> are used respectively (depending on <code>rev</code>).</li></ul><p><strong>Returns</strong></p><ul><li>tuple <code>(U, R)</code>, where:<ul><li><code>U</code>: transformed tensor after applying the QR or LQ factorization. (N-dimensional)</li><li><code>R</code>: factor tensor obtained by reshaping the factor matrix of the QR or LQ factorization (N-dimensional)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL1122-L1136">source</a></section><section><div><pre><code class="language-julia hljs">factorqr!(U::Factor{T,N}, ::Val{false}; rev::Bool=false) where {T&lt;:FloatRC{&lt;:AbstractFloat},N}</code></pre><p>Perform an in-place QR or LQ factorization of the factor <code>U</code>, depending on the value of the keyword argument <code>rev</code> (reverse). This variant uses the <code>Val{false}</code> signature for the default QR factorization.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Mutable factor of type <code>Factor</code> with elements of type <code>T</code> (a subtype of <code>FloatRC</code>) and <code>N</code> dimensions.</li><li><code>rev::Bool=false</code>: Keyword argument that specifies whether to perform an LQ factorization (<code>true</code>) or a QR factorization (<code>false</code>, default).</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(U, R)</code> where:<ul><li><code>U</code>: Transformed tensor after applying the QR or LQ factorization.</li><li><code>R</code>: Factor tensor obtained by reshaping the factor matrix of the factorization.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL1161-L1174">source</a></section><section><div><pre><code class="language-julia hljs">factorqr!(U::Factor{T,N}, ::Val{true}; rev::Bool=false, returnS::Bool=false,
          factf=(A -&gt; LinearAlgebra.qr!(A, LinearAlgebra.ColumnNorm()))) where {T&lt;:FloatRC, N}</code></pre><p>Perform a QR factorization of the factor <code>U</code> with optional pivoting and the ability to return an additional factor <code>S</code>. The function can cope with different orientations (via <code>rev</code>) and supports custom factorization functions.</p><p><strong>Arguments</strong></p><ul><li><p><code>U::Factor{T,N}</code>: Factor to be decomposed, of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> dimensions.</p></li><li><p><code>::Val{true}</code>: Value type that indicates that this version of <code>factorqr!</code> should be used when <code>returnS</code> is needed.</p></li><li><p><code>rev::Bool=false</code>: Keyword argument that determines the orientation of the QR factorization.</p><ul><li><code>false</code> (default): Standard QR factorization is performed.</li><li><code>true</code>: Roles of rows and columns are reversed, affecting the orientation of the factorization.</li></ul></li><li><p><code>returnS::Bool=false</code>: Keyword argument that specifies whether to return an additional factor <code>S</code> such that <code>A ⨝ S = Q</code> if <code>rev == false</code> and <code>S ⨝ A = Q</code> if <code>rev == true</code>.</p></li><li><p><code>factf</code>: Function used to perform the QR factorization, default is set to <code>LinearAlgebra.qr!</code> with column pivoting.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Q, R</code>: Factors <code>Q</code> (orthogonal) and <code>R</code> (upper triangular) from the QR decomposition.</li><li><code>Q, R, S</code>: If <code>returnS == true</code>, returns an additional factor <code>S</code> along with <code>Q</code> and <code>R</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL1177-L1199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorqradd" href="#TensorRefinement.TensorTrain.factorqradd"><code>TensorRefinement.TensorTrain.factorqradd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorqradd(Q::Factor{T,N}, R::Union{Factor{T,N},Nothing}, U::Factor{T,N}; rev::Bool=false) where {T&lt;:FloatRC, N}</code></pre><p>Add rows or columns to an orthogonal factor <code>Q</code> and its corresponding upper triangular factor <code>R</code>, depending on the value of <code>rev</code>. This function is an extension to the QR factorization by updating the factors to incorporate a new matrix <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>Q::Factor{T,N}</code>: Orthogonal factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and <code>N</code> dimensions.</p><ul><li>If <code>rev == true</code>, <code>Q</code> is assumed to be orthogonal with respect to the first rank.</li><li>If <code>rev == false</code>, <code>Q</code> is assumed to be orthogonal with respect to the second rank.</li></ul></li><li><p><code>R::Union{Factor{T,N},Nothing}</code>: Upper triangular factor of the QR factorization. Can be of type <code>Factor</code> or <code>Nothing</code>.</p><ul><li>If <code>R</code> is <code>Nothing</code>, an identity matrix of appropriate dimensions will be used.</li></ul></li><li><p><code>U::Factor{T,N}</code>: New matrix to be added to the existing factors (same mode dimensions as <code>Q</code>).</p></li><li><p><code>rev::Bool=false</code>: Keyword argument indicating the direction of orthogonality for the operation. </p><ul><li><code>false</code> (default): Assumes <code>Q</code> to be orthogonal with respect to the second rank, and columns will be added.</li><li><code>true</code>: Assumes <code>Q</code> to be orthogonal with respect to the first rank, and rows will be added.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Q</code>: Updated orthogonal factor after incorporating <code>U</code>.</li><li><code>R</code>: Updated upper triangular factor after incorporating <code>U</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the mode sizes of <code>Q</code> and <code>U</code> are incompatible.</li><li><code>ArgumentError</code>: If <code>R</code> has incompatible rank or mode dimensions with <code>Q</code>.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> are incompatible in their respective ranks.</li><li><code>ArgumentError</code>: If <code>R</code> is specified and has an incompatible number of mode dimensions or rank.</li></ul><p>Extended Error List:</p><ul><li><code>ArgumentError</code>: If the mode sizes of <code>Q</code> and <code>U</code> are incompatible.</li><li><code>ArgumentError</code>: If <code>R</code> and <code>Q</code> have incompatible number of mode dimensions or incompatible number of unitary mode sizes.</li><li><code>ArgumentError</code>: If <code>R</code> and <code>Q</code> have incompatible rank.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> have incompatible second rank.</li><li><code>ArgumentError</code>: If <code>R</code>  has a different number of mode dimensions as Q or different unitary mode sizes.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>R</code> have incompatible rank.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> have incompatible first rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL1256-L1295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorsvd!" href="#TensorRefinement.TensorTrain.factorsvd!"><code>TensorRefinement.TensorTrain.factorsvd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorsvd!(W::Factor{T,N},
           m::Union{FactorSize,Colon},
           n::Union{FactorSize,Colon};
           soft::S=zero(S),
           hard::S=zero(S),
           atol::S=zero(S),
           rtol::S=zero(S),
           rank::Int=0,
           major::String=&quot;last&quot;,
           rev::Bool=false,
           factf=(A -&gt; LinearAlgebra.svd!(A; full=false, alg=LinearAlgebra.QRIteration())) )
 where {S&lt;:AbstractFloat,T&lt;:FloatRC{S},N}</code></pre><p>Perform a singular value decomposition (SVD) of the factor <code>W</code> where the factor dimensions are adjusted accordingly and optional thresholding is carried out based on specified parameters. </p><p><strong>Arguments</strong></p><ul><li><code>W::Factor{T, N}</code>: Input factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and <code>N</code> dimensions.</li><li><code>m::Union{FactorSize, Colon}</code>: Mode-size parameter for first dimension. Can be a <a href="index.html#TensorRefinement.TensorTrain.FactorSize"><code>FactorSize</code></a> vector specifying the sizes of the mode dimensions or <code>Colon</code> to represent all indices.</li><li><code>n::Union{FactorSize, Colon}</code>: Mode-size parameter for second dimension. Can also be a <a href="index.html#TensorRefinement.TensorTrain.FactorSize"><code>FactorSize</code></a> vector or <code>Colon</code>.</li><li><code>soft::S=zero(S)</code>: Keyword argument specifying the soft threshold for singular value truncation. Must be nonnegative and finite.</li><li><code>hard::S=zero(S)</code>: Keyword argument specifying the hard threshold for singular value truncation. Must be nonnegative and finite.</li><li><code>atol::S=zero(S)</code>: Absolute tolerance for singular values. Must be nonnegative and finite.</li><li><code>rtol::S=zero(S)</code>: Relative tolerance for singular values. Must be nonnegative and finite.</li><li><code>rank::Int=0</code>: Maximum allowable rank for the truncated SVD. Must be nonnegative.</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major contraction order. Must be either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li><li><code>rev::Bool=false</code>: Boolean indicating whether to reverse the dimensions in the output.</li><li><code>factf</code>: Function used to perform the SVD. Default sets it to a function using <code>LinearAlgebra.svd!</code> with <code>QRIteration</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: The left singular vectors after applying SVD, reshaped based on the specified parameters (and potentially truncated).</li><li><code>V</code>: The right singular vectors after applying SVD, reshaped similarly (and also potentially truncated).</li><li><code>ε</code>: The effective noise level that stems from thresholding.</li><li><code>δ</code>: The relative noise level, calculated as <code>ε / μ</code>.</li><li><code>μ</code>: The norm of the input factor <code>W</code>.</li><li><code>ρ</code>: The rank of the truncated SVD.</li><li><code>σ</code>: A vector of the singular values (after thresholding).</li></ul><p><strong>Throws</strong></p><p>Summarized Error List:</p><ul><li><code>ArgumentError</code>: If both <code>m</code> and <code>n</code> are specified as <code>Colon</code>, this causes ambiguity.</li><li><code>ArgumentError</code>: If either <code>m</code> or <code>n</code> is specified with non-positive or inconsistent dimensions.</li><li><code>ArgumentError</code>: If <code>major</code> is not <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li><li><code>ArgumentError</code>: If <code>soft</code>, <code>hard</code>, <code>atol</code>, or <code>rtol</code> are negative or not finite.</li><li><code>ArgumentError</code>: If <code>rank</code> is negative.</li><li><code>DimensionMismatch</code>: If mode-size vectors <code>m</code> and <code>n</code> are inconsistent with dimensions of <code>W</code>.</li><li><code>ErrorException</code>: If numerical issues such as overflow or underflow occur during computations.</li></ul><p>Full Error List:</p><ul><li><p><code>ArgumentError</code>: If both <code>m</code> and <code>n</code> are specified as <code>Colon</code>, this causes ambiguity.</p></li><li><p><code>ArgumentError</code>: If the elements of the first mode-size vector are not positive.</p></li><li><p><code>ArgumentError</code>: If the elements of the second mode-size vector are not positive.</p></li><li><p><code>ArgumentError</code>: If <code>major</code> is neither &quot;last&quot; (default) nor &quot;first&quot;.</p></li><li><p><code>ArgumentError</code>: If <code>soft</code> is negative or infinite.</p></li><li><p><code>ArgumentError</code>: If <code>hard</code> is negative or finite.</p></li><li><p><code>ArgumentError</code>: If <code>atol</code> is negative or infinte.</p></li><li><p><code>ArgumentError</code>:  If <code>rtol</code> is negative or infinte.</p></li><li><p><code>ArgumentError</code>: If optional argument rank is negative.</p></li><li><p><code>DimensionMismatch</code>: If the number of entries in the first mode-size vector is inconsistent with the specified factor.</p></li><li><p><code>DimensionMismatch</code>: If the number of entries in the second mode-size vector is inconsistent with the specified factor.</p></li><li><p><code>DimensionMismatch</code>: If not every mode dimension of W is divisible by the corresponding element of the specified mode-size vector</p></li><li><p><code>DimensionMismatch</code>: If specified mode-size vectors are inconsistent with the specified factor.</p></li><li><p><code>ErrorException</code>: If squaring <code>soft</code> leads to overflow and it was passed finite.</p></li><li><p><code>ErrorException</code>: If squaring <code>soft</code> leads to underflow and it was passed positive.</p></li><li><p><code>ErrorException</code>: If sqauring <code>hard</code> leads to overflow and it was passed finite.</p></li><li><p><code>ErrorException</code>: If squaring <code>hard</code> leads to underflow and it was passed positive.</p></li><li><p><code>ErrorException</code>: If squaring <code>atol</code> leads to overflow and it was passed finite.</p></li><li><p><code>ErrorException</code>: If squaring <code>atol</code> leads to underflow and it was passed positive.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactor.jl#LL1363-L1434">source</a></section></article><h1 id="TensorTrainFactorization"><a class="docs-heading-anchor" href="#TensorTrainFactorization">TensorTrainFactorization</a><a id="TensorTrainFactorization-1"></a><a class="docs-heading-anchor-permalink" href="#TensorTrainFactorization" title="Permalink"></a></h1><p>This section covers functions related to the TensorTrainFactorization module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.DecSize" href="#TensorRefinement.TensorTrain.DecSize"><code>TensorRefinement.TensorTrain.DecSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>DecSize</code> is an alias for a Matrix with integer entries of type <code>Matrix{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.DecRank" href="#TensorRefinement.TensorTrain.DecRank"><code>TensorRefinement.TensorTrain.DecRank</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>DecRank</code> is an alias for a Vector with integer entries of type <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.Dec" href="#TensorRefinement.TensorTrain.Dec"><code>TensorRefinement.TensorTrain.Dec</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Dec</code> is an alias for a <code>Vector{Factor{T,N}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.VectorDec" href="#TensorRefinement.TensorTrain.VectorDec"><code>TensorRefinement.TensorTrain.VectorDec</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>VectorDec{T}</code> is an alias for Vector{VectorFactor{T}}`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL29-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.MatrixDec" href="#TensorRefinement.TensorTrain.MatrixDec"><code>TensorRefinement.TensorTrain.MatrixDec</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>MatrixDec{T}</code> is an alias for Vector{MatrixFactor{T}}`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.checkndims" href="#TensorRefinement.TensorTrain.checkndims"><code>TensorRefinement.TensorTrain.checkndims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkndims(d::Int)</code></pre><p>Check the correctness of the numbers of dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>d::Int</code>: Input dimension.</li></ul><p><strong>Returns</strong></p><ul><li>No Return. Function merely flags negative dimensions.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>d</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL39-L52">source</a></section><section><div><pre><code class="language-julia hljs">checkndims(d::Vector{Int})</code></pre><p>Check whether a given vector exhibits uniform values.</p><p><strong>Arguments</strong></p><ul><li><code>d::Vector{Int}</code>: Input vector of integers.</li></ul><p><strong>Returns</strong></p><ul><li>No Return. Function merely flags incorrent vectors.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>d</code> does not contain elements.</li><li><code>BoundsError</code>: If the elements of <code>d</code> are negative or zero.</li><li><code>ArgumentError</code>: If the values in the dimension vector differ.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL79-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.checklength" href="#TensorRefinement.TensorTrain.checklength"><code>TensorRefinement.TensorTrain.checklength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checklength(L::Int)</code></pre><p>Check the correctness of the length L.</p><p><strong>Arguments</strong></p><ul><li><code>L::Int</code>: Input length.</li></ul><p><strong>Returns</strong></p><ul><li>No Return. Function merely flags negative length.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL59-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.checksize" href="#TensorRefinement.TensorTrain.checksize"><code>TensorRefinement.TensorTrain.checksize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checksize(n::DecSize; len::Int=0, dim::Int=0)</code></pre><p>Check the correctness of a given size matrix with integer entries (Type: Decsize).</p><p><strong>Arguments</strong></p><ul><li><code>n::DecSize</code>: Input size matrix with integer entries.</li><li><code>len::Int=0</code>: Length of the size matrix. By default, it is 0.</li><li><code>dim::Int=0</code>: Dimension of the size matrix. By default, it is 0.</li></ul><p><strong>Returns</strong></p><ul><li>No Return. Function merely flags incorrent size matrix.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>n</code> does not contain elements.</li><li><code>ArgumentError</code>: If <code>n</code> contains negative or zero elements.</li><li><code>ArgumentError</code>: If the number of factors is negative or zero.</li><li><code>ArgumentError</code>: If the number of mode dimensions is negative or zero.</li><li><code>ArgumentError</code>: If the number of rows is incorrect.</li><li><code>ArgumentError</code>: If the number of columns is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL108-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.checkrank" href="#TensorRefinement.TensorTrain.checkrank"><code>TensorRefinement.TensorTrain.checkrank</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkrank(r::DecRank; len::Int=0)</code></pre><p>Check the correctness of a given rank vector with integer entries (Type: DecRank).</p><p><strong>Arguments</strong></p><ul><li><code>r::DecRank</code>: Input rank vector with integer entries.</li><li><code>len::Int=0</code>: Length of the size matrix. By default, it is 0.</li></ul><p><strong>Returns</strong></p><ul><li>No Return. Function merely flags incorrent rank vectors.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>r</code> does not contain at least two elements.</li><li><code>ArgumentError</code>: If <code>r</code> contains negative elements.</li><li><code>ArgumentError</code>: If the number of elements in the rank vector is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL150-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.checkranks" href="#TensorRefinement.TensorTrain.checkranks"><code>TensorRefinement.TensorTrain.checkranks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkranks(p::Vector{Int}, q::Vector{Int}; len::Int=0)</code></pre><p>Check the correctness of two given rank vectors with integer entries.</p><p><strong>Arguments</strong></p><ul><li><code>p::Vector{Int}</code>: First input vector with integer entries.</li><li><code>q::Vector{Int}</code>: Second input vector with integer entries.</li><li><code>len::Int=0</code>: Length of the vectors. By default, it is 0.</li></ul><p><strong>Returns</strong></p><ul><li>No Return. Function merely flags incorrent rank vectors.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>p</code> and <code>q</code> do not have the same length.</li><li><code>ArgumentError</code>: If <code>p</code> or <code>q</code> contain negative elements.</li><li><code>ArgumentError</code>: If the number of elements in the rank vectors is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL179-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.declength" href="#TensorRefinement.TensorTrain.declength"><code>TensorRefinement.TensorTrain.declength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function declength(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Check the correctness of two given rank vectors with integer entries.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of <code>N</code> Factors of type <code>Factor</code>.</li></ul><p><strong>Returns</strong></p><ul><li>An integer: the length of the decomposition.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>L</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL212-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decndims" href="#TensorRefinement.TensorTrain.decndims"><code>TensorRefinement.TensorTrain.decndims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decndims(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Return the number of contraction dimensions of the decomposition.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <a href="index.html#TensorRefinement.TensorTrain.Dec"><code>Dec</code></a> with elements of type <code>T</code> and with <code>N</code> as the number of factors.</li></ul><p><strong>Returns</strong></p><ul><li>An integer representing the number of contraction dimensions, which is <code>N - 2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL232-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decsize" href="#TensorRefinement.TensorTrain.decsize"><code>TensorRefinement.TensorTrain.decsize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decsize(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Return a matrix representing the mode sizes of each factor in the decomposition <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix of integers, where each column represents the different mode sizes for each factor contained in the decomposition <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL245-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decranks" href="#TensorRefinement.TensorTrain.decranks"><code>TensorRefinement.TensorTrain.decranks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decranks(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Return two vectors, which represent the first and last ranks, respectively, of each factor in the decomposition type <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>Two vectors of length L: <code>p</code> and <code>q</code> where <code>p[ℓ]</code> is the first rank and <code>q[ℓ]</code> is the last rank of the ℓ-th factor in <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL267-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decrank" href="#TensorRefinement.TensorTrain.decrank"><code>TensorRefinement.TensorTrain.decrank</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decrank(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Return a vector of ranks by combining all first ranks of the factors of <code>U</code> and appending the last rank of the last factor in the decomposition at the end of the vector.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A vector containing the first rank of each factor in <code>U</code> as well as the last rank of the last factor in the decomposition.</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the factors in <code>U</code> have inconsistent ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL290-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.dec" href="#TensorRefinement.TensorTrain.dec"><code>TensorRefinement.TensorTrain.dec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dec(::Type{T}, d::Int, L::Int) where {T&lt;:Number}</code></pre><p>Create an empty decomposition with <code>L</code> factors, with each factor exhibiting <code>d</code> mode dimensions and entries of data type <code>T</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Data type of the elements in each factor.</li><li><code>d::Int</code>: Number of mode dimensions.</li><li><code>L::Int</code>: Number of factors.</li></ul><p><strong>Returns</strong></p><ul><li>Vector of uninitialized arrays representing the decomposition.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>d</code> or <code>L</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL312-L327">source</a></section><section><div><pre><code class="language-julia hljs">dec(d::Int, L::Int)</code></pre><p>Create an empty decomposition with <code>L</code> factors, with each factor exhibiting <code>d</code> mode dimensions and entries of default data type <code>Float64</code>.</p><p><strong>Arguments</strong></p><ul><li><code>d::Int</code>: Number of mode dimensions.</li><li><code>L::Int</code>: Number of factors.</li></ul><p><strong>Returns</strong></p><ul><li>Vector of uninitialized arrays representing the decomposition, with entries of default data type <code>Float64</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>d</code> or <code>L</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL335-L349">source</a></section><section><div><pre><code class="language-julia hljs">dec(::Type{T}, d::Int) where {T&lt;:Number}</code></pre><p>Create an empty decomposition with zero factors, each having <code>d</code> mode dimensions and data type <code>T</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Data type of the elements in each factor.</li><li><code>d::Int</code>: Number of mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>Vector of uninitialized arrays representing an empty decomposition.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>d</code> is invalid (i.e., if <code>d</code> is negative).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL352-L366">source</a></section><section><div><pre><code class="language-julia hljs">dec(d::Int)</code></pre><p>Create an empty decomposition with zero factors, each having <code>d</code> mode dimensions and default data type <code>Float64</code>.</p><p><strong>Arguments</strong></p><ul><li><code>d::Int</code>: Number of mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>Vector of uninitialized arrays representing an empty decomposition with default data type <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL372-L382">source</a></section><section><div><pre><code class="language-julia hljs">dec(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Return the decomposition <code>U</code> as is.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>The decomposition object <code>U</code> as is.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL385-L395">source</a></section><section><div><pre><code class="language-julia hljs">dec(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T&lt;:Number}</code></pre><p>Create a decomposition with specified size, rank, and further optional parameters.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Data type of the elements in each factor.</li><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> was not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> was not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of arrays representing the decomposition with each factor exibiting the size and rank specified in advance.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the rank is not a nonnegative integer or a vector of such</li><li><code>ArgumentError</code>: If the rank parameter does not contain at least two entries, when the rank parameter is specified as a vector.</li><li><code>ArgumentError</code>: If the rank parameter does not contain L+1 entries, when the size parameter is specified as a matrix with L columns and the rank parameter is specified as a vector.</li><li><code>ArgumentError</code>: If the first rank, when specified separately, is not positive.</li><li><code>ArgumentError</code>: If the last rank, when specified separately, is not positive.</li><li><code>ArgumentError</code>: If the first and last ranks are specified separately, even though the rank parameter is not specified as an integer.</li><li><code>ArgumentError</code>: If the number of factors, when specified, is not positive.</li><li><code>ArgumentError</code>: If the number of rows in the size matrix and the number of factors are not equal, when the number of rows in the size matrix is larger than one and the number of factors is specified.</li><li><code>ArgumentError</code>: If <code>len</code> is not equal to L, when the rank parameter is specified as a vector with L+1 entries and the number of factors len is specified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL400-L426">source</a></section><section><div><pre><code class="language-julia hljs">dec(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)</code></pre><p>Create a decomposition with default type <code>Float64</code> using the specified size, rank, and optional parameters.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> with <code>Float64</code> elements and the specified sizes, ranks, and parameters.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If invalid size, rank, or other parameters are provided (see detailed error control in the <a href="index.html#TensorRefinement.TensorTrain.dec"><code>dec</code></a> function with type specification).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL480-L497">source</a></section><section><div><pre><code class="language-julia hljs">dec(U::Factor{T,N}; len::Int=1) where {T&lt;:Number,N}</code></pre><p>Create a decomposition type <code>Dec</code> (vector of factors) with a specified length, each factor being a copy of the factor <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Factor, whose entries are in <code>T</code> and with <code>N</code> dimensions, to use for creating the decomposition type.</li><li><code>len::Int=1</code>: Length of the created decomposition, whose factors are copies of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li>Decomposition type whose factors consist of copies of <code>U</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the number of factors <code>len</code>, when specified, is not positive.</li><li><code>ArgumentError</code>: If the two ranks of <code>U</code> are not equal when the number of factors <code>len</code> is specified as larger than one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL515-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.dec!" href="#TensorRefinement.TensorTrain.dec!"><code>TensorRefinement.TensorTrain.dec!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dec!(U::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Convert a single factor <code>U</code> into a decomposition object containing merely that factor.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Factor of type <code>factor</code> to be turned into a decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>Decomposition object <code>Dec{T,N}</code> containing the single factor <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL500-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.vector" href="#TensorRefinement.TensorTrain.vector"><code>TensorRefinement.TensorTrain.vector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Return the decomposition <code>U</code> as is; since a decomposition type (vector of factors) is already a vector. </p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition, whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>The input decomposition object <code>U</code> as is. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL547-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decrankselect!" href="#TensorRefinement.TensorTrain.decrankselect!"><code>TensorRefinement.TensorTrain.decrankselect!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decrankselect!(U::Dec{T,N}, α::Indices, β::Indices) where {T&lt;:Number,N}</code></pre><p>Select the first rank dimensions of the first factor and the last rank dimensions of the last factor in the decomposition <code>U</code> based on the provided indices <code>α</code> and <code>β</code>, modifying <code>U</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition, whose entries are in <code>T</code> and with <code>N</code> dimensions, to select ranks from.</li><li><code>α::Indices</code>: Reference numbers for selecting the first rank dimensions of the first factor of <code>U</code>.</li><li><code>β::Indices</code>: Reference numbers for selecting the last rank dimensions of the last factor of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Decomposition type <code>Dec</code>, with the selected ranks. </li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decomposition is empty, or if <code>α</code> or <code>β</code> contain invalid or empty ranges.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If the range for the first rank is empty.</li><li><code>ArgumentError</code>: If the range for the first rank is incorrect.</li><li><code>ArgumentError</code>: If the range for the second rank is empty.</li><li><code>ArgumentError</code>: If the range for the second rank is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL562-L584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decrankselect" href="#TensorRefinement.TensorTrain.decrankselect"><code>TensorRefinement.TensorTrain.decrankselect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decrankselect(U::Dec{T,N}, α::Indices, β::Indices) where {T&lt;:Number,N}</code></pre><p>Create a new decomposition object by selecting the first rank dimensions of the first factor and the last rank dimensions of the last factor in the decomposition <code>U</code> based on the provided indices <code>α</code> and <code>β</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition, whose entries are in <code>T</code> and with <code>N</code> dimensions, to select ranks from.</li><li><code>α::Indices</code>: Reference numbers for selecting the first rank dimensions of the first factor of <code>U</code>.</li><li><code>β::Indices</code>: Reference numbers for selecting the last rank dimensions of the last factor of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Decomposition type <code>Dec</code>, with the selected ranks. </li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decomposition is empty, or if <code>α</code> or <code>β</code> contain invalid or empty ranges.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If the range for the first rank is empty.</li><li><code>ArgumentError</code>: If the range for the first rank is incorrect.</li><li><code>ArgumentError</code>: If the range for the second rank is empty.</li><li><code>ArgumentError</code>: If the range for the second rank is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL613-L635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factor!" href="#TensorRefinement.TensorTrain.factor!"><code>TensorRefinement.TensorTrain.factor!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factor!(U::Dec{T,N}; major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Factorize the decomposition <code>U</code> in place to a single factor (by contracting along all mode dimensions).</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition, whose entries are in <code>T</code> and with <code>N</code> dimensions, to factorize.</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major ordering of the contraction. Can be &quot;first&quot; or &quot;last&quot;.</li></ul><p><strong>Returns</strong></p><ul><li>Single factor object obtained by contracting all factors in the input decomposition object <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL642-L653">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.block!" href="#TensorRefinement.TensorTrain.block!"><code>TensorRefinement.TensorTrain.block!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">block!(U::Dec{T,N}, α::Int, β::Int; major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Selects first ranks of the first and last ranks of the last factor of the decomposition <code>U</code> specified by the indices <code>α</code> and <code>β</code>, contract all factors together in place and yield the resulting block.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, which to modify.</li><li><code>α::Int</code>: The index to select from the first rank.</li><li><code>β::Int</code>: The index to select from the last rank.</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major ordering of the contraction. Can be &quot;first&quot; or &quot;last&quot;.</li></ul><p><strong>Returns</strong></p><ul><li>Resulting factor type <code>U</code> after rank selection and contraction to a block.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL677-L690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decvcat" href="#TensorRefinement.TensorTrain.decvcat"><code>TensorRefinement.TensorTrain.decvcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decvcat(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T&lt;:Number,N,M}</code></pre><p>Vertically concatenate the factors of multiple decomposition types (vectors of factors).</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>W::Vararg{Dec{T,N},M}</code>: Additional decomposition types to concatenate.</li></ul><p><strong>Returns</strong></p><ul><li>New decomposition type obtained by vertically concatenating the given decomposition types (vectors of factors).</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors, mode size, or last rank.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If the decompositions are incompatible in the number of factors.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the last rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL726-L747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.dechcat" href="#TensorRefinement.TensorTrain.dechcat"><code>TensorRefinement.TensorTrain.dechcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dechcat(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T&lt;:Number,N,M}</code></pre><p>Horizontally concatenate the factors of multiple decomposition types (vectors of factors).</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>W::Vararg{Dec{T,N},M}</code>: Additional decompositions types to concatenate.</li></ul><p><strong>Returns</strong></p><ul><li>New decomposition type obtained by horizontally concatenating the given decomposition types (vectors of factors).</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors, mode size, or first rank.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If the decompositions are incompatible in the number of factors.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the first rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL767-L788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decdcat" href="#TensorRefinement.TensorTrain.decdcat"><code>TensorRefinement.TensorTrain.decdcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decdcat(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T&lt;:Number,N,M}</code></pre><p>Concatenates the factors of multiple decomposition types (vectors of factors) along a diagonal mode.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>W::Vararg{Dec{T,N},M}</code>: Additional decomposition types to concatenate.</li></ul><p><strong>Returns</strong></p><ul><li>New decomposition obtained by diagonally concatenating the factors of the given decomposition types.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors or mode size.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If the decompositions are incompatible in the number of factors.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL807-L827">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decscale!" href="#TensorRefinement.TensorTrain.decscale!"><code>TensorRefinement.TensorTrain.decscale!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decscale!(U::Dec{T,N}, α::T) where {T&lt;:Number,N}</code></pre><p>Scale the last factor of the decomposition type <code>U</code> in place by a scalar <code>α</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, which is to be scaled.</li><li><code>α::T</code>: The scalar factor to multiply the last factor by.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Decomposition type with the last factor scaled by α.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL842-L853">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decreverse!" href="#TensorRefinement.TensorTrain.decreverse!"><code>TensorRefinement.TensorTrain.decreverse!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decreverse!(W::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Reverse the order of factors in the decomposition <code>W</code> in place and transposes their ranks.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, which is to be reversed.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: The reversed decomposition of type <code>Dec</code> with transposed ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL860-L870">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decmodetranspose!" href="#TensorRefinement.TensorTrain.decmodetranspose!"><code>TensorRefinement.TensorTrain.decmodetranspose!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decmodetranspose!(U::Dec{T,N}, τ::Union{NTuple{K,Int},Vector{Int}}) where {T&lt;:Number,N,K}</code></pre><p>Transpose the mode dimensions of each factor in the decomposition type <code>U</code> according to the permutation <code>τ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, whose factors&#39; modes are to be transposed.</li><li><code>τ::Union{NTuple{K,Int},Vector{Int}}</code>: A tuple or vector of integers specifiying the permutation of the mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Decomposition type, whose factors exhibit transposed mode dimensions.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decomposition has no mode dimensions or if <code>τ</code> is not a valid permutation.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If the decomposition has no mode dimensions.</li><li><code>ArgumentError</code>: If <code>τ</code> is not a valid permutation of the mode dimensions of <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL880-L899">source</a></section><section><div><pre><code class="language-julia hljs">decmodetranspose!(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Transpose the mode dimensions of each factor in the decomposition <code>U</code> by reversing the mode dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code> whose factors&#39; mode dimensions are to be reversed.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Decomposition of type <code>Dec</code> with the mode dimensions of each factor reversed.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the decomposition has no mode dimensions.</li><li><code>ArgumentError</code>: If the transpose operation is not applicable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL916-L930">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decmodereshape" href="#TensorRefinement.TensorTrain.decmodereshape"><code>TensorRefinement.TensorTrain.decmodereshape</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decmodereshape(U::Dec{T,N}, n::DecSize) where {T&lt;:Number,N}</code></pre><p>Reshape each factor of the decomposition type (vector of factors) <code>U</code> to have new mode sizes specified by <code>n</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, which is to be reshaped.</li><li><code>n::DecSize</code>: Size matrix specifying the new sizes for each mode of the factors of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li>New decomposition with reshaped factors.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the decomposition does not have at least one mode dimension</li><li><code>ArgumentError</code>: If the number of columns in <code>n</code>is inconsistent with <code>U</code>.</li><li><code>DimensionMismatch</code>: If <code>n</code> is inconsistent with <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL933-L949">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decfill!" href="#TensorRefinement.TensorTrain.decfill!"><code>TensorRefinement.TensorTrain.decfill!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decfill!(U::Dec{T,N}, v::T) where {T&lt;:Number,N}</code></pre><p>Fill each factor of the decomposition type <code>U</code> with the value <code>v</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code> whose factors are to be filled.</li><li><code>v::T</code>: The value to fill each element of the factors with.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Decomposition of type <code>Dec</code> with each factor filled with value <code>v</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL968-L979">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decrand!" href="#TensorRefinement.TensorTrain.decrand!"><code>TensorRefinement.TensorTrain.decrand!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decrand!(rng::AbstractRNG, U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Fill each factor of the decomposition type <code>U</code> with random numbers generated from the provided random number generator <code>rng</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: Random number generator to utilize for generating random values.</li><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, whose factors are to be filled with random numbers.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Decomposition of type <code>Dec</code> with each factor filled with random numbers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL988-L999">source</a></section><section><div><pre><code class="language-julia hljs">decrand!(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Fill each factor of the decomposition <code>U</code> with random numbers using the global random number generator.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code> whose factors are to be filled with random numbers generated from the global RNG (<code>Random.GLOBAL_RNG</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Decomposition of type <code>Dec</code> with each factor filled with random numbers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1008-L1018">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.deczeros" href="#TensorRefinement.TensorTrain.deczeros"><code>TensorRefinement.TensorTrain.deczeros</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deczeros(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T&lt;:Number}</code></pre><p>Create a decomposition of the specified type <code>T</code> where each factor is initialized to contain only zeros.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Data type of the elements in each factor.</li><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> where each factor is filled with zeros.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1021-L1036">source</a></section><section><div><pre><code class="language-julia hljs">deczeros(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)</code></pre><p>Create a decomposition of type <code>Float64</code> where each factor is initialized to contain only zeros.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> (with <code>Float64</code> elements) where each factor is filled with zeros.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1039-L1053">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decones" href="#TensorRefinement.TensorTrain.decones"><code>TensorRefinement.TensorTrain.decones</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decones(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T&lt;:Number}</code></pre><p>Create a decomposition of the specified type <code>T</code> where each factor is initialized to contain only ones.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Data type of the elements in each factor.</li><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> with the specified data type <code>T</code>, where each factor is filled with ones.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1056-L1071">source</a></section><section><div><pre><code class="language-julia hljs">decones(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)</code></pre><p>Create a decomposition of type <code>Float64</code> where each factor is initialized to contain only ones.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> with <code>Float64</code> elements, where each factor is filled with ones.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1074-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decrand" href="#TensorRefinement.TensorTrain.decrand"><code>TensorRefinement.TensorTrain.decrand</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decrand(rng::AbstractRNG, ::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T&lt;:Number}</code></pre><p>Create a decomposition of the specified type <code>T</code> and fill each factor with random numbers generated by the provided random number generator <code>rng</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: Random number generator to use for filling the decomposition with random numbers.</li><li><code>T::Type{T}</code>: Data type of the elements in each factor.</li><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> with the specified data type <code>T</code>, where each factor is filled with random numbers generated by the provided <code>rng</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1091-L1107">source</a></section><section><div><pre><code class="language-julia hljs">decrand(rng::AbstractRNG, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)</code></pre><p>Create a decomposition of type <code>Float64</code> and fill each factor with random numbers generated by the provided random number generator <code>rng</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: Random number generator to use for filling the decomposition with random numbers.</li><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> with <code>Float64</code> elements, where each factor is filled with random numbers generated by the provided <code>rng</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1109-L1124">source</a></section><section><div><pre><code class="language-julia hljs">decrand(::Type{T}, n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0) where {T&lt;:Number}</code></pre><p>Create a decomposition of the specified type <code>T</code> and fill each factor with random numbers using the global random number generator (<code>Random.GLOBAL_RNG</code>).</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{T}</code>: Data type of the elements in each factor.</li><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> with the specified data type <code>T</code>, where each factor is filled with random numbers generated by <code>Random.GLOBAL_RNG</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1127-L1142">source</a></section><section><div><pre><code class="language-julia hljs">decrand(n::Union{DecSize,FactorSize}, r::Union{Int,DecRank}; first::Int=0, last::Int=0, len::Int=0)</code></pre><p>Create a decomposition of type <code>Float64</code> and fill each factor with random numbers using the global random number generator (<code>Random.GLOBAL_RNG</code>).</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{DecSize,FactorSize}</code>: Size matrix or factor size, representing the dimensions of the modes in each factor of the decomposition.</li><li><code>r::Union{Int,DecRank}</code>: Rank or rank vector, representing the ranks of the decomposition.</li><li><code>first::Int=0</code>: Optional first rank. Specifies the rank of the first mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>last::Int=0</code>: Optional last rank. Specifies the rank of the last mode dimension if <code>r</code> is not expressed using a vector.</li><li><code>len::Int=0</code>: Number of factors. Specifies the number of factors in the decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>A decomposition of type <code>Dec</code> with <code>Float64</code> elements, where each factor is filled with random numbers generated by <code>Random.GLOBAL_RNG</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1145-L1159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decappend!" href="#TensorRefinement.TensorTrain.decappend!"><code>TensorRefinement.TensorTrain.decappend!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decappend!(U::Dec{T,N}, V::Dec{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number, N}</code></pre><p>Append the decomposition type (vector of factors) <code>V</code> to the end of the decomposition type <code>U</code> in place. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Target decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, to which <code>V</code> will be appended.</li><li><code>V::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which to append to <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> and <code>V</code> before appending.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the combined result after appending.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition type <code>U</code> after appending <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V are inconsistent in the number of dimensions.</li><li><code>ArgumentError</code>:If the factors of U have incorrect or inconsistent ranks.</li><li><code>ArgumentError</code>: If the factors of V have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1163-L1186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decprepend!" href="#TensorRefinement.TensorTrain.decprepend!"><code>TensorRefinement.TensorTrain.decprepend!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decprepend!(U::Dec{T,N}, V::Dec{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number, N}</code></pre><p>Prepend the decomposition type (vector of factors) <code>V</code> to the beginning of the decomposition type (vector of factors) <code>U</code> in place. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Target decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, to which <code>V</code> will be prepended.</li><li><code>V::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which to append to <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> and <code>V</code> before prepending.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the combined result after prepending.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition type <code>U</code> after prepending <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V have different numbers of dimensions.</li><li><code>ArgumentError</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>ArgumentError</code>: If the factors of V have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1211-L1234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decpush!" href="#TensorRefinement.TensorTrain.decpush!"><code>TensorRefinement.TensorTrain.decpush!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decpush!(U::Dec{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number, N}</code></pre><p>Push a factor <code>V</code> to the end of the decomposition type (vector of factors) <code>U</code> in place. Optionally, the ranks before and after the operation are checked.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Target decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, to which the factor <code>V</code> will be pushed.</li><li><code>V::Factor{T,N}</code>: The factor to push to the decomposition type (vector of factors) <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> before pushing.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the result after pushing.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition type (vector of factors) <code>U</code> after pushing <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if their ranks (in case of <code>U</code>, the ranks of its factors) are inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V have different numbers of dimensions.</li><li><code>ArgumentError</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1259-L1281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decpushfirst!" href="#TensorRefinement.TensorTrain.decpushfirst!"><code>TensorRefinement.TensorTrain.decpushfirst!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decpushfirst!(U::Dec{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number, N}</code></pre><p>Push a factor <code>V</code> to the beginning of the decomposition type (vector of factors) <code>U</code> in place. Optionally, the ranks before and after the operation are checked.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Target decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, to which the factor <code>V</code> will be pushed at the beginning.</li><li><code>V::Factor{T,N}</code>: The factor to push to the beginning of <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), the ranks of <code>U</code> are checked before pushing.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), the ranks of the result are checked after pushing.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition type (vector of factors) <code>U</code> after pushing <code>V</code> at the beginning.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if their ranks (in case of <code>U</code>, the ranks of its factors) are inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V have different numbers of dimensions.</li><li><code>DimensionMismatch</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1302-L1324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decpop!" href="#TensorRefinement.TensorTrain.decpop!"><code>TensorRefinement.TensorTrain.decpop!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decpop!(U::Dec{T,N}) where {T&lt;:Number, N}</code></pre><p>Pop the last factor from the decomposition type (vector of factors) <code>U</code> and return it.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, from which to pop the last factor.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The last factor that was removed from <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1347-L1357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decpopfirst!" href="#TensorRefinement.TensorTrain.decpopfirst!"><code>TensorRefinement.TensorTrain.decpopfirst!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decpopfirst!(U::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Pop the first factor from the decomposition type (vector of factors) <code>U</code> and return it.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, from which to pop the first factor.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The first factor that was removed from <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1362-L1372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decinsert!" href="#TensorRefinement.TensorTrain.decinsert!"><code>TensorRefinement.TensorTrain.decinsert!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decinsert!(U::Dec{T,N}, ℓ::Int, V::Factor{T,N}; path::String=&quot;&quot;, rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number, N}</code></pre><p>Insert a factor <code>V</code> into the decomposition type (vector of factors) <code>U</code> at the specified index <code>ℓ</code>. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, in which to insert the factor <code>V</code>.</li><li><code>ℓ::Int</code>: The index at which to insert the factor <code>V</code>.</li><li><code>V::Factor{T,N}</code>: The factor to insert into the decomposition <code>U</code>.</li><li><code>path::String=&quot;&quot;</code>: The path direction for insertion; should be &quot;forward&quot; or &quot;backward&quot;.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> before insertion.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the result after insertion.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition type <code>U</code> after inserting <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If <code>path</code> is not &quot;forward&quot; or &quot;backward&quot;.</li><li><code>DimensionMismatch</code>: If <code>ℓ</code> is out of range or if the ranks (of <code>U</code>, <code>V</code> or the factors of <code>U</code>) are inconsistent for the operation.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If path is neither &quot;forward&quot; nor &quot;backward&quot;</li><li><code>ArgumentError</code>: If ℓ is not from 1:L, where L is the number of factors in `U</li><li><code>DimensionMismatch</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1377-L1403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decdeleteat!" href="#TensorRefinement.TensorTrain.decdeleteat!"><code>TensorRefinement.TensorTrain.decdeleteat!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decdeleteat!(U::Dec{T,N}, Λ::Union{Int,Vector{Int},NTuple{M,Int} where M}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number, N}</code></pre><p>Delete factors from the decomposition type (vector of factors) <code>U</code> at the specified indices <code>Λ</code> in place. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, from which factors will be deleted.</li><li><code>Λ::Union{Int,Vector{Int},NTuple{M,Int} where M}</code>: Indices of factors to delete. Can be a single integer, a vector of integers, or a tuple of integers.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> before deletion.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the result after deletion.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition type <code>U</code> after deleting the specified factors.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the entries of <code>Λ</code> are not unique or are not within the valid range.</li><li><code>DimensionMismatch</code>: If the ranks of <code>U</code> are inconsistent for this operation.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If the entries of Λ are not unique.</li><li><code>ArgumentError</code>: If Λ is not an element or a subset of 1:L with unique entries, where L is the number of factors in <code>U</code>.</li><li><code>DimensionMismatch</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1429-L1453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decinsertidentity!" href="#TensorRefinement.TensorTrain.decinsertidentity!"><code>TensorRefinement.TensorTrain.decinsertidentity!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decinsertidentity!(U::Dec{T,N}, ℓ::Int; path::String=&quot;&quot;, rankprecheck::Bool=true) where {T&lt;:Number, N}</code></pre><p>Insert an identity factor into the decomposition type (vector of factors) <code>U</code> at the specified index <code>ℓ</code>. Optionally, the ranks are checked before the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: Decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions, in which to insert the identity factor.</li><li><code>ℓ::Int</code>: The index at which to insert the identity factor.</li><li><code>path::String=&quot;&quot;</code>: The path direction for insertion (should be &quot;forward&quot; or &quot;backward&quot;).</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), the ranks of <code>U</code> are checked before insertion.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition type <code>U</code> after inserting the identity factor.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If <code>path</code> is not &quot;forward&quot; or &quot;backward&quot;.</li><li><code>DimensionMismatch</code>: If <code>ℓ</code> is out of range or if the ranks are inconsistent for this operation.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If the is neither &quot;forward&quot; nor &quot;backward&quot;.</li><li><code>ArgumentError</code>: If ℓ is not from 1:L, where L is the number of factors in U.</li><li><code>DimensionMismatch</code>: If the factors of U have inconsistent ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1479-L1502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decskp!" href="#TensorRefinement.TensorTrain.decskp!"><code>TensorRefinement.TensorTrain.decskp!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decskp!(W::Dec{T,N}, Λ::Indices; path::String=&quot;&quot;, major::String=&quot;last&quot;) where {T&lt;:Number, N}</code></pre><p>Perform sequential contraction of components of a vector of factors <code>W</code> based on specified indices <code>Λ</code>, following a specified path and contraction order.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li><li><code>Λ::Indices</code>: reference numbers specifying which components of (the vector of factors) <code>W</code> to contract. Can be a colon <code>Colon</code> (indicating all indices) or a <code>Vector{Int}</code> specifying particular indices.</li><li><code>path::String=&quot;&quot;</code>: keyword argument specifying the order of contraction. <ul><li><code>&quot;&quot;</code> (default): path can be deduced from <code>Λ</code> if <code>Λ</code> is a colon or empty.</li><li><code>&quot;forward&quot;</code>: Contraction of components in a forward sequence.</li><li><code>&quot;backward&quot;</code>: Contraction of components in a backward sequence.</li></ul></li><li><code>major::String=&quot;last&quot;</code>: keyword argument indicating the primary direction for the contraction operation.<ul><li><code>&quot;last&quot;</code> (default): Contraction focuses on the last dimension.</li><li><code>&quot;first&quot;</code>: Contraction focuses on the first dimension.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: modified decomposition object (vector of factors) after performing the contractions on the specified components.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>path</code> is not one of <code>&quot;&quot;</code>, <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>ArgumentError</code>: If  <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li><li><code>ArgumentError</code>: If the decomposition object <code>W</code> is empty (<code>L == 0</code>).</li><li><code>ArgumentError</code>: If <code>Λ</code> is a colon, but <code>path</code> is specified as non-empty.</li><li><code>ArgumentError</code>: If <code>Λ</code> is neither empty nor a colon and path is neither <code>&quot;forward&quot;</code> nor <code>&quot;backward&quot;</code>.</li><li><code>ArgumentError</code>: If <code>Λ</code> has duplicate entries.</li><li><code>ArgumentError</code>: If <code>Λ</code> contains invalid indices that do not match the expected range based on <code>path</code> and the number of factors in <code>W</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1527-L1554">source</a></section><section><div><pre><code class="language-julia hljs">decskp!(W::Dec{T,N}; path::String=&quot;&quot;, major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Perform sequential contraction of all components of a decomposition <code>W</code> following the specified contraction path and direction.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number of dimensions.</li><li><code>path::String=&quot;&quot;</code>: Keyword argument specifying the order of contraction.<ul><li><code>&quot;&quot;</code> (default): Path can be deduced if all indices are used.</li><li><code>&quot;forward&quot;</code>: Contract components in a forward sequence.</li><li><code>&quot;backward&quot;</code>: Contract components in a backward sequence.</li></ul></li><li><code>major::String=&quot;last&quot;</code>: Keyword argument indicating the primary direction for the contraction.<ul><li><code>&quot;last&quot;</code> (default): Focuses on the last dimension.</li><li><code>&quot;first&quot;</code>: Focuses on the first dimension.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: The modified decomposition object after performing the contractions.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>path</code> is not one of <code>&quot;&quot;</code>, <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>ArgumentError</code>: If  <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li><li><code>ArgumentError</code>: If the decomposition object <code>W</code> is empty (<code>L == 0</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1590-L1612">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decskp" href="#TensorRefinement.TensorTrain.decskp"><code>TensorRefinement.TensorTrain.decskp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decskp(W::Dec{T,N}, Λ::Indices; path::String=&quot;&quot;, major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Perform a sequential contraction of selected components of a decomposition object (vector of factors) <code>W</code> based on specified indices <code>Λ</code>, a path (<code>&quot;forward&quot;</code>, <code>&quot;backward&quot;</code>, or <code>&quot;&quot;</code>), and a major contraction direction.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li><li><code>Λ::Indices</code>: reference numbers specifying which components of the decomposition obeject <code>W</code> to contract. Can be a colon <code>Colon</code> (indicating all indices), a <code>Vector{Int}</code>, or other types convertible to an index vector.</li><li><code>path::String=&quot;&quot;</code>: keyword argument specifying the order of contraction. <ul><li><code>&quot;&quot;</code> (default): Approved only if <code>Λ</code> is empty or <code>Λ</code> is a colon.</li><li><code>&quot;forward&quot;</code>: Contraction of components in a forward sequence.</li><li><code>&quot;backward&quot;</code>: Contraction of components in a backward sequence.</li></ul></li><li><code>major::String=&quot;last&quot;</code>: keyword argument determining the primary direction for the contraction operation.<ul><li><code>&quot;last&quot;</code> (default): Contraction focuses on last dimension.</li><li><code>&quot;first&quot;</code>: Contraction focuses on first dimension.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: result of contracting the selected components of <code>W</code> based on the provided indices <code>Λ</code> and the specified path and major direction.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>path</code> is not one of <code>&quot;&quot;</code>, <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>ArgumentError</code>: If <code>major</code> is not <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li><li><code>ArgumentError</code>: If the decomposition object <code>W</code> is empty (<code>L == 0</code>).</li><li><code>ArgumentError</code>: If <code>Λ</code> is empty.</li><li><code>ArgumentError</code>: If <code>Λ</code> is not a contiguous set of integers.</li><li><code>ArgumentError</code>: If <code>Λ</code> is a colon, but <code>path</code> is specified as non-empty.</li><li><code>ArgumentError</code>: If <code>Λ</code> is neither empty nor a colon and path is not specified (<code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>) .</li><li><code>ArgumentError</code>: If <code>Λ</code> has duplicate entries.</li><li><code>ArgumentError</code>: If <code>Λ</code> contains invalid indices that do not match the expected range based on <code>path</code> and the number of factors in <code>W</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1615-L1644">source</a></section><section><div><pre><code class="language-julia hljs">decskp(W::Dec{T,N}; path::String=&quot;&quot;, major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Perform sequential contraction of all components of a decomposition <code>W</code> in a non-mutating way, following the specified contraction path and direction.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number of dimensions.</li><li><code>path::String=&quot;&quot;</code>: Keyword argument specifying the order of contraction.<ul><li><code>&quot;&quot;</code> (default): Path can be deduced if all indices are used.</li><li><code>&quot;forward&quot;</code>: Contract components in a forward sequence.</li><li><code>&quot;backward&quot;</code>: Contract components in a backward sequence.</li></ul></li><li><code>major::String=&quot;last&quot;</code>: Keyword argument indicating the primary direction for the contraction.<ul><li><code>&quot;last&quot;</code> (default): Focuses on the last dimension.</li><li><code>&quot;first&quot;</code>: Focuses on the first dimension.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>The contracted decomposition of type <code>Dec</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>path</code> is not one of <code>&quot;&quot;</code>, <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>ArgumentError</code>: If  <code>major</code> is neither <code>&quot;first&quot;</code> nor <code>&quot;last&quot;</code>.</li><li><code>ArgumentError</code>: If the decomposition object <code>W</code> is empty (<code>L == 0</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1686-L1708">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decmp" href="#TensorRefinement.TensorTrain.decmp"><code>TensorRefinement.TensorTrain.decmp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decmp(U₁::Dec{T,N₁}, σ₁::Indices, U₂::Dec{T,N₂}, σ₂::Indices) where {T&lt;:Number, N₁, N₂}</code></pre><p>Perform the mode product of two decomposition objects <code>U₁</code> and <code>U₂</code> along specified sets of modes and returns a new decomposition object resulting from the multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::Dec{T,N₁}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N₁</code> dimensions.</li><li><code>σ₁::Indices</code>: A set of mode indices for <code>U₁</code>. Specifies which modes of <code>U₁</code> to multiply.</li><li><code>U₂::Dec{T,N₂}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N₂</code> dimensions.</li><li><code>σ₂::Indices</code>: A set of mode indices for <code>U₂</code>. Specifies which modes of <code>U₂</code> to multiply.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: A new decomposition object resulting from the mode product of <code>U₁</code> and <code>U₂</code> along the specified modes.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If σ₁ is passed as a vector, and it is not a vector of the type Vector{Int} and not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If σ₂ is passed as a vector, and it is not a vector of the type Vector{Int} and not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If U₁ and U₂ differ in the number of factors.</li><li><code>ArgumentError</code>: If the specified sets of modes of σ₁ and σ₂ are inconsistent.</li><li><code>ArgumentError</code>: If the set of modes of U₁ is specified incorrectly.</li><li><code>ArgumentError</code>: If the set of modes of U₂ is specified incorrectly.</li><li><code>ArgumentError</code>: If U₁ and U₂ are inconsistent with respect to the specified modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1711-L1733">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.deckp" href="#TensorRefinement.TensorTrain.deckp"><code>TensorRefinement.TensorTrain.deckp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deckp(U::Union{Dec{T,N}, Pair{Dec{T,N}, Int}}, V::Vararg{Union{Dec{T,N}, Pair{Dec{T,N}, Int}}, M}) where {T&lt;:Number, N, M}</code></pre><p>Perform the Kronecker product on multiple decomposition objects, optionally with specified exponents for each decomposition object, and return a new decomposition object resulting from the product.</p><p><strong>Arguments</strong></p><ul><li><code>U::Union{Dec{T,N}, Pair{Dec{T,N}, Int}}</code>: The first decomposition object or a pair of a decomposition object and an exponent. If a pair, the exponent specifies how many times the decomposition object is repeated in the Kronecker product.</li><li><code>V::Vararg{Union{Dec{T,N}, Pair{Dec{T,N}, Int}}, M}</code>: Additional decomposition objects or pairs of decomposition objects and exponents to include in the Kronecker product.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: A new decomposition object resulting from the Kronecker product of the input decompositions, each raised to its corresponding exponent.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any exponent specified is negative.</li><li><code>ArgumentError</code>: If the input decompositions differ in the number of factors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1778-L1793">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decaxpby!" href="#TensorRefinement.TensorTrain.decaxpby!"><code>TensorRefinement.TensorTrain.decaxpby!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decaxpby!(α::Vector{T}, U::Dec{T,N}, β::Vector{T}, V::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the operation <code>U = α .* U + β .* V</code> for decompositions <code>U</code> and <code>V</code>, where <code>α</code> and <code>β</code> are vectors of scalars that scale the corresponding factors of <code>U</code> and <code>V</code> respectively. The operation modifies <code>U</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{T}</code>: Vector of scaling factors for the decomposition object <code>U</code>. Must have the same length as the number of factors in <code>U</code>.</li><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>β::Vector{T}</code>: Vector of scaling factors for the decomposition object <code>V</code>. Must have the same length as the number of factors in <code>V</code>.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition object <code>U</code> after applying the operation.</li></ul><p><strong>Throws</strong></p><p>Summarized Error List:</p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have a different number of factors, differ in mode sizes, are incompatible in ranks, or if <code>α</code> and <code>β</code> do not have the correct lengths.</li></ul><p>Extended Error List:</p><ul><li><code>ArgumentError</code>: If U and V differ in the number of factors</li><li><code>ArgumentError</code>: If U and V are inconsistent in mode size</li><li><code>ArgumentError</code>: If α does not have the same length as U and V</li><li><code>ArgumentError</code>: If β does not have the same length as U and V</li><li><code>ArgumentError</code>: If the decompositions is incompatible in the first rank.</li><li><code>ArgumentError</code>: If the decompositions is incompatible in the last rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1846-L1871">source</a></section><section><div><pre><code class="language-julia hljs">decaxpby!(α::T, U::Dec{T,N}, β::T, V::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the operation <code>U = α .* U + β .* V</code> for decompositions <code>U</code> and <code>V</code>, where <code>α</code> and <code>β</code> are scalar values that scale all factors of <code>U</code> and <code>V</code> respectively. The operation modifies <code>U</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>α::T</code>: Scalar value to scale all factors of <code>U</code>.</li><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>β::T</code>: Scalar value to scale all factors of <code>V</code>.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified decomposition object <code>U</code> after applying the operation.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have a different number of factors, differ in mode sizes, or are incompatible in ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1905-L1921">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decadd!" href="#TensorRefinement.TensorTrain.decadd!"><code>TensorRefinement.TensorTrain.decadd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decadd!(U::Dec{T,N}, V::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the operation <code>U = U + V</code> , adding decomposition <code>V</code> to <code>U</code> and modifying <code>U</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: The modified decomposition object <code>U</code> after the addition.</li></ul><p><strong>Throws</strong></p><p>Summarized Error List:</p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> are incompatible in the number of factors, mode size, the first or the last rank.</li></ul><p>Extended Error List:</p><ul><li><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the first rank.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the last rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1924-L1945">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decaxpby" href="#TensorRefinement.TensorTrain.decaxpby"><code>TensorRefinement.TensorTrain.decaxpby</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decaxpby(α::Vector{T}, U::Dec{T,N}, β::Vector{T}, V::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the operation <code>U = α .* U + β .* V</code> for decompositions <code>U</code> and <code>V</code>, where <code>α</code> and <code>β</code> are vectors of scalars that scale the corresponding factors of <code>U</code> and <code>V</code> respectively. The result is returned as a new decomposition.</p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{T}</code>: Vector of scaling factors for the decomposition object <code>U</code>. Must have the same length as the number of factors in <code>U</code>.</li><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>β::Vector{T}</code>: Vector of scaling factors for the decomposition object <code>V</code>. Must have the same length as the number of factors in <code>V</code>.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new decomposition resulting from the operation <code>α .* U + β .* V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have a different number of factors, differ in mode sizes, or are incompatible in ranks, or if <code>α</code> and <code>β</code> do not have the correct lengths.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1948-L1964">source</a></section><section><div><pre><code class="language-julia hljs">decaxpby(α::T, U::Dec{T,N}, β::T, V::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the operation <code>U = α .* U + β .* V</code> for decompositions <code>U</code> and <code>V</code>, where <code>α</code> and <code>β</code> are scalar values that scale all factors of <code>U</code> and <code>V</code> respectively. The result is returned as a new decomposition.</p><p><strong>Arguments</strong></p><ul><li><code>α::T</code>: Scalar value to scale all factors of <code>U</code>.</li><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>β::T</code>: Scalar value to scale all factors of <code>V</code>.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new decomposition resulting from the operation <code>α .* U + β .* V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have a different number of factors, differ in mode sizes, or are incompatible in ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1967-L1983">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decadd" href="#TensorRefinement.TensorTrain.decadd"><code>TensorRefinement.TensorTrain.decadd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decadd(U::Dec{T,N}, V::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the element-wise addition of two decompositions <code>U</code> and <code>V</code>. The result is returned as a new decomposition.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new decomposition resulting from the element-wise addition of <code>U</code> and <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have a different number of factors, differ in mode sizes, or are incompatible in ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL1986-L2000">source</a></section><section><div><pre><code class="language-julia hljs">decadd(U::Dec{T,N}, V::Dec{T,N}, W::Vararg{Dec{T,N},M}) where {T&lt;:Number,N,M}</code></pre><p>Add multiple decompositions <code>U</code>, <code>V</code> and <code>W...</code> by stacking their factors and return a new decomposition object that represents their sum.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>W::Vararg{Dec{T,N},M}</code>: Additional decomposition objects to add.</li></ul><p><strong>Returns</strong></p><ul><li>A new decomposition object obtained by horizontal and vertical concatenation of the factors of all given decompositions.</li></ul><p><strong>Throws</strong></p><p>Summarized error list:</p><ul><li><code>ArgumentError</code>: Thrown if any of the decompositions have incompatible dimensions or ranks.</li></ul><p>Extended error list:</p><ul><li><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the first rank.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the last rank.</li></ul><p><strong>Details</strong></p><ul><li>The factors of each decomposition are stacked together as follows:<ul><li>The first factor is concatenated horizontally.</li><li>The middle factors are concatenated diagonally.</li><li>The last factor is concatenated vertically.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL2003-L2031">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.dechp" href="#TensorRefinement.TensorTrain.dechp"><code>TensorRefinement.TensorTrain.dechp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dechp(U::Dec{T,N}, V::Dec{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the Hadamard product (element-wise multiplication) of two decompositions <code>U</code> and <code>V</code> and return a new decomposition object <code>W</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li><li><code>V::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, which represents a vector of factors whose entries are in <code>T</code> and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: A new decomposition  of type <code>Dec</code>, which results from the Hadamard product of <code>U</code> and <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: Thrown if <code>U</code> and <code>V</code> have a different number of factors or are inconsistent in mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL2057-L2071">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decqr!" href="#TensorRefinement.TensorTrain.decqr!"><code>TensorRefinement.TensorTrain.decqr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decqr!(W::Dec{T,N}, Λ::Indices; pivot::Bool=false, path::String=&quot;&quot;, returnRfactors::Bool=false) where {T&lt;:FloatRC, N}</code></pre><p>Perform a QR decomposition on the components of a decomposition object (vector of factors) <code>W</code> with specified indices <code>Λ</code>, following a given path, and optional pivoting.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li><li><code>Λ::Indices</code>: reference numbers specifying which components of the decomposition object <code>W</code> to apply the QR decomposition to. Can be a colon <code>Colon</code> (indicating all indices) or a <code>Vector{Int}</code>.</li><li><code>pivot::Bool=false</code>: keyword argument indicating whether pivoting should be used in the QR decomposition.</li><li><code>path::String=&quot;&quot;</code>: keyword argument specifying the order of decomposition. <ul><li><code>&quot;&quot;</code> (default): The path is deduced from <code>Λ</code> if possible.</li><li><code>&quot;forward&quot;</code>: Performs decomposition in a forward sequence.</li><li><code>&quot;backward&quot;</code>: Performs decomposition in a backward sequence.</li></ul></li><li><code>returnRfactors::Bool=false</code>: keyword argument indicating whether to return the <code>R</code> factors from the QR decomposition along with the modified decomposition object <code>W</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: modified decomposition object after performing the QR decomposition on the specified components.</li><li><code>Rfactors</code> (optional): vector of <code>Matrix{T}</code> containing the <code>R</code> factors from the QR decompositions; returned if <code>returnRfactors</code> is <code>true</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the decomposition object <code>W</code> is empty (<code>L == 0</code>).</li><li><code>ArgumentError</code>: If <code>path</code> is not one of <code>&quot;&quot;</code>, <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>ArgumentError</code>: If <code>path</code> cannot be deduced from <code>Λ</code> when <code>path</code> is <code>&quot;&quot;</code>.</li><li><code>ArgumentError</code>: If <code>Λ</code> contains duplicate entries.</li><li><code>ArgumentError</code>: If <code>Λ</code> is not a contiguous set of integers.</li><li><code>ArgumentError</code>: If <code>Λ</code> is out of the valid range for the indices of <code>W</code>.</li><li><code>ArgumentError</code>: If <code>Λ</code> is neither sorted in ascending nor in descending order, leading to inconsitency with either &quot;forward&quot; or &quot;backward&quot; <code>path</code>.</li><li><code>ArgumentError</code>: If <code>Λ</code> is not sorted in a consistent order with the <code>path</code> (ascending order matches &quot;forward&quot;<code></code>path<code>; descending order matches</code>&quot;backward&quot;<code></code>path`).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL2084-L2112">source</a></section><section><div><pre><code class="language-julia hljs">decqr!(W::Dec{T,N}; pivot::Bool=false, path::String=&quot;&quot;, returnRfactors::Bool=false) where {T&lt;:FloatRC,N}</code></pre><p>Perform a QR decomposition on all factors of a decomposition object (vector of factors) <code>W</code>, using optional pivoting and following the specified contraction path.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>pivot::Bool=false</code>: Keyword argument indicating whether to apply pivoting during the QR decomposition.</li><li><code>path::String=&quot;&quot;</code>: Specifies the contraction path for the decomposition, either <code>&quot;&quot;</code> (default), <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>. <ul><li><code>&quot;&quot;</code>: The path is deduced from the indices if possible.</li><li><code>&quot;forward&quot;</code>: Decomposes in a forward sequence.</li><li><code>&quot;backward&quot;</code>: Decomposes in a backward sequence.</li></ul></li><li><code>returnRfactors::Bool=false</code>: Whether to return the <code>R</code> factors from the QR decompositions.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: Modified decomposition object after applying the QR decomposition.</li><li><code>Rfactors</code> (optional): If <code>returnRfactors</code> is set to <code>true</code>, a vector of <code>Matrix{T}</code> containing the <code>R</code> factors from the QR decomposition is returned.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the decomposition object <code>W</code> is empty (<code>L == 0</code>).</li><li><code>ArgumentError</code>: If <code>path</code> is neither <code>&quot;forward&quot;</code> nor <code>&quot;backward&quot;</code>.</li><li><code>ArgumentError</code>: If path is <code>&quot;&quot;</code>, because the path cannot be deduced when <code>Λ</code> is a colon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL2177-L2199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.decsvd!" href="#TensorRefinement.TensorTrain.decsvd!"><code>TensorRefinement.TensorTrain.decsvd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decsvd!(W::Dec{T,N}, Λ::Indices, n::Union{Colon,DecSize}; 
        path::String=&quot;&quot;, 
        soft::Float2{AbstractFloat}=zero(S), 
        hard::Float2{AbstractFloat}=zero(S), 
        aTol::Float2{AbstractFloat}=zero(S), 
        aTolDistr::Float2{AbstractFloat}=zero(S), 
        rTol::Float2{AbstractFloat}=zero(S), 
        rTolDistr::Float2{AbstractFloat}=zero(S), 
        rank::Int2=0, 
        major::String=&quot;last&quot;)
where {S&lt;:AbstractFloat,T&lt;:FloatRC{S},N}</code></pre><p>Perform a truncated Singular Value Decomposition (SVD) on a decomposition object (vector of factors) <code>W</code>.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T,N}</code>: Decomposition object of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li><li><code>Λ::Indices</code>: Reference number or a vector of reference numbers specifying the factors of <code>W</code> to be decomposed.</li><li><code>n::Union{Colon,DecSize}</code>: Specifies the mode sizes for the factors to be decomposed. If <code>Colon</code>, the mode sizes of the factors are deduced from <code>W</code>.</li><li><code>path::String=&quot;&quot;</code>: Specifies the path for decomposition, either <code>&quot;forward&quot;</code> or <code>&quot;backward&quot;</code>. Defaults to <code>&quot;&quot;</code>, which means the path will be automatically deduced.</li><li><code>soft::Float2{AbstractFloat}=zero(S)</code>: Soft threshold for truncation, either non-negative scalar or vector of such (one per decomposition step).</li><li><code>hard::Float2{AbstractFloat}=zero(S)</code>: Hard threshold for truncation, either non-negative scalar or vector of such, (one per decomposition step).</li><li><code>aTol::Float2{AbstractFloat}=zero(S)</code>: Absolute tolerance for SVD, either non-negative scalar or vector of such, (one per decomposition step).</li><li><code>aTolDistr::Float2{AbstractFloat}=zero(S)</code>: Distributed absolute tolerance for SVD, either a non-negative scalar or a vector of such, (one per decomposition step).</li><li><code>rTol::Float2{AbstractFloat}=zero(S)</code>: Relative tolerance for SVD, either a non-negative scalar or a vector of such, (one per decomposition step).</li><li><code>rTolDistr::Float2{AbstractFloat}=zero(S)</code>: Distributed relative tolerance for SVD, either a non-negative scalar or a vector of such, (one per decomposition step).</li><li><code>rank::Int2=0</code>: Rank for truncation, either a non-negative integer or a vector of such, (one per decomposition step).</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major ordering of the modes in the vector of factors. Must be either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>. Default is set to <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: Updated decomposition object with SVD applied.</li><li><code>ε</code>: Vector of float numbers representing the computed truncation error for each decomposition step.</li><li><code>δ</code>: Vector of float numbers representing the relative error for each decomposition step.</li><li><code>μ</code>: Norm of the decomposition object.</li><li><code>ρ</code>: Vector of integers representing the ranks after truncation for each decomposition step.</li><li><code>σ</code>: Vector of vectors containing the singular values for each decomposition step.</li></ul><p><strong>Errors</strong></p><p>Summarized Error List:</p><ul><li><code>ArgumentError</code>: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.</li></ul><p>Extended Error List:</p><ul><li><code>ArgumentError</code>: If the decomposition is empty.</li><li><code>ArgumentError</code>: If path is none of the following: &quot;&quot; (default, accepted only when path can be deduced from Λ), &quot;forward&quot; or &quot;backward&quot;.</li><li><code>ArgumentError</code>: If path cannot be deduced from Λ or is the path is neither &quot;forward&quot; nor &quot;backward&quot; when Λ is a colon.</li><li><code>ArgumentError</code>: If the entries of Λ do not form a set of contiguous integers.</li><li><code>ArgumentError</code>: If Λ is out of range.</li><li><code>ArgumentError</code>: If Λ is not sorted in ascending or descending order, rendering it inconsistent with any forward or backward path.</li><li><code>ArgumentError</code>: If Λ is not sorted in ascending order, rendering it inconsistent with any forward path.</li><li><code>ArgumentError</code>: If Λ is not sorted in descending order, rendering it inconsistent with any backward path.</li><li><code>ArgumentError</code>: If the number of rows in n is not equal to the number of dimensions in each factor of W.</li><li><code>ArgumentError</code>: If the number of columns in n is not equal to the number of elements in Λ.</li><li><code>ArgumentError</code>: If n and Λ are incompatible with the size of the factors of W.</li><li><code>ArgumentError</code>: If soft is not a nonnegative Float or a vector of such.</li><li><code>ArgumentError</code>: If soft, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If hard is not a nonnegative Float or a vector of such.</li><li><code>ArgumentError</code>: If hard, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If aTol is not a nonnegative Float64 or a vector of such.</li><li><code>ArgumentError</code>: If aTol, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If aTolDistr is not a nonnegative Float64 or a vector of such.</li><li><code>ArgumentError</code>: If aTolDistr, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If rTol is not a nonnegative Float or a vector of such.</li><li><code>ArgumentError</code>: If rTol, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If rTolDistr is not a nonnegative Float or a vector of such.</li><li><code>ArgumentError</code>: If rTolDistr, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If rank is not a nonnegative Int or a vector of such.</li><li><code>ArgumentError</code>: If rank, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If major is neither &quot;last&quot; (default) nor &quot;first&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL2204-L2273">source</a></section><section><div><pre><code class="language-julia hljs">decsvd!(W::Dec{T,N}, Λ::Indices; path::String=&quot;&quot;, soft::Float2{AbstractFloat}=zero(S), 
        hard::Float2{AbstractFloat}=zero(S), aTol::Float2{AbstractFloat}=zero(S), 
        aTolDistr::Float2{AbstractFloat}=zero(S), rTol::Float2{AbstractFloat}=zero(S), 
        rTolDistr::Float2{AbstractFloat}=zero(S), rank::Int2=0, major::String=&quot;last&quot;) 
where {S&lt;:AbstractFloat, T&lt;:FloatRC{S}, N}</code></pre><p>Perform a truncated Singular Value Decomposition (SVD) on the components of a decomposition object (vector of factors) <code>W</code> with specified indices <code>Λ</code>, applying truncation based on thresholds, tolerances, and ranks. Function deduces mode sizes from the <code>Dec</code> object <code>W</code>.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, representing a vector of factors with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>Λ::Indices</code>: Indices specifying which factors of <code>W</code> to apply the SVD to.</li><li><code>path::String=&quot;&quot;</code>: Specifies the contraction path for the decomposition. Can be <code>&quot;forward&quot;</code>, <code>&quot;backward&quot;</code>, or <code>&quot;&quot;</code> (default, where the path is deduced).</li><li><code>soft::Float2{AbstractFloat}=zero(S)</code>: Soft threshold for truncation.</li><li><code>hard::Float2{AbstractFloat}=zero(S)</code>: Hard threshold for truncation.</li><li><code>aTol::Float2{AbstractFloat}=zero(S)</code>: Absolute tolerance for SVD.</li><li><code>aTolDistr::Float2{AbstractFloat}=zero(S)</code>: Distributed absolute tolerance for SVD.</li><li><code>rTol::Float2{AbstractFloat}=zero(S)</code>: Relative tolerance for SVD.</li><li><code>rTolDistr::Float2{AbstractFloat}=zero(S)</code>: Distributed relative tolerance for SVD.</li><li><code>rank::Int2=0</code>: Rank for truncation.</li><li><code>major::String=&quot;last&quot;</code>: Specifies whether to focus on the &quot;first&quot; or &quot;last&quot; mode during truncation. Defaults to <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: Modified decomposition object after performing the truncated SVD.</li><li><code>ε</code>: Vector of truncation errors for each step.</li><li><code>δ</code>: Vector of relative errors for each step.</li><li><code>μ</code>: Norm of the decomposition object.</li><li><code>ρ</code>: Vector of post-truncation ranks for each step.</li><li><code>σ</code>: Vector of vectors containing the singular values for each step.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any arguments are invalid, for example incorrect dimensions or invalid thresholds.</li><li>For an extended error list, see the default version of <code>decsvd!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL2420-L2454">source</a></section><section><div><pre><code class="language-julia hljs">decsvd!(W::Dec{T,N}; path::String=&quot;&quot;, soft::Float2{AbstractFloat}=zero(S), 
        hard::Float2{AbstractFloat}=zero(S), aTol::Float2{AbstractFloat}=zero(S), 
        aTolDistr::Float2{AbstractFloat}=zero(S), rTol::Float2{AbstractFloat}=zero(S), 
        rTolDistr::Float2{AbstractFloat}=zero(S), rank::Int2=0, major::String=&quot;last&quot;) 
where {S&lt;:AbstractFloat, T&lt;:FloatRC{S}, N}</code></pre><p>Perform a truncated Singular Value Decomposition (SVD) on all components of a decomposition object (vector of factors) <code>W</code> with optional truncation based on thresholds, tolerances, and ranks.</p><p><strong>Arguments</strong></p><ul><li><code>W::Dec{T, N}</code>: Decomposition object of type <code>Dec</code>, representing a vector of factors with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>path::String=&quot;&quot;</code>: Specifies the contraction path for the decomposition. Can be <code>&quot;forward&quot;</code>, <code>&quot;backward&quot;</code>, or <code>&quot;&quot;</code> (default, where the path is deduced).</li><li><code>soft::Float2{AbstractFloat}=zero(S)</code>: Soft threshold for truncation.</li><li><code>hard::Float2{AbstractFloat}=zero(S)</code>: Hard threshold for truncation.</li><li><code>aTol::Float2{AbstractFloat}=zero(S)</code>: Absolute tolerance for SVD.</li><li><code>aTolDistr::Float2{AbstractFloat}=zero(S)</code>: Distributed absolute tolerance for SVD.</li><li><code>rTol::Float2{AbstractFloat}=zero(S)</code>: Relative tolerance for SVD.</li><li><code>rTolDistr::Float2{AbstractFloat}=zero(S)</code>: Distributed relative tolerance for SVD.</li><li><code>rank::Int2=0</code>: Rank for truncation.</li><li><code>major::String=&quot;last&quot;</code>: Specifies whether to focus on the &quot;first&quot; or &quot;last&quot; mode during truncation. Defaults to <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: Modified decomposition object after performing the truncated SVD.</li><li><code>ε</code>: Vector of truncation errors for each step.</li><li><code>δ</code>: Vector of relative errors for each step.</li><li><code>μ</code>: Norm of the decomposition object.</li><li><code>ρ</code>: Vector of post-truncation ranks for each step.</li><li><code>σ</code>: Vector of vectors containing the singular values for each step.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any arguments are invalid, such as incorrect dimensions, invalid thresholds, or mismatched sizes for paths or ranks.</li><li>For an extended error list, see the default version of <code>decsvd!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TensorTrainFactorization.jl#LL2457-L2489">source</a></section></article><h1 id="TT"><a class="docs-heading-anchor" href="#TT">TT</a><a id="TT-1"></a><a class="docs-heading-anchor-permalink" href="#TT" title="Permalink"></a></h1><p>This section covers functions related to the TT module of the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.TT" href="#TensorRefinement.TensorTrain.TT"><code>TensorRefinement.TensorTrain.TT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TT{T&lt;:Number, N}</code></pre><p>A tensor train (TT) structure that represents a given tensor in the TT format. </p><p><strong>Fields</strong></p><ul><li><code>factors::Dec{T,N}</code>: A decomposition that contains the factors of the tensor train. </li></ul><p><strong>Constructor</strong></p><ul><li><code>TT(factors::Dec{T,N})</code>: Construct a TT object with the specified factors. </li></ul><p>Throw an <code>ArgumentError</code> if <code>N &lt; 2</code>, since no factor should have less than two rank indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(U::TT{T,N})</code></pre><p>Return the number of factors in the tensor train <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train object of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of factors in <code>U</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the lenght <code>L</code> is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL335-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ndims(U::TT{T,N})</code></pre><p>Return the number of mode dimensions of the tensor train object <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train object of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of mode dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL355-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(U::TT{T,N})</code></pre><p>Return the sizes of each mode of the tensor train object <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train object of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix of integers, where each column represents the different mode sizes for each factor contained in the tensor train.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL372-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rank" href="#LinearAlgebra.rank"><code>LinearAlgebra.rank</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank(U::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Return a vector of ranks, which consists of all first ranks of the factors in the given tensor train and the last rank of the last factor.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A vector containing the first rank of each factor in <code>U</code> as well as the last rank of the last factor in the decomposition.</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the factors in <code>U</code> have inconsistent ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL411-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.ranks" href="#TensorRefinement.TensorTrain.ranks"><code>TensorRefinement.TensorTrain.ranks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ranks(U::TT{T,N})</code></pre><p>Return the ranks of the tensor train object <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train object of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><p>Two vectors of length L: <code>p</code> and <code>q</code> where <code>p[ℓ]</code> is the first rank and <code>q[ℓ]</code> is the last rank of the ℓ-th factor in the tensor train <code>U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL392-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.deepcopy" href="#Base.deepcopy"><code>Base.deepcopy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deepcopy(U::TT{T,N})</code></pre><p>Return a deep copy of the tensor train object <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train object.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: A deep copy of <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL433-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverse!(W::TT{T,N})</code></pre><p>Reverse the order of factors in the tensor train <code>W</code> in place and transpose their ranks.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: The reversed tensor train of type <code>TT</code> with transposed ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL446-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.permutedims!" href="#Base.permutedims!"><code>Base.permutedims!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permutedims!(U::TT{T,N}, τ::Permutation)</code></pre><p>Permute the mode dimensions of each factor in the tensor train <code>U</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>τ::Permutation</code>: Permutation representing the new ordering of mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: The tensor train <code>U</code> with permuted dimensions.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the decomposition exhibits zero mode dimensions.</li><li><code>ArgumentError</code>: If τ is not a valid permutation of the mode dimensions of U.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL466-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fill!" href="#Base.fill!"><code>Base.fill!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill!(U::TT{T,N}, v::T)</code></pre><p>Fill each factor contained in the tensor train <code>U</code> with the value <code>v</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>v::T</code>: Value to fill each factor with.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Tensor train of type <code>TT</code> with each factor filled with value <code>v</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL498-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Random.rand!" href="#Random.rand!"><code>Random.rand!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand!(rng::AbstractRNG, U::TT{T,N})</code></pre><p>Fill each factor in the tensor train <code>U</code> in place with random values using the provided random number generator <code>rng</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: Random number generator to utilize for generating random values.</li><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>, whose factors are to be filled with random numbers.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Tensor train of type <code>TT</code> with each factor filled with random values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL518-L529">source</a></section><section><div><pre><code class="language-julia hljs">rand!(U::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Fill each factor in the tensor train <code>U</code> with random values in place, using the default global random number generator (<code>Random.GLOBAL_RNG</code>).</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>, whose factors are to be filled with random values.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Tensor train of type <code>TT</code> with random values filled in its factors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL538-L548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.getfirstfactor" href="#TensorRefinement.TensorTrain.getfirstfactor"><code>TensorRefinement.TensorTrain.getfirstfactor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getfirstfactor(U::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Retrieve the first factor of the tensor train <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>, where <code>T</code> is the element type and <code>N</code> is the number of dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>The first factor in the tensor train <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL693-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.getlastfactor" href="#TensorRefinement.TensorTrain.getlastfactor"><code>TensorRefinement.TensorTrain.getlastfactor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getlastfactor(U::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Retrieve the last factor of the tensor train <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>, where <code>T</code> is the element type and <code>N</code> is the number of dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>The last factor in the tensor train <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL706-L716">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.getfactor" href="#TensorRefinement.TensorTrain.getfactor"><code>TensorRefinement.TensorTrain.getfactor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getfactor(U::TT{T,N}, ℓ::Int)</code></pre><p>Return the factor at position <code>ℓ</code> in the tensor train <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>ℓ::Int</code>: Index of the factor to retrieve.</li></ul><p><strong>Returns</strong></p><ul><li><code>Factor{T,N}</code>: The factor at the specified index <code>ℓ</code> of the tensor train.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>ℓ</code> is out of valid range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL719-L733">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.setfirstfactor!" href="#TensorRefinement.TensorTrain.setfirstfactor!"><code>TensorRefinement.TensorTrain.setfirstfactor!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setfirstfactor!(U::TT{T,N}, F::Array{T,N})</code></pre><p>Set the first factor of the tensor train <code>U</code> to <code>F</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>F::Array{T,N}</code>: New factor to replace the current first factor with.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: Modified tensor train <code>U</code> with the first factor set to <code>F</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL742-L753">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.setlastfactor!" href="#TensorRefinement.TensorTrain.setlastfactor!"><code>TensorRefinement.TensorTrain.setlastfactor!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setlastfactor!(U::TT{T,N}, F::Array{T,N})</code></pre><p>Set the last factor of the tensor train <code>U</code> to <code>F</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>F::Array{T,N}</code>: New factor to replace the current last factor with.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: Modified tensor train <code>U</code> with the last factor set to <code>F</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL759-L770">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.setfactor!" href="#TensorRefinement.TensorTrain.setfactor!"><code>TensorRefinement.TensorTrain.setfactor!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setfactor!(U::TT{T,N}, F::Array{T,N}, ℓ::Int)</code></pre><p>Set the factor at position <code>ℓ</code> in the tensor train <code>U</code> to <code>F</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>F::Array{T,N}</code>: New factor to replace the current factor at index <code>ℓ</code> with.</li><li><code>ℓ::Int</code>: The index of the factor to set.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: Modified tensor train <code>U</code> with the factor at index <code>ℓ</code> set to <code>F</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>ℓ</code> is out of valid range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL776-L791">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.rankselect!" href="#TensorRefinement.TensorTrain.rankselect!"><code>TensorRefinement.TensorTrain.rankselect!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rankselect!(U::TT{T,N}, α::Indices, β::Indices)</code></pre><p>Select the first rank dimensions of the first factor and the last rank dimensions of the last factor in the tensor train <code>U</code> based on the provided indices <code>α</code> and <code>β</code>, modifying <code>U</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>α::Indices</code>: Reference numbers for selecting the first rank dimensions of the first factor of <code>U</code>.</li><li><code>β::Indices</code>: Reference numbers for selecting the last rank dimensions of the last factor of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Tensor train type <code>TT</code>, with the selected ranks. </li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the tensor train is empty, or if <code>α</code> or <code>β</code> contain invalid or empty ranges.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If the range for the first rank is empty.</li><li><code>ArgumentError</code>: If the range for the first rank is incorrect.</li><li><code>ArgumentError</code>: If the range for the second rank is empty.</li><li><code>ArgumentError</code>: If the range for the second rank is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL801-L823">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.rankselect" href="#TensorRefinement.TensorTrain.rankselect"><code>TensorRefinement.TensorTrain.rankselect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rankselect(U::TT{T,N}, α::Indices, β::Indices)</code></pre><p>Create a new tensor train object by selecting the first rank dimensions of the first factor and the last rank dimensions of the last factor in the tensor train <code>U</code> based on the provided indices <code>α</code> and <code>β</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>α::Indices</code>: Reference numbers for selecting the first rank dimensions of the first factor of <code>U</code>.</li><li><code>β::Indices</code>: Reference numbers for selecting the last rank dimensions of the last factor of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: New tensor train object, with the selected ranks.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decomposition is empty, or if <code>α</code> or <code>β</code> contain invalid or empty ranges.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If the range for the first rank is empty.</li><li><code>ArgumentError</code>: If the range for the first rank is incorrect.</li><li><code>ArgumentError</code>: If the range for the second rank is empty.</li><li><code>ArgumentError</code>: If the range for the second rank is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL849-L871">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(U::TT{T,N}, α::Indices, β::Indices) where {T&lt;:Number,N}</code></pre><p>Create a new tensor train object by selecting the first rank dimensions of the first factor and the last rank dimensions of the last factor in the tensor train <code>U</code> based on the provided indices <code>α</code> and <code>β</code>. Function acts as an alias for <a href="index.html#TensorRefinement.TensorTrain.rankselect"><code>rankselect</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>α::Indices</code>: Reference numbers for selecting the first rank dimensions of the first factor of <code>U</code>.</li><li><code>β::Indices</code>: Reference numbers for selecting the last rank dimensions of the last factor of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: New tensor train object, with the selected ranks.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the decomposition is empty, or if <code>α</code> or <code>β</code> contain invalid or empty ranges.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If the range for the first rank is empty.</li><li><code>ArgumentError</code>: If the range for the first rank is incorrect.</li><li><code>ArgumentError</code>: If the range for the second rank is empty.</li><li><code>ArgumentError</code>: If the range for the second rank is incorrect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL878-L901">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append!(U::TT{T,N}, V::TT{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number,N}</code></pre><p>Append the tensor train type <code>V</code> to the end of the tensor train type <code>U</code> in place. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Target tensor train of type <code>TT</code> to which <code>V</code> will be appended.</li><li><code>V::TT{T,N}</code>: Tensor Train of type <code>TT</code>, which to append to <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> and <code>V</code> before appending.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the combined result after appending.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified tensor train type <code>U</code> after appending <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V are inconsistent in the number of dimensions.</li><li><code>ArgumentError</code>:If the factors of U have incorrect or inconsistent ranks.</li><li><code>ArgumentError</code>: If the factors of V have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL904-L927">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepend!(U::TT{T,N}, V::TT{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number,N}</code></pre><p>Prepend the tensor train type <code>V</code> to the beginnning of the tensor train type <code>U</code> in place. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Target tensor train of type <code>TT</code>, to which <code>V</code> will be prepended.</li><li><code>V::TT{T,N}</code>: Tensor train of type <code>TT</code>, which to append to <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> and <code>V</code> before prepending.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the combined result after prepending.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified tensor train type <code>U</code> after prepending <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if the ranks of their factors are incorrect or inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V have different numbers of dimensions.</li><li><code>ArgumentError</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>ArgumentError</code>: If the factors of V have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL951-L974">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push!(U::TT{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number,N}</code></pre><p>Push a factor <code>V</code> to the end of the tensor train type <code>U</code> in place. Optionally, the ranks before and after the operation are checked.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Target tensor train of type <code>TT</code>, to which the factor <code>V</code> will be pushed.</li><li><code>V::Factor{T,N}</code>: The factor to push to the tensor train type <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> before pushing.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the result after pushing.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified tensor train type <code>U</code> after pushing <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if their ranks (in case of <code>U</code>, the ranks of its factors) are inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V have different numbers of dimensions.</li><li><code>ArgumentError</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL997-L1019">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pushfirst!" href="#Base.pushfirst!"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pushfirst!(U::TT{T,N}, V::Factor{T,N}; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number,N}</code></pre><p>Push a factor <code>V</code> to the beginning of the tensor train type <code>U</code> in place. Optionally, the ranks before and after the operation are checked.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Target tensor train of type <code>TT</code>, to which the factor <code>V</code> will be pushed at the beginning.</li><li><code>V::Factor{T,N}</code>: The factor to push to the beginning of <code>U</code>.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), the ranks of <code>U</code> are checked before pushing.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), the ranks of the result are checked after pushing.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified tensor train type <code>U</code> after pushing <code>V</code> at the beginning.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>DimensionMismatch</code>: If <code>U</code> and <code>V</code> have different numbers of dimensions, or if their ranks (in case of <code>U</code>, the ranks of its factors) are inconsistent with the operation.</li></ul><p>Extended Error list:</p><ul><li><code>DimensionMismatch</code>: If U and V have different numbers of dimensions.</li><li><code>DimensionMismatch</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1040-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pop!(U::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Pop the last factor from the tensor train type <code>U</code> and return it.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>, from which to pop the last factor.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The last factor that was removed from <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1085-L1095">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.popfirst!" href="#Base.popfirst!"><code>Base.popfirst!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">popfirst!(U::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Pop the first factor from the tensor train type <code>U</code> and return it.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>, from which to pop the first factor.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The first factor that was removed from <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1100-L1110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.insert!" href="#Base.insert!"><code>Base.insert!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert!(U::TT{T,N}, ℓ::Int, V::Factor{T,N}; path::String=&quot;&quot;, rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number,N}</code></pre><p>Insert a factor <code>V</code> into the tensor train type <code>U</code> at the specified index <code>ℓ</code>. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>(U::TT{T,N}</code>: Tensor train of type <code>TT</code>, in which to insert the factor <code>V</code>.</li><li><code>ℓ::Int</code>: The index at which to insert the factor <code>V</code>.</li><li><code>V::Factor{T,N}</code>: The factor to insert into the decomposition <code>U</code>.</li><li><code>path::String=&quot;&quot;</code>: The path direction for insertion; should be &quot;forward&quot; or &quot;backward&quot;.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> before insertion.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the result after insertion.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified tensor train type <code>U</code> after inserting <code>V</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If <code>path</code> is not &quot;forward&quot; or &quot;backward&quot;.</li><li><code>DimensionMismatch</code>: If <code>ℓ</code> is out of range or if the ranks (of <code>U</code>, <code>V</code> or the factors of <code>U</code>) are inconsistent for the operation.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If path is neither &quot;forward&quot; nor &quot;backward&quot;</li><li><code>ArgumentError</code>: If ℓ is not from 1:L, where L is the number of factors in <code>U</code>.</li><li><code>DimensionMismatch</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U and V are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1115-L1141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.deleteat!" href="#Base.deleteat!"><code>Base.deleteat!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deleteat!(U::TT{T,N}, Λ::Path; rankprecheck::Bool=true, rankpostcheck::Bool=true) where {T&lt;:Number,N}</code></pre><p>Delete factors from the tensor train type <code>U</code> at the specified indices <code>Λ</code> in place. Optionally, the ranks are checked before and after the operation.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>, from which factors will be deleted.</li><li><code>Λ::Path</code>: Indices of factors to delete. Can be a single integer, a vector of integers, or a tuple of integers.</li><li><code>rankprecheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of <code>U</code> before deletion.</li><li><code>rankpostcheck::Bool=true</code>: If <code>true</code> (by default), checks the ranks of the result after deletion.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Modified tensor train type <code>U</code> after deleting the specified factors.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the entries of <code>Λ</code> are not unique or are not within the valid range.</li><li><code>DimensionMismatch</code>: If the ranks of <code>U</code> are inconsistent for this operation.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>:  If the entries of Λ are not unique.</li><li><code>ArgumentError</code>: If Λ is not an element or a subset of 1:L with unique entries, where L is the number of factors in U.</li><li><code>DimensionMismatch</code>: If the factors of U have incorrect or inconsistent ranks.</li><li><code>DimensionMismatch</code>: If the ranks of U are inconsistent for this operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1168-L1192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.compose!" href="#TensorRefinement.TensorTrain.compose!"><code>TensorRefinement.TensorTrain.compose!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose!(W::TT{T,N}, Λ::Path; path::String=&quot;&quot;, major::String=&quot;last&quot;)</code></pre><p>Contract the factors of the tensor train <code>W</code> along the path specified by <code>Λ</code>, modifying <code>W</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>Λ::Path</code>: Indices along which to perform contractions. Can be a <code>Colon</code> to select all factors or a vector of integers.</li><li><code>path::String=&quot;&quot;</code>: Direction of contraction, either <code>&quot;forward&quot;</code> or <code>&quot;backward&quot;</code>. Defaults to <code>&quot;&quot;</code>, which deduces the path from <code>Λ</code>.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: Modified tensor train <code>W</code> with factors contracted along the specified path.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If <code>Λ</code> has duplicate entries, is out of the valid range, or if <code>path</code> or <code>major</code> are set to invalid values.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If path is none of the following: &quot;&quot;,  &quot;forward&quot; or &quot;backward&quot;.</li><li><code>ArgumentError</code>: If major is none of the following: &quot;last&quot; (default) or &quot;first&quot;.</li><li><code>ArgumentError</code>: If path is neither &quot;forward&quot; nor &quot;backward&quot;, when Λ is neither empty nor a colon.</li><li><code>ArgumentError</code>: If Λ has duplicate entries.</li><li><code>ArgumentError</code>: If non-empty Λ is neither a colon nor a Vector/NTuple/UnitRange of Int (from 1:L-1 for path=&quot;forward&quot; and from 2:L for path=&quot;backward&quot;, where L is the number of factors in W)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1219-L1243">source</a></section><section><div><pre><code class="language-julia hljs">compose!(W::TT{T,N}; path::String=&quot;&quot;, major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Contract all factors of the tensor train <code>W</code> in place along the specified path.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>path::String=&quot;&quot;</code>: Direction of contraction.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: The modified tensor train after performing the contraction of all factors along the specified path.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If path is none of the following: &quot;&quot;,  &quot;forward&quot; or &quot;backward&quot;.</li><li><code>ArgumentError</code>: If major is none of the following: &quot;last&quot; (default) or &quot;first&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1276-L1292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.compose" href="#TensorRefinement.TensorTrain.compose"><code>TensorRefinement.TensorTrain.compose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(W::TT{T,N}, Λ::Path; path::String=&quot;&quot;, major::String=&quot;last&quot;)</code></pre><p>Create a new tensor train that is a deepcopy of <code>W</code>, with the factors along the path specified by <code>Λ</code> contracted.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>Λ::Path</code>: Indices along which to perform contractions. Can be a <code>Colon</code> to select all factors or a vector of integers.</li><li><code>path::String=&quot;&quot;</code>: Direction of contraction, either <code>&quot;forward&quot;</code> or <code>&quot;backward&quot;</code>. Defaults to <code>&quot;&quot;</code>, which deduces the path from <code>Λ</code>.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: New tensor train object of type <code>TT</code>, obtained by contracting a deepcopy of <code>W</code> along the specified path.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If <code>Λ</code> has duplicate entries, is out of the valid range, or if <code>path</code> or <code>major</code> are set to invalid values.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If path is none of the following: &quot;&quot;,  &quot;forward&quot; or &quot;backward&quot;.</li><li><code>ArgumentError</code>: If major is none of the following: &quot;last&quot; (default) or &quot;first&quot;.</li><li><code>ArgumentError</code>: If path is neither &quot;forward&quot; nor &quot;backward&quot;, when Λ is neither empty nor a colon.</li><li><code>ArgumentError</code>: If Λ has duplicate entries.</li><li><code>ArgumentError</code>: If non-empty Λ is neither a colon nor a Vector/NTuple/UnitRange of Int (from 1:L-1 for path=&quot;forward&quot; and from 2:L for path=&quot;backward&quot;, where L is the number of factors in W)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1295-L1319">source</a></section><section><div><pre><code class="language-julia hljs">compose(W::TT{T,N}; path::String=&quot;&quot;, major::String=&quot;last&quot;) where {T&lt;:Number,N}</code></pre><p>Contract all the factors of the tensor train <code>W</code> along the specified path and return a new tensor train.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>path::String=&quot;&quot;</code>: Direction of contraction.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new tensor train with all the factors contracted along the specified path.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If path is none of the following: &quot;&quot;,  &quot;forward&quot; or &quot;backward&quot;.</li><li><code>ArgumentError</code>: If major is none of the following: &quot;last&quot; (default) or &quot;first&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1325-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.composecore!" href="#TensorRefinement.TensorTrain.composecore!"><code>TensorRefinement.TensorTrain.composecore!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composecore!(U::TT{T,N}; major::String=&quot;last&quot;)</code></pre><p>Contract all factors of the tensor train <code>U</code> in place and return the resulting tensor.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>. Defaults to <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Factor{T,N}</code>: Final tensor obtained by contracting all the factors of <code>U</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>major</code> is set to a value different from &quot;last&quot; (default) or &quot;first&quot;&quot;.</li><li><code>ArgumentError</code>: If the decomposition is empty.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1375-L1390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.composecore" href="#TensorRefinement.TensorTrain.composecore"><code>TensorRefinement.TensorTrain.composecore</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composecore(W::TT{T,N}; major::String=&quot;last&quot;)</code></pre><p>Compute the tensor of a tensor train <code>W</code>, which results from contracting all its factors.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>. Defaults to <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Factor{T,N}</code>: Final tensor obtained by contracting all the factors of <code>W</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>major</code> is set to a value different from &quot;last&quot; (default) or &quot;first&quot;&quot;.</li><li><code>ArgumentError</code>: If the decomposition is empty.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1344-L1359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.composeblock!" href="#TensorRefinement.TensorTrain.composeblock!"><code>TensorRefinement.TensorTrain.composeblock!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composeblock!(U::TT{T,N}, α::Int, β::Int; major::String=&quot;last&quot;)</code></pre><p>Contract the factors of the tensor train <code>U</code> after having selected the first and last rank of the tensor train via indices <code>α</code> and <code>β</code>, modifying <code>U</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>α::Int</code>: Index for the first rank of the block.</li><li><code>β::Int</code>: Index for the second rank of the block.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>. Defaults to <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Factor{T,N}</code>: Final tensor after contracting the factors of <code>U</code> exhibiting the selected first and last rank.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>α</code> or <code>β</code> are out of range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1396-L1412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.composeblock" href="#TensorRefinement.TensorTrain.composeblock"><code>TensorRefinement.TensorTrain.composeblock</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composeblock(U::TT{T,N}, α::Int, β::Int; major::String=&quot;last&quot;)</code></pre><p>Create a new tensor obtained by contracting the factors of a deep copy of the tensor train <code>U</code> after having selected the first and last rank of the tensor train via indices <code>α</code> and <code>β</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>α::Int</code>: Index for the first rank of the block.</li><li><code>β::Int</code>: Index for the second rank of the block.</li><li><code>major::String=&quot;last&quot;</code>: The major ordering of dimensions for the contraction. Either <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>. Defaults to <code>&quot;last&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Factor{T,N}</code>: Final tensor after contracting the factors of the deepcopy of <code>U</code> exhibiting the selected first and last rank.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>α</code> or <code>β</code> are out of range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1425-L1441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcat(U::TT{T,N}, V::TT{T,N}, W::Vararg{TT{T,N},M})</code></pre><p>Vertically concatenate the given tensor trains <code>U</code>, <code>V</code> and any additional tensor trains <code>W...</code>, to form a new tensor train <code>Z</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: First tensor train of type <code>TT</code>.</li><li><code>V::TT{T,N}</code>: Second tensor train of type <code>TT</code>.</li><li><code>W::Vararg{TT{T,N},M}</code>: Additional tensor trains to include in the concatenation.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train <code>Z</code> that is the vertical concatenation of <code>U</code>, <code>V</code>, and any additional tensor trains.</li></ul><p><strong>Throws</strong></p><ul><li><p><code>ArgumentError</code>: If the number of factors, mode size, or ranks of the tensor trains are incompatible.</p></li><li><p><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors.</p></li><li><p><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</p></li><li><p><code>ArgumentError</code>: If the decompositions are incompatible in the last rank.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1448-L1467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hcat(U::TT{T,N}, V::TT{T,N}, W::Vararg{TT{T,N},M})</code></pre><p>Horizontally concatenate the given tensor trains <code>U</code>, <code>V</code> and any additional tensor trains <code>W...</code>, to form a new tensor train <code>Z</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: First tensor train of type <code>TT</code>.</li><li><code>V::TT{T,N}</code>: Second tensor train of type <code>TT</code>.</li><li><code>W::Vararg{TT{T,N},M}</code>: Additional tensor trains to concatenate.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train <code>Z</code> that is the horizontal concatenation of <code>U</code>, <code>V</code>, and any additional tensor trains.</li></ul><p><strong>Throws</strong></p><ul><li><p><code>ArgumentError</code>: If the number of factors, mode size, or ranks of the tensor trains are incompatible.</p></li><li><p><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors.</p></li><li><p><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</p></li><li><p><code>ArgumentError</code>: If the decompositions are incompatible in the first rank.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1491-L1510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.dcat" href="#TensorRefinement.TensorTrain.dcat"><code>TensorRefinement.TensorTrain.dcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcat(U::TT{T,N}, V::TT{T,N}, W::Vararg{TT{T,N},M})</code></pre><p>Diagonally concatenate the given tensor trains <code>U</code>, <code>V</code> and any additional tensor trains <code>W...</code>, to form a new tensor train <code>Z</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: First tensor train of type <code>TT</code>.</li><li><code>V::TT{T,N}</code>: Second tensor train of type <code>TT</code>.</li><li><code>W::Vararg{TT{T,N},M}</code>: Additional tensor trains to concatenate.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train <code>Z</code> that is the diagonal concatenation of <code>U</code>, <code>V</code> and any additional tensor trains.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the decompositions are incompatible in the number of factors.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1534-L1550">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lmul!" href="#LinearAlgebra.lmul!"><code>LinearAlgebra.lmul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lmul!(α::T, U::TT{T,N})</code></pre><p>Scale the tensor train <code>U</code> in place by multiplying its last factor by a value <code>α</code>.</p><p><strong>Arguments</strong></p><ul><li><code>α::T</code>: Value of type <code>T</code> to multiply with.</li><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: Modified tensor train <code>U</code> after scaling its last factor by <code>α</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1569-L1580">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rmul!" href="#LinearAlgebra.rmul!"><code>LinearAlgebra.rmul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rmul!(U::TT{T,N}, α::T) where {T&lt;:Number,N}</code></pre><p>Scale the tensor train <code>U</code> in place by multiplying its last factor by a value <code>α</code>. Function acts as a wrapper around <a href="index.html#LinearAlgebra.lmul!"><code>lmul!</code></a> to allow for the arguments&#39; order to be changed.</p><p><strong>Arguments</strong></p><ul><li><code>α::T</code>: Value of type <code>T</code> to multiply with.</li><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: Modified tensor train <code>U</code> after scaling its last factor by <code>α</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1587-L1599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.mul" href="#TensorRefinement.TensorTrain.mul"><code>TensorRefinement.TensorTrain.mul</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mul(U₁::TT{T,N₁}, σ₁::Indices, U₂::TT{T,N₂}, σ₂::Indices)</code></pre><p>Multiply two tensor trains <code>U₁</code> and <code>U₂</code> along the specified sets of modes <code>σ₁</code> and <code>σ₂</code>, respectively, and return a new tensor train.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::TT{T,N₁}</code>: First tensor train of type <code>TT</code>.</li><li><code>σ₁::Indices</code>: Indices of modes for the first tensor train to be contracted along.</li><li><code>U₂::TT{T,N₂}</code>: Second tensor train of type <code>TT</code>.</li><li><code>σ₂::Indices</code>: Indices of modes for the second tensor train to be contracted along.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train obtaied by the multiplication of <code>U₁</code> and <code>U₂</code> along the specified modes.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> differ in the number of factors.</li><li><code>ArgumentError</code>: If σ₁ is passed as a vector, and it is not a vector of type Vector{Int} or an empty vector of type Vector{Any}.</li><li><code>ArgumentError</code>: If σ₂ is passed as a vector, and it is not a vector of type Vector{Int} or an empty vector of type Vector{Any}.</li><li><code>ArgumentError</code>: If the specified sets of modes of σ₁ and σ₂ are inconsistent.</li><li><code>ArgumentError</code>: If the set of modes of U₁ is specified incorrectly.</li><li><code>ArgumentError</code>: If the set of modes of U₂ is specified incorrectly.</li><li><code>ArgumentError</code>: If U₁ and U₂ are inconsistent with respect to the specified modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1634-L1656">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.had" href="#TensorRefinement.TensorTrain.had"><code>TensorRefinement.TensorTrain.had</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">had(U::TT{T,N}, V::TT{T,N})</code></pre><p>Perform the Hadamard product of two tensor trains <code>U</code> and <code>V</code>, and yield the new tensor train.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: First tensor train of type <code>TT</code>.</li><li><code>V::TT{T,N}</code>: Second tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train obtained by the element-wise multiplication of the factors of tensor trains <code>U</code> and <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> differ in the number of factors.</li><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> are inconsistent in mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1688-L1703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*" href="#Base.:*"><code>Base.:*</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(α::T, U::TT{T,N})</code></pre><p>Create a new tensor train by multiplying the last factor of the deepcopy of <code>U</code> by a value <code>α</code>.</p><p><strong>Arguments</strong></p><ul><li><code>α::T</code>: Value of type <code>T</code> to multiply with.</li><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train <code>V</code> that is a deepcopy of <code>U</code> with its last factor scaled by <code>α</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1602-L1613">source</a></section><section><div><pre><code class="language-julia hljs">*(U::TT{T,N}, α::T) where {T&lt;:Number,N}</code></pre><p>Create a new tensor train by multiplying the last factor of the deepcopy of <code>U</code> by a value <code>α</code>. Function acts as a wrapper around the default function <a href="index.html#Base.:*"><code>*</code></a> to allow for the arguments&#39; order to be interchanged.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>α::T</code>: Value of type <code>T</code> to multiply with.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train <code>V</code> that is a deepcopy of <code>U</code> with its last factor scaled by <code>α</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1619-L1631">source</a></section><section><div><pre><code class="language-julia hljs">*(U::TT{T,N}, V::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Perform the Hadamard product of two tensor trains <code>U</code> and <code>V</code>, and yield the new tensor train. Funcion is an alias for <a href="index.html#TensorRefinement.TensorTrain.had"><code>had</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: First tensor train of type <code>TT</code>.</li><li><code>V::TT{T,N}</code>: Second tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train obtained by the element-wise multiplication of the factors of tensor trains <code>U</code> and <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> differ in the number of factors.</li><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> are inconsistent in mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1716-L1732">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kron(U₁::Dec{T,N}, U₂::Dec{T,N})</code></pre><p>Compute the Kronecker product of two decompositions <code>U₁</code> and <code>U₂</code> of type <code>Dec</code>, and return the result as a new tensor train.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li><li><code>U₂::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, , which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train of type <code>TT</code> obtained as the Kronecker product of <code>U₁</code> and <code>U₂</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> differ in the number of factors. </li><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> are inconsistent in the number of mode dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1735-L1750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.:⊗" href="#TensorRefinement.TensorTrain.:⊗"><code>TensorRefinement.TensorTrain.:⊗</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊗(U₁::Dec{T,N}, U₂::Dec{T,N})</code></pre><p>An alias for <code>kron(U₁, U₂)</code>. Compute the Kronecker product of two decompositions <code>U₁</code> and <code>U₂</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::Dec{T,N}</code>: First decomposition of type <code>Dec</code>, which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li><li><code>U₂::Dec{T,N}</code>: Second decomposition of type <code>Dec</code>, , which represents a vector of factors with elements of type <code>T</code> and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train of type <code>TT</code> obtained as the Kronecker product of <code>U₁</code> and <code>U₂</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1763-L1774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.add" href="#TensorRefinement.TensorTrain.add"><code>TensorRefinement.TensorTrain.add</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add(U::TT{T,N}, V::TT{T,N})</code></pre><p>Add two tensor trains <code>U</code> and <code>V</code> and return a new tensor train object that represents their sum.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: First tensor train of type <code>TT</code>.</li><li><code>V::TT{T,N}</code>: Second tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train <code>W</code> obtained as the sum of <code>U</code> and <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If U and V differ in the number of factors.</li><li><code>ArgumentError</code>: If U and V are inconsistent in mode size.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the first rank.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the last rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1777-L1794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+" href="#Base.:+"><code>Base.:+</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(U::TT{T,N}, V::TT{T,N}) where {T&lt;:Number,N}</code></pre><p>Add two tensor trains <code>U</code> and <code>V</code> and return a new tensor train object that represents their sum. Function is an alias for <a href="index.html#TensorRefinement.TensorTrain.add"><code>add</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>U::TT{T,N}</code>: First tensor train of type <code>TT</code>.</li><li><code>V::TT{T,N}</code>: Second tensor train of type <code>TT</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>TT{T,N}</code>: New tensor train <code>W</code> obtained as the sum of <code>U</code> and <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If U and V differ in the number of factors.</li><li><code>ArgumentError</code>: If U and V are inconsistent in mode size.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the first rank.</li><li><code>ArgumentError</code>: If the decompositions are incompatible in the last rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1824-L1842">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.qr!" href="#LinearAlgebra.qr!"><code>LinearAlgebra.qr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr!(W::TT{T,N}, Λ::Path; path::String=&quot;&quot;) where {T&lt;:FloatRC,N}</code></pre><p>Perform an in-place QR decomposition on the specified factors of the tensor train <code>W</code>. </p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>Λ::Path</code>: Path along which to perform the QR decomposition. Can be specified as a range, a vector of integers, or <code>Colon</code>.</li><li><code>path::String=&quot;&quot;</code>: Specifies the direction of the decomposition. Can be <code>&quot;forward&quot;</code> for left-to-right decomposition, <code>&quot;backward&quot;</code> for right-to-left decomposition, or an empty string <code>&quot;&quot;</code> to automatically deduce the path based on <code>Λ</code>.</li></ul><p><strong>Returns</strong></p><ul><li>Modified tensor train <code>W</code> after performing the QR decomposition along the specified path.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the tensor train <code>W</code> is empty.</li><li><code>ArgumentError</code>: If <code>path</code> is none of the following: <code>&quot;forward&quot;</code>, <code>&quot;backward&quot;</code>, or an empty string.</li><li><code>ArgumentError</code>: If <code>path</code> cannot be deduced from Λ or path is not specified when <code>Λ</code> is a colon.</li><li><code>ArgumentError</code>: If <code>Λ</code> has duplicate entries.</li><li><code>ArgumentError</code>: If the entries of <code>Λ</code> do not form a set of contiguous integers.</li><li><code>ArgumentError</code>: If <code>Λ</code> is out of the valid range <code>1:L</code> where <code>L</code> is the length of the tensor train <code>W</code>.</li><li><code>ArgumentError</code>: If <code>Λ</code> is neither sorted in ascending nor in descending order, leading to inconsitency with either &quot;forward&quot; or &quot;backward&quot; <code>path</code>.</li><li><code>ArgumentError</code>: If <code>Λ</code> is not sorted in ascending order, rendering it inconsistent with any forward path.</li><li><code>ArgumentError</code>: If <code>Λ</code> is not sorted in descending order, rendering it inconsistent with any backward path.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1845-L1868">source</a></section><section><div><pre><code class="language-julia hljs">qr!(W::TT{T,N}; path::String=&quot;&quot;) where {T&lt;:FloatRC,N}</code></pre><p>Perform an in-place QR decomposition on all the factors of the tensor train <code>W</code>.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train of type <code>TT</code>.</li><li><code>path::String=&quot;&quot;</code>: Specifies the direction of the decomposition. Can be <code>&quot;forward&quot;</code> for left-to-right decomposition or <code>&quot;backward&quot;</code> for right-to-left decomposition.</li></ul><p><strong>Returns</strong></p><ul><li>Modified tensor train <code>W</code> after performing the QR decomposition along the specified path.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the tensor train <code>W</code> is empty.</li><li><code>ArgumentError</code>: If <code>path</code> is not specified as <code>&quot;forward&quot;</code> or <code>&quot;backward&quot;</code> (Notice: Λ is a colon, thus path must be specified)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1921-L1936">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.svd!" href="#LinearAlgebra.svd!"><code>LinearAlgebra.svd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd!(W::TT{T,N}, Λ::Path, n::Union{Colon,DecSize}; path::String=&quot;&quot;, aTol::Float2=0.0, aTolDistr::Float2=0.0, rTol::Float2=0.0, rTolDistr::Float2=0.0, maxrank::Int2=0, major::String=&quot;last&quot;)</code></pre><p>Perform an in-place singular value decomposition (SVD) with specified path and tolerances on the tensor train <code>W</code>. Assume that the decomposition <code>W</code> is orthogonal.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train to be decomposed in-place.</li><li><code>Λ::Path</code>: Path along which to perform the SVD. Can be a colon (<code>:</code>) or a vector of integers.</li><li><code>n::Union{Colon,DecSize}</code>: Specifies target dimensions of the factors after decomposition. Can be a colon (<code>:</code>) or a size matrix.</li><li><code>path::String</code>: Specifies the direction of the decomposition. Accepts <code>&quot;&quot;</code> (default), <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>aTol::Float2</code>: Absolute tolerance for truncation. Can be a single float or a vector of floats.</li><li><code>aTolDistr::Float2</code>: Absolute tolerance for distributed truncation. Can be a single float or a vector of floats.</li><li><code>rTol::Float2</code>: Relative tolerance for truncation. Can be a single float or a vector of floats.</li><li><code>rTolDistr::Float2</code>: Relative tolerance for distributed truncation. Can be a single float or a vector of floats.</li><li><code>maxrank::Int2</code>: Maximum rank for truncation. Can be a single integer or a vector of integers.</li><li><code>major::String</code>: Specifies whether to prioritize the first or last indices during the operation. Acceptable values are <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W::TT{T,N}</code>: Modified tensor train after performing the in-place SVD.</li><li><code>ε::Vector{Float64}</code>: Vector of absolute errors for each factor.</li><li><code>δ::Vector{Float64}</code>: Vector of relative errors for each factor.</li><li><code>μ::Float64</code>: Norm of the core tensor after the decomposition.</li><li><code>ρ::Vector{Int}</code>: Vector of ranks for each factor.</li><li><code>σ::Vector{Vector{Float64}}</code>: Vector of singular values for each factor.</li></ul><p><strong>Throws</strong></p><p>Summarized Error List:</p><ul><li><code>ArgumentError</code>: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.</li></ul><p>Extended Error List:</p><ul><li><code>ArgumentError</code>: If the decomposition is empty.</li><li><code>ArgumentError</code>: If path is none of the following: &quot;&quot; (default, accepted only when path can be deduced from Λ), &quot;forward&quot; or &quot;backward&quot;&quot;.</li><li><code>ArgumentError</code>: If path cannot be deduced from Λ or is the path is neither &quot;forward&quot; nor &quot;backward&quot; when Λ is a colon.</li><li><code>ArgumentError</code>: If the entries of Λ should form a set of contiguous integers&quot;)</li><li><code>ArgumentError</code>: If Λ is out of range.</li><li><code>ArgumentError</code>: If Λ is not sorted in ascending or descending order, rendering it inconsistent with any forward or backward path.</li><li><code>ArgumentError</code>: If Λ is not sorted in ascending order, rendering it inconsistent with any forward path.</li><li><code>ArgumentError</code>: If Λ is not sorted in descending order, rendering it inconsistent with any backward path.</li><li><code>ArgumentError</code>: If the number of rows in n is not equal to the number of dimensions in each factor of W.</li><li><code>ArgumentError</code>: If the number of columns in n is not equal to the number of elements in Λ.</li><li><code>ArgumentError</code>: If n and Λ are incompatible with the size of the factors of W.</li><li><code>ArgumentError</code>: If aTol is not a nonnegative Float64 or a vector of such.</li><li><code>ArgumentError</code>: If aTol, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If aTolDistr is not a nonnegative Float64 or a vector of such.</li><li><code>ArgumentError</code>: If aTolDistr, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If rTol is not a nonnegative Float64 or a vector of such.</li><li><code>ArgumentError</code>: If rTol, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If rTolDistr is not a nonnegative Float64 or a vector of such.</li><li><code>ArgumentError</code>: If rTolDistr, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If maxrank is not a nonnegative Int or a vector of such.</li><li><code>ArgumentError</code>: If maxrank, passed as a vector, has incorrect length.</li><li><code>ArgumentError</code>: If major is neither &quot;last&quot; (default) nor &quot;first&quot;&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL1939-L1991">source</a></section><section><div><pre><code class="language-julia hljs">svd!(W::TT{T,N}, Λ::Path, n::Union{Colon,DecSize}; path::String=&quot;&quot;, aTol::Float2=0.0, aTolDistr::Float2=0.0, rTol::Float2=0.0, rTolDistr::Float2=0.0, maxrank::Int2=0, major::String=&quot;last&quot;)</code></pre><p>Perform an in-place singular value decomposition (SVD) of the in <code>Λ</code> specified factors with automatically deduced target dimensions of the factors. Consider specified path and tolerances on the tensor train <code>W</code>. Assume that the decomposition <code>W</code> is orthogonal.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train to be decomposed in-place.</li><li><code>Λ::Path</code>: Path along which to perform the SVD. Can be a colon (<code>:</code>) or a vector of integers.</li><li><code>path::String</code>: Specifies the direction of the decomposition. Accepts <code>&quot;&quot;</code> (default), <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>aTol::Float2</code>: Absolute tolerance for truncation. Can be a single float or a vector of floats.</li><li><code>aTolDistr::Float2</code>: Absolute tolerance for distributed truncation. Can be a single float or a vector of floats.</li><li><code>rTol::Float2</code>: Relative tolerance for truncation. Can be a single float or a vector of floats.</li><li><code>rTolDistr::Float2</code>: Relative tolerance for distributed truncation. Can be a single float or a vector of floats.</li><li><code>maxrank::Int2</code>: Maximum rank for truncation. Can be a single integer or a vector of integers.</li><li><code>major::String</code>: Specifies whether to prioritize the first or last indices during the operation. Acceptable values are <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W::TT{T,N}</code>: Modified tensor train after performing the in-place SVD.</li><li><code>ε::Vector{Float64}</code>: Vector of absolute errors for each factor.</li><li><code>δ::Vector{Float64}</code>: Vector of relative errors for each factor.</li><li><code>μ::Float64</code>: Norm of the core tensor after the decomposition.</li><li><code>ρ::Vector{Int}</code>: Vector of ranks for each factor.</li><li><code>σ::Vector{Vector{Float64}}</code>: Vector of singular values for each factor.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.</li><li>For full error control, see default <code>svd!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL2121-L2149">source</a></section><section><div><pre><code class="language-julia hljs">svd!(W::TT{T,N}, Λ::Path, n::Union{Colon,DecSize}; path::String=&quot;&quot;, aTol::Float2=0.0, aTolDistr::Float2=0.0, rTol::Float2=0.0, rTolDistr::Float2=0.0, maxrank::Int2=0, major::String=&quot;last&quot;)</code></pre><p>Perform an in-place singular value decomposition (SVD) of all factors with automatically deduced target dimensions of the factors. Consider specified path and tolerances on the tensor train <code>W</code>. Assume that the decomposition <code>W</code> is orthogonal.</p><p><strong>Arguments</strong></p><ul><li><code>W::TT{T,N}</code>: Tensor train to be decomposed in-place.</li><li><code>path::String</code>: Specifies the direction of the decomposition. Accepts <code>&quot;&quot;</code> (default), <code>&quot;forward&quot;</code>, or <code>&quot;backward&quot;</code>.</li><li><code>aTol::Float2</code>: Absolute tolerance for truncation. Can be a single float or a vector of floats.</li><li><code>aTolDistr::Float2</code>: Absolute tolerance for distributed truncation. Can be a single float or a vector of floats.</li><li><code>rTol::Float2</code>: Relative tolerance for truncation. Can be a single float or a vector of floats.</li><li><code>rTolDistr::Float2</code>: Relative tolerance for distributed truncation. Can be a single float or a vector of floats.</li><li><code>maxrank::Int2</code>: Maximum rank for truncation. Can be a single integer or a vector of integers.</li><li><code>major::String</code>: Specifies whether to prioritize the first or last indices during the operation. Acceptable values are <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>W::TT{T,N}</code>: Modified tensor train after performing the in-place SVD.</li><li><code>ε::Vector{Float64}</code>: Vector of absolute errors for each factor.</li><li><code>δ::Vector{Float64}</code>: Vector of relative errors for each factor.</li><li><code>μ::Float64</code>: Norm of the core tensor after the decomposition.</li><li><code>ρ::Vector{Int}</code>: Vector of ranks for each factor.</li><li><code>σ::Vector{Vector{Float64}}</code>: Vector of singular values for each factor.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any input arguments are invalid, for example incorrect dimensions, negative values where non-negative are expected or invalid strings for path or major.</li><li>For full error control, see default <code>svd!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/a4b6e2b114a5ed20bc2107b6acb747f824cd43c6/src/TT.jl#LL2152-L2179">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Tuesday 17 September 2024 11:44">Tuesday 17 September 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
