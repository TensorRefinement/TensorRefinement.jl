<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TensorRefinement.jl</title><meta name="title" content="Home · TensorRefinement.jl"/><meta property="og:title" content="Home · TensorRefinement.jl"/><meta property="twitter:title" content="Home · TensorRefinement.jl"/><meta name="description" content="Documentation for TensorRefinement.jl."/><meta property="og:description" content="Documentation for TensorRefinement.jl."/><meta property="twitter:description" content="Documentation for TensorRefinement.jl."/><meta property="og:url" content="https://TensorRefinement.github.io/TensorRefinement.jl/index.html"/><meta property="twitter:url" content="https://TensorRefinement.github.io/TensorRefinement.jl/index.html"/><link rel="canonical" href="https://TensorRefinement.github.io/TensorRefinement.jl/index.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">TensorRefinement.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/master/docs/src/index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TensorRefinement"><a class="docs-heading-anchor" href="#TensorRefinement">TensorRefinement</a><a id="TensorRefinement-1"></a><a class="docs-heading-anchor-permalink" href="#TensorRefinement" title="Permalink"></a></h1><ul><li><a href="index.html#TensorRefinement.TensorTrain.Factor"><code>TensorRefinement.TensorTrain.Factor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.FactorSize"><code>TensorRefinement.TensorTrain.FactorSize</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.MatrixFactor"><code>TensorRefinement.TensorTrain.MatrixFactor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.VectorFactor"><code>TensorRefinement.TensorTrain.VectorFactor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.block"><code>TensorRefinement.TensorTrain.block</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factor"><code>TensorRefinement.TensorTrain.factor</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorcontract"><code>TensorRefinement.TensorTrain.factorcontract</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factordcat"><code>TensorRefinement.TensorTrain.factordcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factordiagm"><code>TensorRefinement.TensorTrain.factordiagm</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorhcat"><code>TensorRefinement.TensorTrain.factorhcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorhp"><code>TensorRefinement.TensorTrain.factorhp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorkp"><code>TensorRefinement.TensorTrain.factorkp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorltcat"><code>TensorRefinement.TensorTrain.factorltcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormatrix"><code>TensorRefinement.TensorTrain.factormatrix</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormodereshape"><code>TensorRefinement.TensorTrain.factormodereshape</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormodetranspose"><code>TensorRefinement.TensorTrain.factormodetranspose</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factormp"><code>TensorRefinement.TensorTrain.factormp</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorndims"><code>TensorRefinement.TensorTrain.factorndims</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factornumentries"><code>TensorRefinement.TensorTrain.factornumentries</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorqr!"><code>TensorRefinement.TensorTrain.factorqr!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorqradd"><code>TensorRefinement.TensorTrain.factorqradd</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorranks"><code>TensorRefinement.TensorTrain.factorranks</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorrankselect"><code>TensorRefinement.TensorTrain.factorrankselect</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorranktranspose"><code>TensorRefinement.TensorTrain.factorranktranspose</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorsize"><code>TensorRefinement.TensorTrain.factorsize</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorstorage"><code>TensorRefinement.TensorTrain.factorstorage</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorsvd!"><code>TensorRefinement.TensorTrain.factorsvd!</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorutcat"><code>TensorRefinement.TensorTrain.factorutcat</code></a></li><li><a href="index.html#TensorRefinement.TensorTrain.factorvcat"><code>TensorRefinement.TensorTrain.factorvcat</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factor" href="#TensorRefinement.TensorTrain.factor"><code>TensorRefinement.TensorTrain.factor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factor(U::Array{T,N}) where {T&lt;:Number,N}</code></pre><p>Reshape a given tensor <code>U</code> into a factor that can be used in further TT-operations.</p><p><strong>Arguments</strong></p><ul><li><code>U::Array{T, N}</code>: Multi-dimensional array with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped version of the tensor <code>U</code> with a single first and last dimension to facilitate TT-operations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL131-L141">source</a></section><section><div><pre><code class="language-julia hljs">factor(U::Matrix{T}, m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}, 
       n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}, 
       π::Union{NTuple{K,Int}, Vector{Int}}) where {T&lt;:Number, K, M, N}</code></pre><p>Reshape a matrix <code>U</code> into a multi-dimensional array with specified mode sizes <code>m</code> and <code>n</code>,  and permute the mode dimensions according to the permutation <code>π</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Matrix{T}</code>: Input matrix with elements of type <code>T</code>.</li><li><code>m::Union{Int, NTuple{M,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the first dimension of <code>U</code>.</li><li><code>n::Union{Int, NTuple{N,Int}, Vector{Int}, Vector{Any}}</code>: Mode sizes for the second dimension of <code>U</code>.</li><li><code>π::Union{NTuple{K,Int}, Vector{Int}}</code>: Permutation of the mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped and permuted tensor based on the provided mode sizes <code>m</code>, <code>n</code>, and permutation <code>π</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>π</code> is empty or not a valid permutation of <code>1:length(m) + length(n)</code>.</li><li><code>ArgumentError</code>: If <code>m</code> or <code>n</code> is none of the following: integer, vector or tuple of integers, empty vector or tuple. </li><li><code>DimensionMismatch</code>: If the dimensions of <code>U</code> are not divisible by the products of <code>m</code> or <code>n</code>, respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL146-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.FactorSize" href="#TensorRefinement.TensorTrain.FactorSize"><code>TensorRefinement.TensorTrain.FactorSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Factorsize is an alias for a</code>Vector{Int}`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.Factor" href="#TensorRefinement.TensorTrain.Factor"><code>TensorRefinement.TensorTrain.Factor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Factor{T,N}</code> is an alias for <code>Array{T,N} where {T&lt;:Number,N}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.VectorFactor" href="#TensorRefinement.TensorTrain.VectorFactor"><code>TensorRefinement.TensorTrain.VectorFactor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>VectorFactor{T}</code> is a 3D tensor with entries of type T`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.MatrixFactor" href="#TensorRefinement.TensorTrain.MatrixFactor"><code>TensorRefinement.TensorTrain.MatrixFactor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>MatrixFactor{T}</code> is a 4D tensor with entries of type T`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorsize" href="#TensorRefinement.TensorTrain.factorsize"><code>TensorRefinement.TensorTrain.factorsize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorsize(U::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Determine the sizes of the mode dimensions of the given factor <code>U</code> in a vector, excluding the first and last dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: factor of type <code>Factor</code> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>Factorsize(n)</code>: custom type <code>Factorsize</code> that holds the mode dimensions of <code>U</code> excluding the first and last dimension as a vector.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If factor exhibits only one or no rank dimension.</li><li><code>ArgumentError</code>: If factor exhibits negative mode size.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">U = Factor(rand(3, 4, 5, 6, 7))  # Initialization of random Factor
size_vector = factorsize(U)  # Returns vector containing all but the first and last dimensions
println(size_vector)  # Outputs FactorSize([4, 5, 6]) where Factorsize = Vector{Int}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL31-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorranks" href="#TensorRefinement.TensorTrain.factorranks"><code>TensorRefinement.TensorTrain.factorranks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorranks(U::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Determine the first and last rank dimension of a given factor <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple <code>(sz[1], sz[end])</code> where <code>sz[1]</code> is the first and <code>sz[end]</code> is the last dimension of the input tensor.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If factor exhibits only one or no rank dimension.</li><li><code>ArgumentError</code>: If factor exhibits negative mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL65-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorndims" href="#TensorRefinement.TensorTrain.factorndims"><code>TensorRefinement.TensorTrain.factorndims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorndims(::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Return the number of mode dimensions excluding the first and last dimension.</p><p><strong>Arguments</strong></p><ul><li><code>::Factor{T, N}</code>: factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>An integer representing the number of mode dimensions, which is <code>N - 2</code> (number of entries in <a href="index.html#TensorRefinement.TensorTrain.factorsize"><code>factorsize</code></a>).</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If factor exhibits only one or no rank dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL110-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factornumentries" href="#TensorRefinement.TensorTrain.factornumentries"><code>TensorRefinement.TensorTrain.factornumentries</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factornumentries(U::Factor{T,N}) where {T&lt;:Number,N}</code></pre><p>Determine the number of entries in the given factor.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>An integer specifiying the number of entries in the given [<code>Factor</code>].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorstorage" href="#TensorRefinement.TensorTrain.factorstorage"><code>TensorRefinement.TensorTrain.factorstorage</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An alias for the function factornumentries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL105-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormatrix" href="#TensorRefinement.TensorTrain.factormatrix"><code>TensorRefinement.TensorTrain.factormatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormatrix(U::Factor{T,K}, π::Indices, σ::Indices) where {T&lt;:Number, K}</code></pre><p>Convert a factor <code>U</code> into a matrix by permuting and reshaping the mode dimensions according to the specified indices <code>π</code> and <code>σ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,K}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>K</code> dimensions.</li><li><code>π::Indices</code>: Reference numbers specifying the permutation of mode dimensions for the first dimension of the resulting matrix.</li><li><code>σ::Indices</code>: Reference numbers specifying the permutation of mode dimensions for the second dimension of the resulting matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix obtained by permuting and reshaping <code>U</code> according to the specified indices <code>π</code> and <code>σ</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> does not have at least one mode dimension.</li><li><code>ArgumentError</code>: If <code>π</code> or <code>σ</code> are not valid indices or do not constitute a valid permutation of mode dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL208-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorrankselect" href="#TensorRefinement.TensorTrain.factorrankselect"><code>TensorRefinement.TensorTrain.factorrankselect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorrankselect(U::Factor{T,N}, α::Indices, β::Indices) where {T&lt;:Number, N}</code></pre><p>Select specific slices from a factor <code>U</code> based on the provided rank indices <code>α</code> and <code>β</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>α::Indices</code>: Reference numbers for selecting slices along the first rank dimension.</li><li><code>β::Indices</code>: Reference numbers for selecting slices along the second rank dimension.</li></ul><p><strong>Returns</strong></p><ul><li>A sub-array of <code>U</code> corresponding to the specified slices.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the indices <code>α</code> or <code>β</code> are incorrect or out of range for the respective rank dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL249-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.block" href="#TensorRefinement.TensorTrain.block"><code>TensorRefinement.TensorTrain.block</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">block(U::Factor{T,N}, α::Int, β::Int) where {T&lt;:Number, N}</code></pre><p>Extracts a specific block from the factor <code>U</code> based on the provided rank indices <code>α</code> and <code>β</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>α::Int</code>: Reference numbers for selecting the slice along the first rank dimension.</li><li><code>β::Int</code>: Reference numbers for selecting the slice along the second rank dimension.</li></ul><p><strong>Returns</strong></p><ul><li>A sub-array representing the block corresponding to the specified rank indices.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the indices <code>α</code> or <code>β</code> are out of range for the respective rank dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL281-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorvcat" href="#TensorRefinement.TensorTrain.factorvcat"><code>TensorRefinement.TensorTrain.factorvcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorvcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T&lt;:Number, N, M}</code></pre><p>Vertically concatenate the factors <code>U</code>, <code>V</code>, and additional factors in <code>W</code> along the first rank dimension.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor to be concatenated. Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor to be concatenated. Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>W::Vararg{Factor{T,N},M}</code>: Additional factors to be concatenated, each of Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the vertical concatenation of <code>U</code>, <code>V</code>, and the additional factors in <code>W</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the factors have incompatible mode sizes or second ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL311-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorhcat" href="#TensorRefinement.TensorTrain.factorhcat"><code>TensorRefinement.TensorTrain.factorhcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorhcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T&lt;:Number, N, M}</code></pre><p>Horizontally concatenate the factors <code>U</code>, <code>V</code>, and additional factors in <code>W</code> along the second rank dimension.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor to be concatenated. Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor to be concatenated. Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>W::Vararg{Factor{T,N},M}</code>: Additional factors to be concatenated, each of Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the horizontal concatenation of <code>U</code>, <code>V</code>, and the additional factors in <code>W</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the factors have incompatible mode sizes or first ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL342-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factordcat" href="#TensorRefinement.TensorTrain.factordcat"><code>TensorRefinement.TensorTrain.factordcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factordcat(U::Factor{T,N}, V::Factor{T,N}, W::Vararg{Factor{T,N},M}) where {T&lt;:Number, N, M}</code></pre><p>Concatenate the factors <code>U</code>, <code>V</code>, and additional factors in <code>W</code> along the mode dimensions and the second rank dimension.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor to be concatenated. Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor to be concatenated. Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>W::Vararg{Factor{T,N},M}</code>: Additional factors to be concatenated, each of Of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the concatenation of <code>U</code>, <code>V</code>, and the additional factors in <code>W</code> along the mode dimensions and the second rank dimension.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the factors have incompatible mode sizes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL374-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorltcat" href="#TensorRefinement.TensorTrain.factorltcat"><code>TensorRefinement.TensorTrain.factorltcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorltcat(U₁₁::Factor{T,N}, U₂₁::Factor{T,N}, U₂₂::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Concatenate three factors <code>U₁₁</code>, <code>U₂₁</code>, and <code>U₂₂</code> in a lower triangular block matrix form.</p><p><strong>Arguments</strong></p><ul><li><code>U₁₁::Factor{T,N}</code>: First factor for the upper left block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₂₁::Factor{T,N}</code>: Second factor for the lower left block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₂₂::Factor{T,N}</code>: Third factor for the lower right block, with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor representing the lower triangular concatenation of <code>U₁₁</code>, <code>U₂₁</code>, and <code>U₂₂</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the factors are incompatible in mode size or rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL436-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorutcat" href="#TensorRefinement.TensorTrain.factorutcat"><code>TensorRefinement.TensorTrain.factorutcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorutcat(U₁₁::Factor{T,N}, U₁₂::Factor{T,N}, U₂₂::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Concatenate three factors <code>U₁₁</code>, <code>U₁₂</code>, and <code>U₂₂</code> in an upper triangular block matrix form.</p><p><strong>Arguments</strong></p><ul><li><code>U₁₁::Factor{T,N}</code>: First factor for the upper left block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₁₂::Factor{T,N}</code>: Second factor for the upper right block, with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>U₂₂::Factor{T,N}</code>: Third factor for the lower right block, with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor representing the upper triangular concatenation of <code>U₁₁</code>, <code>U₁₂</code>, and <code>U₂₂</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the factors are incompatible in mode size or rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL402-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorranktranspose" href="#TensorRefinement.TensorTrain.factorranktranspose"><code>TensorRefinement.TensorTrain.factorranktranspose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorranktranspose(U::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Transpose the rank dimensions of the factor <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor with the rank dimensions of <code>U</code> transposed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL470-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormodetranspose" href="#TensorRefinement.TensorTrain.factormodetranspose"><code>TensorRefinement.TensorTrain.factormodetranspose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormodetranspose(U::Factor{T,N}, π::NTuple{K,Int}) where {T&lt;:Number, N, K}</code></pre><p>Permute the mode dimensions of the factor <code>U</code> according to the permutation <code>π</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>π::NTuple{K,Int}</code>: Permutation of the mode dimensions of <code>U</code>. Should contain exactly <code>K = N - 2</code> elements, which are a valid permutation of <code>1:d</code> where <code>d</code> is the number of mode dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from permuting the mode dimensions of <code>U</code> according to <code>π</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> has fewer than one mode dimension.</li><li><code>ArgumentError</code>: If <code>π</code> is not a valid permutation of the mode dimensions of <code>U</code>.</li><li><code>ArgumentError</code>: If <code>π</code> is not a valid permutation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL487-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormodereshape" href="#TensorRefinement.TensorTrain.factormodereshape"><code>TensorRefinement.TensorTrain.factormodereshape</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormodereshape(U::Factor{T,N}, n::FactorSize) where {T&lt;:Number, N}</code></pre><p>Reshape the mode dimensions of the factor <code>U</code> to the specified sizes in <code>n</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>n::FactorSize</code>: Vector specifying the new sizes for the mode dimensions. Product of <code>n</code> must equal the product of current mode sizes of <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from reshaping the mode dimensions of <code>U</code> to <code>n</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the product of <code>n</code> does not equal the product of the current mode sizes of <code>U</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL522-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factordiagm" href="#TensorRefinement.TensorTrain.factordiagm"><code>TensorRefinement.TensorTrain.factordiagm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factordiagm(U::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Create a tensor with diagonal properties from the factor <code>U</code> by placing the elements of <code>U</code> along the diagonal of a larger-dimensional tensor.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor that represents a tensor with diagonal properties constructed from <code>U</code>, dimensions expanded.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> has fewer than one mode dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL548-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorcontract" href="#TensorRefinement.TensorTrain.factorcontract"><code>TensorRefinement.TensorTrain.factorcontract</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorcontract(U::Factor{T,N}, V::Factor{T,N}; rev::Bool=false, major::String=&quot;last&quot;) where {T&lt;:Number, N}</code></pre><p>Contract two factors <code>U</code> and <code>V</code> along their shared rank dimensions. Function supports contracting in different orientations and orders based on parameters <code>rev</code> and <code>major</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>rev::Bool=false</code>: If <code>true</code>, reverse the roles of <code>U</code> and <code>V</code> in the contraction.</li><li><code>major::String=&quot;last&quot;</code>: Specifies major contraction order. Must be either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from contracting <code>U</code> and <code>V</code> along their shared rank dimensions.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have inconsistent ranks</li><li><code>ArgumentError</code>: If <code>major</code> is not <code>&quot;last&quot;</code> or <code>&quot;first&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL577-L594">source</a></section><section><div><pre><code class="language-julia hljs">factorcontract(U::Factor{T,N}, V::S) where {T&lt;:Number, N, S&lt;:AbstractMatrix{T}}</code></pre><p>Contract a factor <code>U</code> with a matrix <code>V</code>, aligning the rank dimensions and performing matrix multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li><li><code>V::S</code>: Matrix of type <code>S</code> and elements of type <code>T</code> to contract with <code>U</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the contraction of <code>U</code> with <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have inconsistent ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL620-L634">source</a></section><section><div><pre><code class="language-julia hljs">factorcontract(U::S, V::Factor{T,N}) where {T&lt;:Number, N, S&lt;:AbstractMatrix{T}}</code></pre><p>Contracts a matrix <code>U</code> with a factor <code>V</code>, aligning the rank dimensions and performing matrix multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>U::S</code>: Matrix of type <code>S</code> and elements of type <code>T</code> to contract with <code>V</code>.</li><li><code>V::Factor{T,N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the contraction of <code>U</code> with <code>V</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> have inconsistent ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL647-L661">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factormp" href="#TensorRefinement.TensorTrain.factormp"><code>TensorRefinement.TensorTrain.factormp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factormp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T&lt;:Number, N₁, N₂}</code></pre><p>Perform a mode-wise multiplication (contraction) of two factors <code>U₁</code> and <code>U₂</code> along specified modes <code>σ₁</code> and <code>σ₂</code>. Operation contracts the specified modes, while the remaining dimensions of the factors are combined.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::Factor{T,N₁}</code>: First factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N₁</code> dimensions.</li><li><code>σ₁::Indices</code>: Reference numbers specifying which modes of <code>U₁</code> to use in the contraction. Can be a vector of integers or an empty vector.</li><li><code>U₂::Factor{T,N₂}</code>: Second factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N₂</code> dimensions.</li><li><code>σ₂::Indices</code>: Reference numbers specifying which modes of <code>U₂</code> to use in the contraction. Can be a vector of integers or an empty vector.</li></ul><p><strong>Returns</strong></p><ul><li>A new factor resulting from the mode-wise multiplication of <code>U₁</code> and <code>U₂</code>, with contracted modes combined and the remaining dimensions preserved.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>σ₁</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If <code>σ₂</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If the specified sets of modes of σ₁ and σ₂ are inconsistent.</li><li><code>ArgumentError</code>: If the set of modes of <code>U₁</code> is specified incorrectly.</li><li><code>ArgumentError</code>: If the set of modes of U₂ is specified incorrectly.</li><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> are inconsistent with respect to the specified modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL677-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorkp" href="#TensorRefinement.TensorTrain.factorkp"><code>TensorRefinement.TensorTrain.factorkp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorkp(U::Union{Factor{T,N}, Pair{Factor{T,N},Int}}, V::Vararg{Union{Factor{T,N}, Pair{Factor{T,N},Int}},M}) where {T&lt;:Number,N,M}</code></pre><p>Perform a Kronecker product of multiple factors (optionally raised to specified nonnegative integer exponents).</p><p><strong>Arguments</strong></p><ul><li><code>U::Union{Factor{T, N}, Pair{Factor{T, N}, Int}}</code>: first factor can either be a <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> type or a pair <code>(Factor, Int)</code>. If given as a pair, the integer is the exponent for the respective factor in the Kronecker product.</li><li><code>V::Vararg{Union{Factor{T, N}, Pair{Factor{T, N}, Int}}, M}</code>: variable number (denoted by M) of additional factors, each of which can also be either a <code>Factor</code> type or a pair <code>(Factor, Int)</code>. The same usage for the integer applies as in the above line.</li></ul><p><strong>Returns</strong></p><ul><li><code>W</code>: resulting tensor (or matrix if d = 0) after the Kronecker products of all provided factors (with optionally some factors exponentiated). Final tensor is a result of a series of multiplications and reshaping operations.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If a negative exponent is provided in a pair <code>(Factor, Int)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL772-L786">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorhp" href="#TensorRefinement.TensorTrain.factorhp"><code>TensorRefinement.TensorTrain.factorhp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorhp(U::Factor{T,N}, V::Factor{T,N}) where {T&lt;:Number, N}</code></pre><p>Compute the higher-order tensor product of two factors <code>U</code> and <code>V</code>. Resulting factor has dimensions formed by multiplying the ranks and mode sizes of <code>U</code> and <code>V</code>.</p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T,N}</code>: First factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> dimensions.</li><li><code>V::Factor{T,N}</code>: Second factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> dimensions.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped tensor representing the higher-order product of <code>U</code> and <code>V</code>, with dimensions <code>(p * r, n..., q * s)</code> where:<ul><li><code>(p, q)</code> are the ranks of <code>U</code>.</li><li><code>(r, s)</code> are the ranks of <code>V</code>.</li><li><code>n</code> represents the mode sizes of <code>U</code> and <code>V</code>.</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>U</code> and <code>V</code> do not have the same mode size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL834-L851">source</a></section><section><div><pre><code class="language-julia hljs">factorhp(U₁::Factor{T,N₁}, σ₁::Indices, U₂::Factor{T,N₂}, σ₂::Indices) where {T&lt;:Number, N₁, N₂}</code></pre><p>Compute the higher-order tensor product of two factors <code>U₁</code> and <code>U₂</code> along specified modes <code>σ₁</code> and <code>σ₂</code>. Function allows for a flexible contraction over selected modes.</p><p><strong>Arguments</strong></p><ul><li><code>U₁::Factor{T,N₁}</code>: First factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N₁</code> dimensions.</li><li><code>σ₁::Indices</code>: Reference numbers specifying which modes of <code>U₁</code> to use in the contraction. Can be a vector of integers or an empty vector.</li><li><code>U₂::Factor{T,N₂}</code>: Second factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> and <code>N₂</code> dimensions.</li><li><code>σ₂::Indices</code>: Reference numbers specifying which modes of <code>U₂</code> to use in the contraction. Can be a vector of integers or an empty vector.</li></ul><p><strong>Returns</strong></p><ul><li>A reshaped tensor representing the higher-order product of <code>U₁</code> and <code>U₂</code>, contracted over the specified modes.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If <code>σ₁</code> or <code>σ₂</code> are incorrectly specified or inconsistent with the dimensions of <code>U₁</code> or <code>U₂</code>.</li><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> are inconsistent with respect to the specified modes.</li></ul><p>Extended Error list:</p><ul><li><code>ArgumentError</code>: If <code>σ₁</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If <code>σ₂</code> is passed as a vector, but it is not of type Vector{Int} and it is not an empty vector of the type Vector{Any}.</li><li><code>ArgumentError</code>: If the specified sets of modes of <code>σ₁</code> and <code>σ₂</code> are inconsistent.</li><li><code>ArgumentError</code>: If the set of modes of <code>U₁</code> is specified incorrectly.</li><li><code>ArgumentError</code>: If the set of modes of <code>U₂</code> is specified incorrectly.</li><li><code>ArgumentError</code>: If <code>U₁</code> and <code>U₂</code> are inconsistent with respect to the specified modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL866-L893">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorqr!" href="#TensorRefinement.TensorTrain.factorqr!"><code>TensorRefinement.TensorTrain.factorqr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorqr!(U::Factor{T,N}; rev::Bool=false, factf=(rev ? A -&gt; LinearAlgebra.lq!(A) : A -&gt; LinearAlgebra.qr!(A))) where {T&lt;:FloatRC, N}</code></pre><p>Perform a QR or LQ factorization of the tensor <code>U</code>, depending on the value of the keyword argument <code>rev</code> (reverse). </p><p><strong>Arguments</strong></p><ul><li><code>U::Factor{T, N}</code>: mutable factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> as the number dimensions.</li><li><code>rev::Bool=false</code>: keyword argument that determines the type of factorization. If <code>false</code>, performs a QR factorization; if <code>true</code>, performs an LQ factorization.</li><li><code>factf</code>: keyword argument that specifies the chosen factorization function. By default, <code>LinearAlgebra.qr!</code> and <code>LinearAlgebra.lq!</code> are used respectively (depending on <code>rev</code>).</li></ul><p><strong>Returns</strong></p><ul><li>tuple <code>(U, R)</code>, where:<ul><li><code>U</code>: transformed tensor after applying the QR or LQ factorization. (N-dimensional)</li><li><code>R</code>: factor tensor obtained by reshaping the factor matrix of the QR or LQ factorization (N-dimensional)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL1001-L1015">source</a></section><section><div><pre><code class="language-julia hljs">factorqr!(U::Factor{T,N}, ::Val{true}; rev::Bool=false, returnS::Bool=false,
          factf=(A -&gt; LinearAlgebra.qr!(A, LinearAlgebra.ColumnNorm()))) where {T&lt;:FloatRC, N}</code></pre><p>Perform a QR factorization of the factor <code>U</code> with optional pivoting and the ability to return an additional factor <code>S</code>. The function can cope with different orientations (via <code>rev</code>) and supports custom factorization functions.</p><p><strong>Arguments</strong></p><ul><li><p><code>U::Factor{T,N}</code>: Factor to be decomposed, of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and with <code>N</code> dimensions.</p></li><li><p><code>::Val{true}</code>: Value type that indicates that this version of <code>factorqr!</code> should be used when <code>returnS</code> is needed.</p></li><li><p><code>rev::Bool=false</code>: Keyword argument that determines the orientation of the QR factorization.</p><ul><li><code>false</code> (default): Standard QR factorization is performed.</li><li><code>true</code>: Roles of rows and columns are reversed, affecting the orientation of the factorization.</li></ul></li><li><p><code>returnS::Bool=false</code>: Keyword argument that specifies whether to return an additional factor <code>S</code> such that <code>A ⨝ S = Q</code> if <code>rev == false</code> and <code>S ⨝ A = Q</code> if <code>rev == true</code>.</p></li><li><p><code>factf</code>: Function used to perform the QR factorization, default is set to <code>LinearAlgebra.qr!</code> with column pivoting.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Q, R</code>: Factors <code>Q</code> (orthogonal) and <code>R</code> (upper triangular) from the QR decomposition.</li><li><code>Q, R, S</code>: If <code>returnS == true</code>, returns an additional factor <code>S</code> along with <code>Q</code> and <code>R</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL1042-L1064">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorqradd" href="#TensorRefinement.TensorTrain.factorqradd"><code>TensorRefinement.TensorTrain.factorqradd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorqradd(Q::Factor{T,N}, R::Union{Factor{T,N},Nothing}, U::Factor{T,N}; rev::Bool=false) where {T&lt;:FloatRC, N}</code></pre><p>Add rows or columns to an orthogonal factor <code>Q</code> and its corresponding upper triangular factor <code>R</code>, depending on the value of <code>rev</code>. This function is an extension to the QR factorization by updating the factors to incorporate a new matrix <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>Q::Factor{T,N}</code>: Orthogonal factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and <code>N</code> dimensions.</p><ul><li>If <code>rev == true</code>, <code>Q</code> is assumed to be orthogonal with respect to the first rank.</li><li>If <code>rev == false</code>, <code>Q</code> is assumed to be orthogonal with respect to the second rank.</li></ul></li><li><p><code>R::Union{Factor{T,N},Nothing}</code>: Upper triangular factor of the QR factorization. Can be of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> or <code>Nothing</code>.</p><ul><li>If <code>R</code> is <code>Nothing</code>, an identity matrix of appropriate dimensions will be used.</li></ul></li><li><p><code>U::Factor{T,N}</code>: New matrix to be added to the existing factors (same mode dimensions as <code>Q</code>).</p></li><li><p><code>rev::Bool=false</code>: Keyword argument indicating the direction of orthogonality for the operation. </p><ul><li><code>false</code> (default): Assumes <code>Q</code> to be orthogonal with respect to the second rank, and columns will be added.</li><li><code>true</code>: Assumes <code>Q</code> to be orthogonal with respect to the first rank, and rows will be added.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Q</code>: Updated orthogonal factor after incorporating <code>U</code>.</li><li><code>R</code>: Updated upper triangular factor after incorporating <code>U</code>.</li></ul><p><strong>Throws</strong></p><p>Summarized Error list:</p><ul><li><code>ArgumentError</code>: If the mode sizes of <code>Q</code> and <code>U</code> are incompatible.</li><li><code>ArgumentError</code>: If <code>R</code> has incompatible rank or mode dimensions with <code>Q</code>.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> are incompatible in their respective ranks.</li><li><code>ArgumentError</code>: If <code>R</code> is specified and has an incompatible number of mode dimensions or rank.</li></ul><p>Extended Error List:</p><ul><li><code>ArgumentError</code>: If the mode sizes of <code>Q</code> and <code>U</code> are incompatible.</li><li><code>ArgumentError</code>: If <code>R</code> and <code>Q</code> have incompatible number of mode dimensions or incompatible number of unitary mode sizes.</li><li><code>ArgumentError</code>: If <code>R</code> and <code>Q</code> have incompatible rank.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> have incompatible second rank.</li><li><code>ArgumentError</code>: If <code>R</code>  has a different number of mode dimensions as Q or different unitary mode sizes.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>R</code> have incompatible rank.</li><li><code>ArgumentError</code>: If <code>Q</code> and <code>U</code> have incompatible first rank.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL1121-L1160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorRefinement.TensorTrain.factorsvd!" href="#TensorRefinement.TensorTrain.factorsvd!"><code>TensorRefinement.TensorTrain.factorsvd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function factorsvd!(W::Factor{T,N},
                m::Union{FactorSize,Colon},
                n::Union{FactorSize,Colon};
				soft::S=zero(S),
				hard::S=zero(S),
                atol::S=zero(S),
                rtol::S=zero(S),
                rank::Int=0,
                major::String=&quot;last&quot;,
				rev::Bool=false,
				factf=(A -&gt; LinearAlgebra.svd!(A; full=false, alg=LinearAlgebra.QRIteration())) ) where {S&lt;:AbstractFloat,T&lt;:FloatRC{S},N}</code></pre><p>Perform a singular value decomposition (SVD) of the factor <code>W</code> where the factor dimensions are adjusted accordingly and optional thresholding is carried out based on specified parameters. </p><p><strong>Arguments</strong></p><ul><li><code>W::Factor{T, N}</code>: Input factor of type <a href="index.html#TensorRefinement.TensorTrain.Factor"><code>Factor</code></a> with elements of type <code>T</code> (subtype of <code>FloatRC</code>: any real or complex floating point) and <code>N</code> dimensions.</li><li><code>m::Union{FactorSize, Colon}</code>: Mode-size parameter for first dimension. Can be a <a href="index.html#TensorRefinement.TensorTrain.FactorSize"><code>FactorSize</code></a> vector specifying the sizes of the mode dimensions or <code>Colon</code> to represent all indices.</li><li><code>n::Union{FactorSize, Colon}</code>: Mode-size parameter for second dimension. Can also be a <a href="index.html#TensorRefinement.TensorTrain.FactorSize"><code>FactorSize</code></a> vector or <code>Colon</code>.</li><li><code>soft::S=zero(S)</code>: Keyword argument specifying the soft threshold for singular value truncation. Must be nonnegative and finite.</li><li><code>hard::S=zero(S)</code>: Keyword argument specifying the hard threshold for singular value truncation. Must be nonnegative and finite.</li><li><code>atol::S=zero(S)</code>: Absolute tolerance for singular values. Must be nonnegative and finite.</li><li><code>rtol::S=zero(S)</code>: Relative tolerance for singular values. Must be nonnegative and finite.</li><li><code>rank::Int=0</code>: Maximum allowable rank for the truncated SVD. Must be nonnegative.</li><li><code>major::String=&quot;last&quot;</code>: Specifies the major contraction order. Must be either <code>&quot;last&quot;</code> (default) or <code>&quot;first&quot;</code>.</li><li><code>rev::Bool=false</code>: Boolean indicating whether to reverse the dimensions in the output.</li><li><code>factf</code>: Function used to perform the SVD. Default sets it to a function using <code>LinearAlgebra.svd!</code> with <code>QRIteration</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: The left singular vectors after applying SVD, reshaped based on the specified parameters (and potentially truncated).</li><li><code>V</code>: The right singular vectors after applying SVD, reshaped similarly (and also potentially truncated).</li><li><code>ε</code>: The effective noise level that stems from thresholding.</li><li><code>δ</code>: The relative noise level, calculated as <code>ε / μ</code>.</li><li><code>μ</code>: The norm of the input factor <code>W</code>.</li><li><code>ρ</code>: The rank of the truncated SVD.</li><li><code>σ</code>: A vector of the singular values (after thresholding).</li></ul><p><strong>Throws</strong></p><p>Summarized Error List:</p><ul><li><code>ArgumentError</code>: If both <code>m</code> and <code>n</code> are specified as <code>Colon</code>, this causes ambiguity.</li><li><code>ArgumentError</code>: If either <code>m</code> or <code>n</code> is specified with non-positive or inconsistent dimensions.</li><li><code>ArgumentError</code>: If <code>major</code> is not <code>&quot;first&quot;</code> or <code>&quot;last&quot;</code>.</li><li><code>ArgumentError</code>: If <code>soft</code>, <code>hard</code>, <code>atol</code>, or <code>rtol</code> are negative or not finite.</li><li><code>ArgumentError</code>: If <code>rank</code> is negative.</li><li><code>DimensionMismatch</code>: If mode-size vectors <code>m</code> and <code>n</code> are inconsistent with dimensions of <code>W</code>.</li><li><code>ErrorException</code>: If numerical issues such as overflow or underflow occur during computations.</li></ul><p>Full Error List:</p><ul><li><p><code>ArgumentError</code>: If both <code>m</code> and <code>n</code> are specified as <code>Colon</code>, this causes ambiguity.</p></li><li><p><code>ArgumentError</code>: If the elements of the first mode-size vector are not positive.</p></li><li><p><code>ArgumentError</code>: If the elements of the second mode-size vector are not positive.</p></li><li><p><code>ArgumentError</code>: If <code>major</code> is neither &quot;last&quot; (default) nor &quot;first&quot;.</p></li><li><p><code>ArgumentError</code>: If <code>soft</code> is negative or infinite.</p></li><li><p><code>ArgumentError</code>: If <code>hard</code> is negative or finite.</p></li><li><p><code>ArgumentError</code>: If <code>atol</code> is negative or infinte.</p></li><li><p><code>ArgumentError</code>:  If <code>rtol</code> is negative or infinte.</p></li><li><p><code>ArgumentError</code>: If optional argument rank is negative.</p></li><li><p><code>DimensionMismatch</code>: If the number of entries in the first mode-size vector is inconsistent with the specified factor.</p></li><li><p><code>DimensionMismatch</code>: If the number of entries in the second mode-size vector is inconsistent with the specified factor.</p></li><li><p><code>DimensionMismatch</code>: If not every mode dimension of W is divisible by the corresponding element of the specified mode-size vector</p></li><li><p><code>DimensionMismatch</code>: If specified mode-size vectors are inconsistent with the specified factor.</p></li><li><p><code>ErrorException</code>: If squaring <code>soft</code> leads to overflow and it was passed finite.</p></li><li><p><code>ErrorException</code>: If squaring <code>soft</code> leads to underflow and it was passed positive.</p></li><li><p><code>ErrorException</code>: If sqauring <code>hard</code> leads to overflow and it was passed finite.</p></li><li><p><code>ErrorException</code>: If squaring <code>hard</code> leads to underflow and it was passed positive.</p></li><li><p><code>ErrorException</code>: If squaring <code>atol</code> leads to overflow and it was passed finite.</p></li><li><p><code>ErrorException</code>: If squaring <code>atol</code> leads to underflow and it was passed positive.</p></li></ul><p><strong>Example</strong></p><p>```julia</p><p><strong>Assume Factor{T, N}, FactorSize, and FloatRC are properly defined and initialized</strong></p><p><strong>Initialize W as a Factor{T, N} type, for example, a decomposed tensor</strong></p><p>W = Factor(...)  # specific initialization needed</p><p><strong>Specify mode-size parameters</strong></p><p>m = FactorSize([2, 3]) n = FactorSize([2, 2])</p><p><strong>Perform SVD with pre-specified thresholds and tolerances</strong></p><p>U, V, ε, δ, μ, ρ, σ = factorsvd!(W, m, n; soft=0.5, hard=0.05, atol=1e-6, rtol=1e-3, rank=10, major=&quot;last&quot;)</p><p><strong>Output the resulting factors and singular values</strong></p><p>println(&quot;Left singular vectors (U): &quot;, U) println(&quot;Right singular vectors (V): &quot;, V) println(&quot;Effective noise level (ε): &quot;, ε) println(&quot;Relative noise level (δ): &quot;, δ) println(&quot;Norm of the input factor (μ): &quot;, μ) println(&quot;Rank of the truncated SVD (ρ): &quot;, ρ) println(&quot;Singular values after thresholding (σ): &quot;, σ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorRefinement/TensorRefinement.jl/blob/c254e6baeb4b182d6439c385bb5d9197551ae209/src/TensorTrainFactor.jl#LL1228-L1324">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Monday 2 September 2024 14:53">Monday 2 September 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
